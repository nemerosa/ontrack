# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"Any type which contains authorizations for itself"
interface Authorizable {
    "Authorizations for this context"
    authorizations: [Authorization!]!
}

"Interface implemented by all mutation payloads"
interface Payload {
    "List of errors"
    errors: [UserError]
}

"Interface implemented by all mutation payloads"
interface PayloadInterface {
    "List of errors"
    errors: [PayloadUserError]
}

interface ProjectEntity {
    creation: Signature
    description: String
    id: Int!
    name: String
}

type Account {
    "Source of authentication (builtin, ldap, etc.)"
    authenticationSource: AuthenticationSource
    "List of authorized projects"
    authorizedProjects: [AuthorizedProject!]!
    "List of groups contributed to this account. Some groups are available only after the user has logged in."
    contributedGroups: [AccountGroup!]!
    "Is this account disabled?"
    disabled: Boolean
    "Email of the account"
    email: String!
    "Full name of the account"
    fullName: String!
    "Global role for the account"
    globalRole: GlobalRole
    "List of groups the account belongs to"
    groups: [AccountGroup!]!
    id: Int!
    "Links"
    links: AccountLinks @deprecated(reason: "Use the `actions` field instead.")
    "Is this account locked (meaning that no change can be performed)?"
    locked: Boolean
    "Unique name for the account"
    name: String
    "List of groups provided to this account. Some groups are available only after the user has logged in."
    providedGroups: [String!]!
    "Security role (admin or none)"
    role: String
    "Authentication token, if any, linked to this account."
    token: Token @deprecated(reason: "Use the list of tokens. Will be removed in V5.")
    "List of authentication tokens linked to this account."
    tokens: [Token!]!
}

type AccountGroup {
    "List of associated accounts"
    accounts: [Account!]!
    "List of authorized projects"
    authorizedProjects: [AuthorizedProject!]!
    description: String
    "Global role for the account group"
    globalRole: GlobalRole
    id: Int!
    "Links"
    links: AccountGroupLinks @deprecated(reason: "Use the `actions` field instead.")
    "Mappings for this group"
    mappings: [AccountGroupMapping!]!
    name: String
}

"AccountGroup links"
type AccountGroupLinks {
    _delete: String
    _self: String
    _update: String
}

type AccountGroupMapping {
    "Associated authentication source"
    authenticationSource: AuthenticationSource
    "Associated group"
    group: AccountGroup
    id: Int!
    "Name of the mapping"
    name: String
}

"Account links"
type AccountLinks {
    _delete: String
    _generateToken: String
    _revokeToken: String
    _self: String
    _token: String
    _update: String
}

type Action {
    "enabled field"
    enabled: Boolean
    id: String
    name: String
    type: String
    uri: String
}

"Authentication source for an account or group."
type AuthenticationSource {
    "Is this authentication source allowing to change a password?"
    allowingPasswordChange: Boolean!
    "Is this authentication source enabled?"
    enabled: Boolean!
    "Does this authentication source support external groups?"
    groupMappingSupported: Boolean!
    "Key for this source"
    key: String!
    "Display name for this source"
    name: String!
    "Name of the provider for this authentication source"
    provider: String!
}

"A named authorization"
type Authorization {
    "Action to authorize"
    action: String!
    "Authorized?"
    authorized: Boolean!
    "Name of the authorization scope"
    name: String!
}

type AuthorizedProject {
    "Authorized project"
    project: Project!
    "Role for the project"
    role: ProjectRole!
}

"Audit entry for an auto versioning processing order."
type AutoVersioningAuditEntry {
    "History of the different states"
    audit: [AutoVersioningAuditEntryState!]!
    "Elapsed time between the creation of this process and its last state (in ms)"
    duration: Int
    "Most recent state"
    mostRecentState: AutoVersioningAuditEntryState!
    "Associated auto versioning order"
    order: AutoVersioningOrder!
    "Promotion which triggered the auto-versioning"
    promotionRun: PromotionRun
    "Actual queue where the order was posted"
    queue: String
    "Queue routing key used for this order"
    routing: String!
    "Running state"
    running: Boolean
    "Actual SCM branch being used"
    upgradeBranch: String
}

type AutoVersioningAuditEntryPaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [AutoVersioningAuditEntry!]!
}

"Audit entry for an auto versioning order"
type AutoVersioningAuditEntryState {
    creation: Signature!
    "Associated data"
    data: JSON!
    "Is the state indicating a request being processed?"
    processing: Boolean!
    "Is the state indicating a running request?"
    running: Boolean!
    "State of the processing"
    state: AutoVersioningAuditState!
}

"AV trail for a specific branch"
type AutoVersioningBranchTrail {
    "Associated auto-versioning audit entry if any"
    audit: AutoVersioningAuditEntry
    "Targeted branch"
    branch: Branch!
    "Associated configuration"
    configuration: AutoVersioningSourceConfig!
    "Unique ID for this trail"
    id: String!
    "AV order ID when actually scheduled"
    orderId: String
    "Rejection reason"
    rejectionReason: String
}

"Configuration of the auto versioning on a branch."
type AutoVersioningConfig {
    "List of configurations"
    configurations: [AutoVersioningSourceConfig!]!
}

"Association of a branch with its auto versioning configuration"
type AutoVersioningConfiguredBranch {
    "Target branch for the auto-versioning"
    branch: Branch!
    "Target auto-versioning configurations on the target branch"
    configuration: AutoVersioningSourceConfig!
}

"AutoVersioningNotification"
type AutoVersioningNotification {
    "channel field"
    channel: String!
    "config field"
    config: JSON!
    "Optional notification template used to override the default text"
    notificationTemplate: String
    "scope field"
    scope: [AutoVersioningNotificationScope!]!
}

"Auto versioning processing order"
type AutoVersioningOrder {
    "additionalPaths field"
    additionalPaths: [AutoVersioningSourceConfigPath!]!
    "If the PR must be auto approved & merged"
    autoApproval: Boolean
    "Defines the way the PR is merged when auto approval is set."
    autoApprovalMode: AutoApprovalMode!
    "Target branch for the processing order"
    branch: Branch
    "Post processing type"
    postProcessing: String
    "JSON configuration for the post processing"
    postProcessingConfig: JSON
    "Link to the target repository"
    repositoryHtmlURL: String
    "List of reviewers to always add to the pull request"
    reviewers: [String!]!
    "Source project for the processing order"
    sourceProject: String!
    "Source promotion for the processing order"
    sourcePromotion: String
    "Target path(s) for the processing order"
    targetPath: String!
    "Target path(s) for the processing order"
    targetPaths: String @deprecated(reason: "Deprecated, use `targetPath`")
    "Property in the target file"
    targetProperty: String
    "Regex used in property value to identify the version"
    targetPropertyRegex: String
    "Type of the target file"
    targetPropertyType: String
    "Regex used to identify the line to update in the target files"
    targetRegex: String
    "Version to set"
    targetVersion: String!
    "Pattern for the branch being used for the update"
    upgradeBranchPattern: String!
    "UUID for the processing order"
    uuid: String!
    "Ontrack validation stamp associated with this auto versioning (used for checks)"
    validationStamp: String
}

"Configuration of the auto versioning for one source."
type AutoVersioningSourceConfig {
    "Additional paths to change"
    additionalPaths: [AutoVersioningSourceConfigPath!]
    "Check if the PR must be approved automatically or not (`true` by default)"
    autoApproval: Boolean
    "Auto approval mode"
    autoApprovalMode: AutoApprovalMode
    "Validation stamp to create on the source build (optional)"
    backValidation: String
    "Build link creation. True by default."
    buildLinkCreation: Boolean
    "List of notifications subscriptions to setup for this auto versioning"
    notifications: [AutoVersioningNotification!]
    "Type of post processing to launch after the version has been updated"
    postProcessing: String
    "Configuration of the post processing"
    postProcessingConfig: JSON
    "Template for the body of the pull request (optional)"
    prBodyTemplate: String
    "Template format for the body of the pull request (plain by default, html, markdown as possible values)"
    prBodyTemplateFormat: String
    "Template for the title of the pull request (optional)"
    prTitleTemplate: String
    "Qualifier for the build link to create (when links are created)"
    qualifier: String
    "List of reviewers to always set on the pull request created by the auto versioning"
    reviewers: [String!]
    "Branches to watch using a regular expression"
    sourceBranch: String!
    "Project to watch"
    sourceProject: String!
    "Promotion to watch"
    sourcePromotion: String!
    "Comma-separated list of file to update with the new version"
    targetPath: String!
    "Optional replacement for the regex, using only a property name"
    targetProperty: String
    "Optional regex to use on the targetProperty value"
    targetPropertyRegex: String
    "When targetProperty is defined, defines the type of property (defaults to Java properties file, but could be NPM, etc.)"
    targetPropertyType: String
    "Regex to use in the target file to identify the line to replace with the new version. The first matching group must be the version."
    targetRegex: String
    "Prefix to use for the upgrade branch in Git, defaults to `feature/auto-upgrade-<project>-<version>-<branch>`"
    upgradeBranchPattern: String
    "Validation stamp to create on auto versioning (optional)"
    validationStamp: String
    "Source of the version for the build. By default, uses the build label is the source project is configured so, or the build name itself. This allows the customization of this behavior."
    versionSource: String
}

"Configuration for an additional path in an auto-versioning configuration."
type AutoVersioningSourceConfigPath {
    "Comma-separated list of file to update with the new version"
    path: String!
    "Optional replacement for the regex, using only a property name"
    property: String
    "Optional regex to use on the property value"
    propertyRegex: String
    "When property is defined, defines the type of property (defaults to Java properties file, but could be NPM, etc.)"
    propertyType: String
    "Regex to use in the target file to identify the line to replace with the new version. The first matching group must be the version."
    regex: String
    "Source of the version for the build. By default, uses the build label is the source project is configured so, or the build name itself. This allows the customization of this behavior."
    versionSource: String
}

"Describes the history of an auto-versioning decision process"
type AutoVersioningTrail {
    "Trails per branch"
    branches: [AutoVersioningBranchTrail!]!
}

type Branch implements Authorizable & ProjectEntity {
    "Description with links."
    annotatedDescription: String
    "Synchronisation of the promotions with Artifactory build statuses"
    artifactoryPromotionSyncProperty: Property
    "Authorizations for this context"
    authorizations: [Authorization!]!
    "Auto versioning information for this build, in regards of a parent branch"
    autoVersioning(
        "ID of the parent branch. Is overridden by the buildId argument, but at least one of each is required."
        branchId: Int,
        "ID of the parent build. Takes precedence on the branchId argument, but at least one of each is required."
        buildId: Int,
        "Downstream or upstream dependencies (down by default)."
        direction: AutoVersioningDirection
    ): BuildAutoVersioning
    "Auto versioning configuration"
    autoVersioningConfig: AutoVersioningConfig
    "Actions to get a diff on builds of the branch"
    buildDiffActions: [Action!]!
    "List of forms for the build filters (for the creation of new filters)"
    buildFilterForms: [BuildFilterForm!]!
    "List of shared build filters for this branch"
    buildFilterResources: [BuildFilterResource!]!
    "Gets a list of builds for this branch. Use `buildsPaginated` to get a list of paginated builds."
    builds(
        "Maximum number of builds to return"
        count: Int,
        "Filter based on build promotions, validations, properties, ..."
        filter: StandardBuildFilter,
        "Generic filter based on a configured filter"
        generic: GenericBuildFilter,
        "Filter which returns the last promoted builds"
        lastPromotions: Boolean
    ): [Build!]!
    "Gets a list of paginated builds for this branch."
    buildsPaginated(
        "Filter based on build promotions, validations, properties, ..."
        filter: StandardBuildFilter,
        "Generic filter based on a configured filter"
        generic: GenericBuildFilter,
        "Offset for the page"
        offset: Int = 0,
        "Size of the page"
        size: Int = 20
    ): BuildPaginated
    creation: Signature
    "List of decorations"
    decorations(
        "Fully qualified name of the decoration type"
        type: String
    ): [Decoration!]!
    description: String
    disabled: Boolean!
    "Display name for this branch or the branch's name if not available"
    displayName: String!
    "List of branches this branch depends on."
    downstreamLinks(
        "Number of builds to use to get the dependencies"
        builds: Int
    ): [BranchLink!]!
    "Is this branch a favourite of the current user?"
    favourite: Boolean
    "Git branch"
    gitBranchConfigurationProperty: Property
    gitChangeLog(
        "Name of the build to start the change log with"
        from: String!,
        "Name of the build to end the change log with"
        to: String!
    ): GitChangeLog
    "Registered GitHub ingestion configuration"
    gitHubIngestionConfig: GitHubIngestionConfig
    "Graph of dependencies for this branch"
    graph(
        "Direction for the dependencies"
        direction: BranchLinksDirection!
    ): BranchLinksNode! @deprecated(reason: "Graph UI will be dropped in 4.6 and `graph` fields in 5.0.")
    id: Int!
    "List of information components attached to this entity"
    information: [EntityInformation!]!
    "Link to a Jenkins Job"
    jenkinsJobProperty: Property
    "List of links."
    linkProperty: Property
    "Links"
    links: BranchLinks @deprecated(reason: "Use the `actions` field instead.")
    "Associates an arbitrary message (and its type) to an entity. Will be displayed as a decorator in the UI."
    messageProperty: Property
    "List of meta information properties"
    metaInfoProperty: Property
    "Mock SCM used for testing only"
    mockSCMBranchProperty: Property
    name: String
    "List of other branches in the same project"
    otherBranches: [Branch!]!
    "Makes a promotion conditional based on the fact that a previous promotion has been granted."
    previousPromotionConditionProperty: Property
    "Reference to project"
    project: Project
    promotionLevels: [PromotionLevel!]!
    "Given a list of promotion names, returns for each one the last promotion run or null if the promotion does not exist."
    promotionStatuses(names: [String!]!): [PromotionRun!]!
    "List of properties"
    properties(
        "Keeps properties having a value"
        hasValue: Boolean = false,
        "Fully qualified name of the property type"
        type: String
    ): [Property!]!
    "Pull request (if any) linked to the branch"
    pullRequest: GitPullRequest
    "When set, adding a release/label on a build will also validate this build."
    releaseValidationProperty: Property
    "SCM information about the branch"
    scmBranchInfo: SCMBranchInfo
    "List of branches this branch is a dependency of."
    upstreamLinks(
        "Number of builds to use to get the dependencies"
        builds: Int
    ): [BranchLink!]!
    "List of actions available for this entity"
    userMenuActions: [UserMenuAction!]!
    "List of issues reported into the validation run statuses"
    validationIssues(
        "Maximum number of validation runs to fetch per validation stamp in order to get the issues"
        count: Int = 10,
        "Filters the validation runs according to their status"
        passed: Boolean,
        "Regular expression to filter on the validation stamps."
        stamp: String,
        "List of issue statuses to keep"
        status: [String]
    ): [ValidationIssue!]!
    "List of existing validation stamp filters for this branch."
    validationStampFilters(
        "If all project & global filters must be included as well."
        all: Boolean
    ): [ValidationStampFilter!]!
    validationStamps(
        "Filters on the validation stamp"
        name: String
    ): [ValidationStamp!]!
    "Given a list of validation names, returns for each one the last validation run or null if the validation does not exist."
    validationStatuses(names: [String!]!): [ValidationRun!]!
}

"Branch and associated information"
type BranchInfo {
    "Associated branch"
    branch: Branch
    "First build which contains the commit"
    firstBuild: Build
    "First promotion for every promotion level"
    promotions: [PromotionRun!]!
}

"Type of branch associated with information about the corresponding branches."
type BranchInfos {
    "List of branches and their associated information"
    branchInfoList: [BranchInfo!]!
    "Type of branch"
    type: String
}

"Qualified link to a branch"
type BranchLink {
    "Auto versioning information for this link, in regards to the relationship from the source branch to the target branch."
    autoVersioning: BuildAutoVersioning
    "Linked branch"
    branch: Branch!
    "Nature/qualification of the link"
    qualifier: String!
    "Last source build"
    sourceBuild: Build!
    "Last target build"
    targetBuild: Build!
}

"Branch links"
type BranchLinks {
    _actions: String
    _allValidationStampFilters: String
    _branches: String
    _buildFilterForms: String
    _buildFilterResources: String
    _buildFilterSave: String
    _buildFilterShare: String
    _bulkUpdate: String
    _clone: String
    _copy: String
    _createBuild: String
    _createPromotionLevel: String
    _createValidationStamp: String
    _decorations: String
    _delete: String
    _disable: String
    _download: String
    _enable: String
    _events: String
    _extra: String
    _favourite: String
    _page: String
    _project: String
    _promotionLevels: String
    _properties: String
    _reorderPromotionLevels: String
    _reorderValidationStamps: String
    _self: String
    _status: String
    _unfavourite: String
    _update: String
    _validationStampFilterCreate: String
    _validationStampViews: String
    _validationStamps: String
    _view: String
}

type BranchLinksDecoration {
    "Optional longer text, typically used as a tooltip"
    description: String
    "Feature contributing to this decoration"
    feature: ExtensionFeatureDescription!
    "Optional name to an image for the decoration. This name is used together with the [feature] and the [id] to build a URL on the client side"
    icon: String
    "ID of the decoration provider"
    id: String!
    "Short text to display at edge level for the decoration"
    text: String!
    "Optional link from the decoration to another page"
    url: String
}

"BranchLinksEdge"
type BranchLinksEdge {
    "decorations field"
    decorations: [BranchLinksDecoration!]!
    "direction field"
    direction: BranchLinksDirection!
    "linkedTo field"
    linkedTo: BranchLinksNode!
}

"BranchLinksNode"
type BranchLinksNode {
    "Branch associated to this node"
    branch: Branch!
    "Actual build for this node"
    build: Build
    "Edges coming out of this node to other nodes"
    edges: [BranchLinksEdge!]!
}

type Build implements Authorizable & ProjectEntity {
    "Actions for a Build"
    actions: BuildActions @deprecated(reason: "Will be removed in V5. User `userMenuActions` instead.")
    "Description with links."
    annotatedDescription: String
    "Authorizations for this context"
    authorizations: [Authorization!]!
    "Auto versioning information for this build, in regards of a parent branch"
    autoVersioning(
        "ID of the parent branch. Is overridden by the buildId argument, but at least one of each is required."
        branchId: Int,
        "ID of the parent build. Takes precedence on the branchId argument, but at least one of each is required."
        buildId: Int,
        "Downstream or upstream dependencies (down by default)."
        direction: AutoVersioningDirection
    ): BuildAutoVersioning
    "Reference to branch"
    branch: Branch
    "Link to the GitHub Workflow Run which created this build."
    buildGitHubWorkflowRunProperty: Property
    creation: Signature
    "List of decorations"
    decorations(
        "Fully qualified name of the decoration type"
        type: String
    ): [Decoration!]!
    description: String
    gitChangeLog(
        "Name of the build to end the change log with. If not set, compares with the previous build."
        to: String
    ): GitChangeLog
    "Git commit"
    gitCommitProperty: Property
    "Graph of dependencies for this build"
    graph(
        "Direction for the dependencies"
        direction: BranchLinksDirection!
    ): BranchLinksNode! @deprecated(reason: "Graph UI will be dropped in 4.6 and `graph` fields in 5.0.")
    id: Int!
    "List of information components attached to this entity"
    information: [EntityInformation!]!
    "Link to a Jenkins Build"
    jenkinsBuildProperty: Property
    "List of links."
    linkProperty: Property
    "Links"
    links: BuildLinks @deprecated(reason: "Use the `actions` field instead.")
    "Associates an arbitrary message (and its type) to an entity. Will be displayed as a decorator in the UI."
    messageProperty: Property
    "List of meta information properties"
    metaInfoProperty: Property
    "Mock SCM used for testing only"
    mockSCMBuildCommitProperty: Property
    name: String
    "Next build"
    nextBuild: Build
    "Previous build"
    previousBuild: Build
    "Promotions for this build"
    promotionRuns(
        "Returns the last promotion run per promotion level"
        lastPerLevel: Boolean,
        "Name of the promotion level"
        promotion: String
    ): [PromotionRun!]!
    "List of properties"
    properties(
        "Keeps properties having a value"
        hasValue: Boolean = false,
        "Fully qualified name of the property type"
        type: String
    ): [Property!]!
    "Release indicator on the build."
    releaseProperty: Property
    "Renders a template for this build"
    render(
        "Format of the rendering"
        format: String,
        "Template for the rendering"
        template: String
    ): String!
    "Run info associated with this build"
    runInfo: RunInfo
    "List of builds using this one."
    usedBy(
        "Keeps only links targeted from this branch. `project` argument is also required."
        branch: String,
        "Offset for the page"
        offset: Int = 0,
        "Keeps only links targeted from this project"
        project: String,
        "Size of the page"
        size: Int = 20
    ): BuildPaginated @deprecated(reason: "usedByQualified must be used instead")
    "List of builds using this one."
    usedByQualified(
        "Keeps only links targeted from this branch. `project` argument is also required."
        branch: String,
        "Offset for the page"
        offset: Int = 0,
        "Keeps only links targeted from this project"
        project: String,
        "Size of the page"
        size: Int = 20
    ): BuildLinkPaginated
    "List of actions available for this entity"
    userMenuActions: [UserMenuAction!]!
    "List of builds being used by this one."
    using(
        "Keeps only links targeted from this branch. `project` argument is also required."
        branch: String,
        "Offset for the page"
        offset: Int = 0,
        "Keeps only links targeted from this project"
        project: String,
        "Size of the page"
        size: Int = 20
    ): BuildPaginated @deprecated(reason: "usingQualified must be used instead")
    "List of builds being used by this one."
    usingQualified(
        "Keeps only links targeted from this branch. `project` argument is also required."
        branch: String,
        "If greater than 0, looks for children up to this depth"
        depth: Int = 0,
        "Label (category:name) to filter build projects with"
        label: String = "",
        "Offset for the page"
        offset: Int = 0,
        "Keeps only links targeted from this project"
        project: String,
        "Keeps only links targeted for this qualifier"
        qualifier: String,
        "Size of the page"
        size: Int = 20
    ): BuildLinkPaginated
    "Validations for this build"
    validationRuns(
        "Maximum number of validation runs"
        count: Int = 50,
        "Name of the validation stamp, can be a regular expression."
        validationStamp: String
    ): [ValidationRun!]!
    "Paginated list of validation runs"
    validationRunsPaginated(
        "Offset for the page"
        offset: Int = 0,
        "Size of the page"
        size: Int = 20,
        "Describes how the validation runs must be sorted."
        sortingMode: ValidationRunSortingMode,
        "List of statuses to select"
        statuses: [String],
        "Validation stamp to filter upon"
        validationStamp: String
    ): ValidationRunPaginated
    "Validations per validation stamp"
    validations(
        "Offset for the page"
        offset: Int = 0,
        "Size of the page"
        size: Int = 20,
        "Name of the validation stamp"
        validationStamp: String
    ): [Validation!]!
}

"Creating a validation run for this build"
type BuildActionCreateValidationRunById {
    "Description of the action"
    description: String!
    "Links attached to this action"
    links: BuildActionCreateValidationRunByIdLinks
    "Mutation associated with this action"
    mutation: String
}

"Links attached to the createValidationRunById action on the Build type."
type BuildActionCreateValidationRunByIdLinks {
    "Creating a validation run for this build"
    form: UIActionLink
}

"Actions for a Build"
type BuildActions {
    "Creating a validation run for this build"
    createValidationRunById: BuildActionCreateValidationRunById
}

"Gathering information about the auto versioning around this build"
type BuildAutoVersioning {
    "AV source config"
    config: AutoVersioningSourceConfig!
    "Last eligible build for this AV config"
    lastEligibleBuild: Build
    "Last auto versioning entry for this dependency."
    status: AutoVersioningAuditEntry
}

"Form to create a new build filter."
type BuildFilterForm {
    "Form for the filter."
    form: JSON @deprecated(reason: "Form is only used for the Ontrack legacy UI")
    "If the filter is predefined and cannot be configured."
    isPredefined: Boolean
    "FQCN for the build filter provider"
    type: String!
    "Display name for the filter"
    typeName: String!
}

"Shared build filter for a branch."
type BuildFilterResource {
    "Data for this filter"
    data: JSON
    "Filter error if any"
    error: String
    "Is this filter shared?"
    isShared: Boolean
    "Links"
    links: BuildFilterResourceLinks @deprecated(reason: "Use the `actions` field instead.")
    "Name for this filter"
    name: String!
    "FQCN of the build filter provider"
    type: String!
}

"BuildFilterResource links"
type BuildFilterResourceLinks {
    _delete: String
    _share: String
    _update: String
}

"Build filter validation result."
type BuildFilterValidation {
    "Validation message or null if valid."
    error: String
}

"Qualified link to a build"
type BuildLink {
    "Linked build"
    build: Build!
    "Nature/qualification of the link"
    qualifier: String!
}

type BuildLinkPaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [BuildLink!]!
}

"Build links"
type BuildLinks {
    _actions: String
    _buildLinksFrom: String
    _changeLog: String
    _changeLogPage: String
    _collectSonarQube: String
    _decorations: String
    _delete: String
    _events: String
    _extra: String
    _lastPromotionRuns: String
    _next: String
    _page: String
    _previous: String
    _promote: String
    _promotionRuns: String
    _properties: String
    _runInfo: String
    _self: String
    _signature: String
    _update: String
    _validate: String
    _validationRuns: String
    _validationStampRunViews: String
}

type BuildPaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [Build!]!
}

"Output type for the bulkUpdatePromotionLevelById mutation."
type BulkUpdatePromotionLevelByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the bulkUpdateValidationStampById mutation."
type BulkUpdateValidationStampByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Configuration as code information"
type CasC {
    "Renders the current settings as JSON"
    json: JSON
    "List of resources needed to define the configuration as code"
    locations: [String!]!
    "CasC schema as JSON"
    schema: JSON
    "Renders the current settings as YAML"
    yaml: String!
}

type ChangePasswordPayload implements PayloadInterface {
    "List of errors"
    errors: [PayloadUserError]
}

"Output type for the changeValidationRunStatusComment mutation."
type ChangeValidationRunStatusCommentPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Updated validation run"
    validationRun: ValidationRun
}

"Output type for the changeValidationRunStatus mutation."
type ChangeValidationRunStatusPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Updated validation run"
    validationRun: ValidationRun
}

"Reference to a chart that an entity exposes."
type ChartDefinition {
    "Additional fields that the chart type required"
    config: JSON!
    "Unique ID for this chart in the context of the entity exposing the charts"
    id: String!
    "Parameters that the client must pass to get the chart data"
    parameters: JSON!
    "Chart title"
    title: String!
    "Chart type, as supported by the client: `count`, `percentage`, `duration`, etc."
    type: String!
}

"Output type for the checkAutoVersioning mutation."
type CheckAutoVersioningPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Definition of an attribute for a configurable indicator"
type ConfigurableIndicatorAttribute {
    "Identifier for this attribute, used for storage"
    key: String!
    "Display name for this attribute"
    name: String!
    "True is the attribute is required"
    required: Boolean
    "Type of the value"
    type: ConfigurableIndicatorAttributeType!
}

"Value for a state"
type ConfigurableIndicatorAttributeValue {
    "Attribute definition"
    definition: ConfigurableIndicatorAttribute!
    "Attribute key"
    key: String!
    "Attribute value"
    value: String
}

"Stored state for a configurable indicator"
type ConfigurableIndicatorState {
    "Is this indicator enabled?"
    enabled: Boolean
    "Link to a description for this indicator"
    link: String
    "List of attribute values for this indicator"
    values: [ConfigurableIndicatorAttributeValue!]!
}

"Configurable indicator and its state"
type ConfigurableIndicatorTypeState {
    "List of attributes for this type"
    attributes: [ConfigurableIndicatorAttribute!]!
    "Associated category"
    category: IndicatorComputedCategory!
    "Indicator type ID"
    id: String
    "Links"
    links: ConfigurableIndicatorTypeStateLinks @deprecated(reason: "Use the `actions` field instead.")
    "Indicator type name"
    name: String
    "Saved stated for this configurable indicator"
    state: ConfigurableIndicatorState
}

"ConfigurableIndicatorTypeState links"
type ConfigurableIndicatorTypeStateLinks {
    _update: String
}

"Generic configuration"
type Configuration {
    "Specific data for the configuration (may include the name as well)"
    data: JSON
    "Addition data outside of the configuration itself"
    extra: JSON
    "Unique name for the configuration"
    name: String!
}

"Result of testing a configuration"
type ConnectionResult {
    "Result message"
    message: String!
    "Type of result"
    type: ConnectionResultType!
}

"Output type for the createBranchOrGet mutation."
type CreateBranchOrGetPayload implements Payload {
    "Created or existing branch"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the createBranch mutation."
type CreateBranchPayload implements Payload {
    "Created branch"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the createBuildOrGet mutation."
type CreateBuildOrGetPayload implements Payload {
    "Created or existing build"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the createBuild mutation."
type CreateBuildPayload implements Payload {
    "Created build"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the createBuiltInAccount mutation."
type CreateBuiltInAccountPayload implements Payload {
    "Created account"
    account: Account
    "List of errors"
    errors: [UserError]
}

"Output type for the createConfiguration mutation."
type CreateConfigurationPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the createEnvironment mutation."
type CreateEnvironmentPayload implements Payload {
    "Created environment"
    environment: Environment
    "List of errors"
    errors: [UserError]
}

"Output type for the createGitHubConfiguration mutation."
type CreateGitHubConfigurationPayload implements Payload {
    "Saved configuration"
    configuration: GitHubEngineConfiguration
    "List of errors"
    errors: [UserError]
}

"Output type for the createJenkinsConfiguration mutation."
type CreateJenkinsConfigurationPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the createProjectOrGet mutation."
type CreateProjectOrGetPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created or existing project"
    project: Project
}

"Output type for the createProject mutation."
type CreateProjectPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created project"
    project: Project
}

"Output type for the createPromotionLevelById mutation."
type CreatePromotionLevelByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created promotion level"
    promotionLevel: PromotionLevel
}

"Output type for the createPromotionRunById mutation."
type CreatePromotionRunByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created promotion run"
    promotionRun: PromotionRun
}

"Output type for the createPromotionRun mutation."
type CreatePromotionRunPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created promotion run"
    promotionRun: PromotionRun
}

"Output type for the createSlots mutation."
type CreateSlotsPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "List of the created slots"
    slots: SlotList
}

"Output type for the createValidationRunById mutation."
type CreateValidationRunByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created validation run"
    validationRun: ValidationRun
}

"Output type for the createValidationRun mutation."
type CreateValidationRunPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created validation run"
    validationRun: ValidationRun
}

"Output type for the createValidationStampById mutation."
type CreateValidationStampByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created validation stamp"
    validationStamp: ValidationStamp
}

"Output type for the createValidationStampFilter mutation."
type CreateValidationStampFilterPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation stamp filter having been created"
    validationStampFilter: ValidationStampFilter
}

"Output type for the createWebhook mutation."
type CreateWebhookPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Registered webhook"
    webhook: Webhook
}

type Dashboard {
    authorizations: DashboardAuthorizations!
    name: String!
    userScope: DashboardContextUserScope!
    uuid: String!
    widgets: [WidgetInstance!]!
}

type DashboardAuthorizations {
    delete: Boolean!
    edit: Boolean!
    share: Boolean!
}

type Decoration {
    "JSON representation of the decoration data"
    data: JSON
    "Decoration type"
    decorationType: String
    "Any error message associated with the decoration"
    error: String
    "Extension feature"
    feature: ExtensionFeatureDescription
}

"Output type for the deleteAutoVersioningConfig mutation."
type DeleteAutoVersioningConfigPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBranchGitConfigPropertyById mutation."
type DeleteBranchGitConfigPropertyByIdPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBranchGitConfigProperty mutation."
type DeleteBranchGitConfigPropertyPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBranchMessagePropertyById mutation."
type DeleteBranchMessagePropertyByIdPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBranchMessageProperty mutation."
type DeleteBranchMessagePropertyPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBranchMetaInfoPropertyById mutation."
type DeleteBranchMetaInfoPropertyByIdPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBranchMetaInfoProperty mutation."
type DeleteBranchMetaInfoPropertyPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBranchReleaseValidationPropertyById mutation."
type DeleteBranchReleaseValidationPropertyByIdPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBranchReleaseValidationProperty mutation."
type DeleteBranchReleaseValidationPropertyPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBuildFilter mutation."
type DeleteBuildFilterPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBuildGitCommitPropertyById mutation."
type DeleteBuildGitCommitPropertyByIdPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBuildGitCommitProperty mutation."
type DeleteBuildGitCommitPropertyPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBuildMessagePropertyById mutation."
type DeleteBuildMessagePropertyByIdPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBuildMessageProperty mutation."
type DeleteBuildMessagePropertyPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBuildMetaInfoPropertyById mutation."
type DeleteBuildMetaInfoPropertyByIdPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBuildMetaInfoProperty mutation."
type DeleteBuildMetaInfoPropertyPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBuildReleasePropertyById mutation."
type DeleteBuildReleasePropertyByIdPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteBuildReleaseProperty mutation."
type DeleteBuildReleasePropertyPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteConfiguration mutation."
type DeleteConfigurationPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteGenericProperty mutation."
type DeleteGenericPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteJenkinsConfiguration mutation."
type DeleteJenkinsConfigurationPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteNotificationRecords mutation."
type DeleteNotificationRecordsPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteProjectAutoPromotionLevelPropertyById mutation."
type DeleteProjectAutoPromotionLevelPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectAutoPromotionLevelProperty mutation."
type DeleteProjectAutoPromotionLevelPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectAutoValidationStampPropertyById mutation."
type DeleteProjectAutoValidationStampPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectAutoValidationStampProperty mutation."
type DeleteProjectAutoValidationStampPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectAutoVersioningProjectPropertyById mutation."
type DeleteProjectAutoVersioningProjectPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectAutoVersioningProjectProperty mutation."
type DeleteProjectAutoVersioningProjectPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectBitbucketCloudConfigurationPropertyById mutation."
type DeleteProjectBitbucketCloudConfigurationPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectBitbucketCloudConfigurationProperty mutation."
type DeleteProjectBitbucketCloudConfigurationPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectBitbucketConfigurationPropertyById mutation."
type DeleteProjectBitbucketConfigurationPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectBitbucketConfigurationProperty mutation."
type DeleteProjectBitbucketConfigurationPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectBuildLinkDisplayPropertyById mutation."
type DeleteProjectBuildLinkDisplayPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectBuildLinkDisplayProperty mutation."
type DeleteProjectBuildLinkDisplayPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectGitHubConfigurationPropertyById mutation."
type DeleteProjectGitHubConfigurationPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectGitHubConfigurationProperty mutation."
type DeleteProjectGitHubConfigurationPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectGitLabConfigurationPropertyById mutation."
type DeleteProjectGitLabConfigurationPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectGitLabConfigurationProperty mutation."
type DeleteProjectGitLabConfigurationPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectMessagePropertyById mutation."
type DeleteProjectMessagePropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectMessageProperty mutation."
type DeleteProjectMessagePropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectMetaInfoPropertyById mutation."
type DeleteProjectMetaInfoPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectMetaInfoProperty mutation."
type DeleteProjectMetaInfoPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProject mutation."
type DeleteProjectPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteProjectSonarQubePropertyById mutation."
type DeleteProjectSonarQubePropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectSonarQubeProperty mutation."
type DeleteProjectSonarQubePropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectStalePropertyById mutation."
type DeleteProjectStalePropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deleteProjectStaleProperty mutation."
type DeleteProjectStalePropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the deletePromotionLevelAutoPromotionPropertyById mutation."
type DeletePromotionLevelAutoPromotionPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion level updated"
    promotionLevel: PromotionLevel
}

"Output type for the deletePromotionLevelAutoPromotionProperty mutation."
type DeletePromotionLevelAutoPromotionPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion level updated"
    promotionLevel: PromotionLevel
}

"Output type for the deletePromotionLevelById mutation."
type DeletePromotionLevelByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the deletePromotionLevelMessagePropertyById mutation."
type DeletePromotionLevelMessagePropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion level updated"
    promotionLevel: PromotionLevel
}

"Output type for the deletePromotionLevelMessageProperty mutation."
type DeletePromotionLevelMessagePropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion level updated"
    promotionLevel: PromotionLevel
}

"Output type for the deletePromotionLevelMetaInfoPropertyById mutation."
type DeletePromotionLevelMetaInfoPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion level updated"
    promotionLevel: PromotionLevel
}

"Output type for the deletePromotionLevelMetaInfoProperty mutation."
type DeletePromotionLevelMetaInfoPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion level updated"
    promotionLevel: PromotionLevel
}

"Output type for the deletePromotionRunMessagePropertyById mutation."
type DeletePromotionRunMessagePropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion run updated"
    promotionRun: PromotionRun
}

"Output type for the deletePromotionRunMessageProperty mutation."
type DeletePromotionRunMessagePropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion run updated"
    promotionRun: PromotionRun
}

"Output type for the deletePromotionRunMetaInfoPropertyById mutation."
type DeletePromotionRunMetaInfoPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion run updated"
    promotionRun: PromotionRun
}

"Output type for the deletePromotionRunMetaInfoProperty mutation."
type DeletePromotionRunMetaInfoPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion run updated"
    promotionRun: PromotionRun
}

"Output type for the deletePromotionRun mutation."
type DeletePromotionRunPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteSubscription mutation."
type DeleteSubscriptionPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteValidationRunMessagePropertyById mutation."
type DeleteValidationRunMessagePropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation run updated"
    validationRun: ValidationRun
}

"Output type for the deleteValidationRunMessageProperty mutation."
type DeleteValidationRunMessagePropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation run updated"
    validationRun: ValidationRun
}

"Output type for the deleteValidationRunMetaInfoPropertyById mutation."
type DeleteValidationRunMetaInfoPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation run updated"
    validationRun: ValidationRun
}

"Output type for the deleteValidationRunMetaInfoProperty mutation."
type DeleteValidationRunMetaInfoPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation run updated"
    validationRun: ValidationRun
}

"Output type for the deleteValidationStampById mutation."
type DeleteValidationStampByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the deleteValidationStampMessagePropertyById mutation."
type DeleteValidationStampMessagePropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation stamp updated"
    validationStamp: ValidationStamp
}

"Output type for the deleteValidationStampMessageProperty mutation."
type DeleteValidationStampMessagePropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation stamp updated"
    validationStamp: ValidationStamp
}

"Output type for the deleteValidationStampMetaInfoPropertyById mutation."
type DeleteValidationStampMetaInfoPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation stamp updated"
    validationStamp: ValidationStamp
}

"Output type for the deleteValidationStampMetaInfoProperty mutation."
type DeleteValidationStampMetaInfoPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation stamp updated"
    validationStamp: ValidationStamp
}

"Output type for the deleteWebhook mutation."
type DeleteWebhookPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

type DeletionPayload implements PayloadInterface {
    "List of errors"
    errors: [PayloadUserError]
}

"Result for the check of the admission for a pipeline"
type DeployableCheck {
    "reason field"
    reason: String
    "status field"
    status: Boolean
}

"Output type for the disableAccount mutation."
type DisableAccountPayload implements Payload {
    "Updated account"
    account: Account
    "List of errors"
    errors: [UserError]
}

"Output type for the disableBranch mutation."
type DisableBranchPayload implements Payload {
    "Updated branch"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the disableProject mutation."
type DisableProjectPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Updated project"
    project: Project
}

"Output type for the disableSubscription mutation."
type DisableSubscriptionPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Saved subscription"
    subscription: EventSubscriptionPayload
}

"Output type for the enableAccount mutation."
type EnableAccountPayload implements Payload {
    "Updated account"
    account: Account
    "List of errors"
    errors: [UserError]
}

"Output type for the enableBranch mutation."
type EnableBranchPayload implements Payload {
    "Updated branch"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the enableProject mutation."
type EnableProjectPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Updated project"
    project: Project
}

"Output type for the enableSubscription mutation."
type EnableSubscriptionPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Saved subscription"
    subscription: EventSubscriptionPayload
}

"Representation of the entity counts"
type EntityCounts {
    "Number of projects"
    projects: Int!
}

"Extra information component about an entity"
type EntityInformation {
    "Associated data"
    data: JSON
    "Display name for this information"
    title: String!
    "Type of information"
    type: String!
}

"Description of an environment"
type Environment {
    "description field"
    description: String
    "id field"
    id: String!
    "name field"
    name: String!
    "order field"
    order: Int
    "List of slots for this environment"
    slots: [Slot!]!
    "tags field"
    tags: [String!]!
}

"EventSubscriptionPayload"
type EventSubscriptionPayload {
    "Channel to send this event to"
    channel: String!
    "Channel configuration"
    channelConfig: JSON!
    "Textual description of the channel configuration"
    channelConfigText: String!
    "Optional template to use for the message"
    contentTemplate: String
    "If this subscription is disabled"
    disabled: Boolean
    "List of events types to subscribe to"
    events: [String!]!
    "Name of the subscription"
    id: String @deprecated(reason: "Will be removed in V5. Use `name` instead.")
    "Optional space-separated list of tokens to look for in the events"
    keywords: String
    "Unique name for this subscription"
    name: String!
}

type EventSubscriptionPayloadPaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [EventSubscriptionPayload!]!
    "Can the user create subscriptions in the current context"
    writeSubscriptionGranted: Boolean!
}

"EventType"
type EventType {
    "description field"
    description: String!
    "id field"
    id: String!
}

"Definition of an export format for the issues."
type ExportFormat {
    "ID of the format"
    id: String!
    "Display name of the format"
    name: String!
    "MIME type of the format"
    type: String!
}

type ExtensionFeatureDescription {
    "Feature description"
    description: String
    "Feature ID"
    id: String
    "Feature name"
    name: String
    "Feature version"
    version: String
}

"Output type for the favouriteBranch mutation."
type FavouriteBranchPayload implements Payload {
    "Updated branch"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the favouriteProject mutation."
type FavouriteProjectPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Updated project"
    project: Project
}

"Output type for the finishSlotPipelineDeployment mutation."
type FinishSlotPipelineDeploymentPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Status of the deployment"
    finishStatus: SlotPipelineDeploymentFinishStatus
}

"Output type for the generateToken mutation."
type GenerateTokenPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Generated token"
    token: Token
}

type GitChangeLog {
    "From build"
    buildFrom: Build!
    "To build"
    buildTo: Build!
    "List of commits in the change log"
    commits: [GitUICommit!]!
    "List of commits as a plot"
    commitsPlot: JSON
    "Gets the change of some dependency"
    depChangeLog(
        "Name of the project to follow"
        project: String!
    ): GitChangeLog
    "Link to a diff between the two builds"
    diffLink: String
    "Export of the change log according to some specifications"
    export(
        "Export specifications"
        request: IssueChangeLogExportRequest
    ): String
    "List of files changes"
    files: GitChangeLogFiles!
    "Checking if a change log can have issues"
    hasIssues: Boolean!
    "List of issues in the change log"
    issues: GitChangeLogIssues
    "All dependency changes"
    linkChanges: [LinkChange!]!
    "Project linked to the change log"
    project: Project!
    "If an error has occured during the synchronization"
    syncError: Boolean
    "UUID of the change log."
    uuid: String!
}

"Change on one file"
type GitChangeLogFile {
    "changeType field"
    changeType: SCMChangeLogFileChangeType!
    "newPath field"
    newPath: String!
    "oldPath field"
    oldPath: String!
    "Old path if set, new path otherwiser"
    path: String!
    "url field"
    url: String!
}

"List of files changes"
type GitChangeLogFiles {
    "List of individual file changes"
    list: [GitChangeLogFile!]!
}

"Description for an issue"
type GitChangeLogIssue {
    "Issue representation with minimal fields"
    issue: Issue!
    "Issue representation as JSON"
    issueObject: JSON
}

"List of issues associated with their issue service representation"
type GitChangeLogIssues {
    "Configuration of the issue service associated with this list of issues"
    issueServiceConfiguration: IssueServiceConfigurationRepresentation
    "List of issues"
    list: [GitChangeLogIssue!]!
}

"GitCommit"
type GitCommit {
    "author field"
    author: GitPerson!
    "commitTime field"
    commitTime: LocalDateTime!
    "committer field"
    committer: GitPerson!
    "fullMessage field"
    fullMessage: String!
    "id field"
    id: String!
    "shortId field"
    shortId: String!
    "shortMessage field"
    shortMessage: String!
}

"GitHub App token information"
type GitHubAppToken {
    "Date of creation"
    createdAt: LocalDateTime
    "Is the token valid?"
    valid: Boolean
    "Date of validity"
    validUntil: LocalDateTime
}

"CheckAutoVersioningOutput"
type GitHubCCheckAutoVersioningOutput {
    "UUID of the payload being processed in the background"
    uuid: String!
}

"Output type for the gitHubCheckAutoVersioningByBuildLabel mutation."
type GitHubCheckAutoVersioningByBuildLabelPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Payload being processed in the background"
    payload: GitHubCCheckAutoVersioningOutput
}

"Output type for the gitHubCheckAutoVersioningByBuildName mutation."
type GitHubCheckAutoVersioningByBuildNamePayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Payload being processed in the background"
    payload: GitHubCCheckAutoVersioningOutput
}

"Output type for the gitHubCheckAutoVersioningByRunId mutation."
type GitHubCheckAutoVersioningByRunIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Payload being processed in the background"
    payload: GitHubCCheckAutoVersioningOutput
}

"Configuration to connect to GitHub"
type GitHubEngineConfiguration {
    "ID of the GitHub App used for authentication"
    appId: String
    "Name of the account where the GitHub App is installed."
    appInstallationAccountName: String
    "GitHub App token information"
    appToken: GitHubAppToken
    "Authentication type"
    authenticationType: String
    "Links"
    links: GitHubEngineConfigurationLinks @deprecated(reason: "Use the `actions` field instead.")
    "Name of the configuration"
    name: String
    "Rate limits for this configuration"
    rateLimits: GitHubRateLimit
    "URL to GitHub"
    url: String!
    "User used to connect to GitHub. Can be used with a password or an OAuth2 token. Not needed if using only the OAUth2 token or a GitHub App."
    user: String
}

"GitHubEngineConfiguration links"
type GitHubEngineConfigurationLinks {
    _delete: String
    _self: String
    _update: String
}

"Output type for the gitHubIngestionBuildLinksByBuildLabel mutation."
type GitHubIngestionBuildLinksByBuildLabelPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Payload being processed in the background"
    payload: GitHubIngestionBuildLinksOutput
}

"Output type for the gitHubIngestionBuildLinksByBuildName mutation."
type GitHubIngestionBuildLinksByBuildNamePayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Payload being processed in the background"
    payload: GitHubIngestionBuildLinksOutput
}

"Output type for the gitHubIngestionBuildLinksByRunId mutation."
type GitHubIngestionBuildLinksByRunIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Payload being processed in the background"
    payload: GitHubIngestionBuildLinksOutput
}

"GitHubIngestionBuildLinksOutput"
type GitHubIngestionBuildLinksOutput {
    "UUID of the payload being processed in the background"
    uuid: String!
}

"IngestionConfig"
type GitHubIngestionConfig {
    "Configuration for the ingestion of the jobs"
    jobs: IngestionConfigJobs!
    "Setup of Ontrack resources"
    setup: IngestionConfigSetup!
    "Configuration for the ingestion of the steps"
    steps: IngestionConfigSteps!
    "Configuration for the tag ingestion"
    tagging: IngestionTaggingConfig!
    "Version of the configuration"
    version: String!
    "Defines the way a computed name must be normalized before it can be used as a validation stamp name."
    vsNameNormalization: IngestionConfigVSNameNormalization!
    "Configuration for the ingestion of the workflows"
    workflows: IngestionConfigWorkflows!
}

"Filter rule"
type GitHubIngestionFilterConfig {
    "Regular expression to exclude the items (empty = no exclusion)"
    excludes: String!
    "Regular expression to include the items"
    includes: String!
}

"Payload received by the GitHub Ingestion Hook"
type GitHubIngestionHookPayload {
    "Timestamp for the end of the processing"
    completion: LocalDateTime
    "Mapped to the `X-GitHub-Delivery` header"
    gitHubDelivery: String!
    "Mapped to the `X-GitHub-Event` header"
    gitHubEvent: String!
    "Mapped to the `X-GitHub-Hook-ID` header"
    gitHubHookID: Int
    "Mapped to the `X-GitHub-Hook-Installation-Target-ID` header"
    gitHubHookInstallationTargetID: Int
    "Mapped to the `X-GitHub-Hook-Installation-Target-Type` header"
    gitHubHookInstallationTargetType: String!
    "Status message (exception stack trace in case of error)"
    message: String
    "Outcome of the processing"
    outcome: IngestionEventProcessingResult
    "Details about the outcome of the processing"
    outcomeDetails: String
    "JSON payload, raw from GitHub"
    payload: JSON!
    "Queue information"
    queue: String
    "Repository this payload refers to"
    repository: GitHubRepository
    "Routing information"
    routing: String
    "Source/name of the payload/event"
    source: String
    "Timestamp for the start of the processing"
    started: LocalDateTime
    "Status of the processing"
    status: IngestionHookPayloadStatus!
    "Timestamp of reception for this payload"
    timestamp: LocalDateTime
    "Unique ID for this payload"
    uuid: String
}

type GitHubIngestionHookPayloadPaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [GitHubIngestionHookPayload!]!
}

"Output type for the gitHubIngestionValidateDataByBuildLabel mutation."
type GitHubIngestionValidateDataByBuildLabelPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Payload being processed in the background"
    payload: GitHubIngestionValidateDataOutput
}

"Output type for the gitHubIngestionValidateDataByBuildName mutation."
type GitHubIngestionValidateDataByBuildNamePayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Payload being processed in the background"
    payload: GitHubIngestionValidateDataOutput
}

"Output type for the gitHubIngestionValidateDataByRunId mutation."
type GitHubIngestionValidateDataByRunIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Payload being processed in the background"
    payload: GitHubIngestionValidateDataOutput
}

"GitHubIngestionValidateDataOutput"
type GitHubIngestionValidateDataOutput {
    "UUID of the payload being processed in the background"
    uuid: String!
}

"GitHub owner"
type GitHubOwner {
    "Login for the owner"
    login: String
}

"Rate limits"
type GitHubRateLimit {
    "Rate limit for core calls"
    core: RateLimit
    "Rate limit for GraphQL calls"
    graphql: RateLimit
}

"GitHub repository"
type GitHubRepository {
    "URL to the repository"
    htmlUrl: String
    "Name of the repository"
    name: String
    "Owner of the repository"
    owner: GitHubOwner!
}

"GitPerson"
type GitPerson {
    "email field"
    email: String!
    "name field"
    name: String!
}

"Git pull request associated to a branch"
type GitPullRequest {
    "PR id"
    id: Int
    "PR validity - does it exist?"
    isValid: Boolean
    "Display name for the PR"
    key: String!
    "Source branch"
    source: String!
    "Link to the Ontrack branch which is the source of this PR"
    sourceBranch: Branch
    "PR status"
    status: String!
    "Target branch"
    target: String!
    "Link to the Ontrack branch which is the target of this PR"
    targetBranch: Branch
    "PR title"
    title: String!
    "Link to the PR web page"
    url: String!
}

"GitUICommit"
type GitUICommit {
    "annotatedMessage field"
    annotatedMessage: String!
    "author field"
    author: String!
    "authorEmail field"
    authorEmail: String!
    "Build associated with this commit"
    build: Build
    "commit field"
    commit: GitCommit!
    "fullAnnotatedMessage field"
    fullAnnotatedMessage: String!
    "id field"
    id: String!
    "link field"
    link: String!
    "message field"
    message: String!
    "shortId field"
    shortId: String!
    "timestamp field"
    timestamp: LocalDateTime!
}

type GlobalRole {
    "List of accounts having this role"
    accounts: [Account!]!
    "description field"
    description: String!
    "List of groups having this role"
    groups: [AccountGroup!]!
    "id field"
    id: String!
    "name field"
    name: String!
}

"Home page settings"
type HomePageSettingsType {
    "Maximum of branches to display per favorite project"
    maxBranches: Int!
    "Maximum of projects starting from which we need to switch to a search mode"
    maxProjects: Int!
}

"HookInfoLink"
type HookInfoLink {
    "JSON data as understood by the HookInfoLinkExtension"
    data: JSON!
    "ID of the ExtensionFeature which provides the information."
    feature: String!
    "ID of the HookInfoLinkExtension which provides the information."
    id: String!
}

"HookRecordFilterInfo"
type HookRecordFilterInfo {
    "List of endpoints"
    hooks: [String!]!
    "List of available hook messages states"
    states: [String!]!
}

"Recording for hook messages"
type HookRecording {
    "End time of the processing"
    endTime: LocalDateTime
    "Any exception associated with the processing"
    exception: String
    "Reference to the handler of this hook"
    hook: String!
    "Unique ID for the hook received message"
    id: String!
    "Any message associated with the processing"
    message: String
    "Body of the hook request"
    request: HookRequest!
    "Response returned by the hook"
    response: HookResponse
    "Start time of the processing"
    startTime: LocalDateTime!
    "Current state of the processing"
    state: HookRecordState!
}

type HookRecordingPaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [HookRecording!]!
}

"Request received by a hook"
type HookRequest {
    "Body of the request"
    body: String!
    "URL query parameters"
    parameters: [NameValue!]!
}

"Data returned by a hook."
type HookResponse {
    "Additional information (non structured, will typically be rendered as JSON)"
    info: JSON
    "Structured additional information"
    infoLink: HookInfoLink
    "Type of response"
    type: HookResponseType!
}

"Aggregator of indicator categories"
type IndicatorCategories {
    "List of indicator categories"
    categories(
        "ID of the indicator category"
        id: String
    ): [IndicatorCategory!]!
    "Links"
    links: IndicatorCategoriesLinks @deprecated(reason: "Use the `actions` field instead.")
}

"IndicatorCategories links"
type IndicatorCategoriesLinks {
    _create: String
}

"Indicator category"
type IndicatorCategory {
    "Indicator category deprecation reason if any"
    deprecated: String
    "Indicator category ID"
    id: String
    "Links"
    links: IndicatorCategoryLinks @deprecated(reason: "Use the `actions` field instead.")
    "Indicator category name"
    name: String
    "Reporting the indicators for the types in this category"
    report(
        "Reports only projects where the indicator is filled in"
        filledOnly: Boolean,
        "Reports on the projects matching this label"
        label: String,
        "Reports on the projects belonging to this portfolio"
        portfolio: String,
        "Reports on the project matching this ID"
        projectId: Int,
        "Reports on the project matching this name"
        projectName: String
    ): IndicatorCategoryReport!
    "Source for this category"
    source: IndicatorSource
    "List of indicator types belonging to this category."
    types: [ProjectIndicatorType!]!
}

"IndicatorCategory links"
type IndicatorCategoryLinks {
    _delete: String
    _update: String
}

"Report of indicators for a category"
type IndicatorCategoryReport {
    "Report of indicators per project"
    projectReport(
        "Rate must be worse or equal."
        rate: String
    ): [IndicatorCategoryReportProject!]!
    "Report of indicators per type"
    typeReport: [IndicatorCategoryReportType!]!
}

"Report of indicators for one project"
type IndicatorCategoryReportProject {
    "Indicators for one projects and types in this category"
    indicators: [ProjectIndicator!]!
    "Associated project"
    project: Project
}

"Report of indicators for one type"
type IndicatorCategoryReportType {
    "Indicators for one projects and types in this category"
    projectIndicators: [IndicatorCategoryReportTypeEntry!]!
    "Associated type"
    type: ProjectIndicatorType
}

"Indicator for one project and one type"
type IndicatorCategoryReportTypeEntry {
    "Indicator for one project and one type"
    indicator: ProjectIndicator!
    "Associated project"
    project: Project
}

"Association of a category and statistics over several items"
type IndicatorCategoryStats {
    "Associated indicator category"
    category: IndicatorCategory
    "previousStats field"
    previousStats: IndicatorPreviousStats
    "Statistics"
    stats: IndicatorStats
}

"Computed indicator category"
type IndicatorComputedCategory {
    "Indicator category ID"
    id: String
    "Indicator category name"
    name: String
}

"Grouping indicators for a group of projects identified by labels."
type IndicatorPortfolio {
    "Indicator categories being shown for this portfolio"
    categories: [IndicatorCategory!]!
    "Stats per category"
    categoryStats(
        "Number of seconds (> 0) to get indicator trends from."
        duration: Int
    ): [IndicatorCategoryStats!]! @deprecated(reason: "Use viewStats with viewId = null. This field will be removed in V5.")
    "Global indicator stats"
    globalStats(
        "Number of seconds (> 0) to get indicator trends from."
        duration: Int
    ): [IndicatorCategoryStats!]! @deprecated(reason: "Use indicator views. This field will be removed in V5.")
    "ID of the portfolio"
    id: String
    "Label for this portfolio"
    label: Label
    "Links"
    links: IndicatorPortfolioLinks @deprecated(reason: "Use the `actions` field instead.")
    "Name of the portfolio"
    name: String
    "List of projects associated with this portfolio"
    projects: [Project!]!
    "Indicators stats for a given view for this portfolio"
    viewStats(
        "Number of seconds (> 0) to get indicator trends from."
        duration: Int,
        "ID of the indicator view, set to null to use the portfolio default configuration"
        id: String
    ): [IndicatorCategoryStats!]
}

"IndicatorPortfolio links"
type IndicatorPortfolioLinks {
    _delete: String
    _update: String
}

"List of portfolios"
type IndicatorPortfolioOfPortfolios {
    "Global indicator categories"
    categories: [IndicatorCategory!]! @deprecated(reason: "Use indicator views")
    "Links"
    links: IndicatorPortfolioOfPortfoliosLinks @deprecated(reason: "Use the `actions` field instead.")
    "List of portfolios"
    portfolios: [IndicatorPortfolio!]!
}

"IndicatorPortfolioOfPortfolios links"
type IndicatorPortfolioOfPortfoliosLinks {
    _create: String
    _globalIndicators: String
}

"Indicator stats from the past"
type IndicatorPreviousStats {
    "avgTrend field"
    avgTrend: String
    "Time (in seconds) since the indicator values were computed or entered."
    durationSeconds: Int
    "maxTrend field"
    maxTrend: String
    "minTrend field"
    minTrend: String
    "stats field"
    stats: IndicatorStats!
}

"Indicator source"
type IndicatorSource {
    "Indicator source name"
    name: String!
    "Indicator source provider"
    provider: IndicatorSourceProviderDescription
}

"Indicator source provider description"
type IndicatorSourceProviderDescription {
    "Indicator source provider ID"
    id: String
    "Indicator source provider name"
    name: String
}

"Aggregation of ratings over several items."
type IndicatorStats {
    "Average value (undefined if no stat available)"
    avg: Int
    "Rating for the min value"
    avgRating: String
    "Number of items having an actual usable value for stat computation"
    count: Int
    "Maximal value (undefined if no stat available)"
    max: Int
    "Number of items having the maximum value"
    maxCount: Int
    "Rating for the min value"
    maxRating: String
    "Minimal value (undefined if no stat available)"
    min: Int
    "Number of items having the minimum value"
    minCount: Int
    "Rating for the min value"
    minRating: String
    "Total number of items used for this stat"
    total: Int
}

"Association of a type and statistics over several items"
type IndicatorTypeStats {
    "Statistics"
    stats: IndicatorStats
    "Associated indicator type"
    type: ProjectIndicatorType
}

"Aggregator of indicator types"
type IndicatorTypes {
    "Links"
    links: IndicatorTypesLinks @deprecated(reason: "Use the `actions` field instead.")
    "List of indicator types"
    types(
        "ID of the indicator category"
        category: String,
        "ID of the indicator type"
        id: String
    ): [ProjectIndicatorType!]!
}

"IndicatorTypes links"
type IndicatorTypesLinks {
    _create: String
}

"Indicator value type"
type IndicatorValueType {
    "Extension feature"
    feature: ExtensionFeatureDescription
    "FQCN of the value type"
    id: String
    "Display name of the value type"
    name: String!
}

"List of categories to display for a portfolio or a list of portfolios."
type IndicatorView {
    "Selected categories for this view"
    categories: [IndicatorCategory!]!
    "Unique ID for this view"
    id: String!
    "Links"
    links: IndicatorViewLinks @deprecated(reason: "Use the `actions` field instead.")
    "Name of the view"
    name: String!
    "List of indicator stats per project for all categories in this view"
    reports(
        "Number of seconds (> 0) to get indicator trends from."
        duration: Int,
        "Reports only projects where the indicator is filled in"
        filledOnly: Boolean,
        "Reports on the projects matching this label"
        label: String,
        "Reports on the projects belonging to this portfolio"
        portfolio: String,
        "Reports on the project matching this ID"
        projectId: Int,
        "Reports on the project matching this name"
        projectName: String,
        "Rate must be worse or equal."
        rate: String
    ): [IndicatorViewProjectReport!]!
}

"IndicatorView links"
type IndicatorViewLinks {
    _delete: String
    _update: String
}

"List of indicator views and management links."
type IndicatorViewList {
    "Links"
    links: IndicatorViewListLinks @deprecated(reason: "Use the `actions` field instead.")
    "List of indicator views"
    views(
        "ID of the view to put in the list"
        id: String,
        "Name of the view to put in the list"
        name: String
    ): [IndicatorView!]!
}

"IndicatorViewList links"
type IndicatorViewListLinks {
    _create: String
}

"View report line for a project"
type IndicatorViewProjectReport {
    "Associated project"
    project: Project!
    "List of stats per category in the view"
    viewStats: [IndicatorCategoryStats!]!
}

"Management of indicators"
type IndicatorsManagement {
    "Management of the indicators categories"
    categories: Boolean
    "Management of the configurable indicators"
    configuration: Boolean
    "Access to the indicator portfolios"
    portfolios: Boolean
    "Management of the indicators types"
    types: Boolean
    "Management of the indicators views"
    views: Boolean
}

"Application information"
type Info {
    "Version information"
    version: VersionInfo
}

"Build identification strategy"
type IngestionConfigBuildIdStategy {
    "Configuration of the build identification strategy"
    config: JSON!
    "ID of the build identification strategy (null to use the default commit-based strategy)"
    id: String
}

"IngestionConfigCascPromotion"
type IngestionConfigCascPromotion {
    "Optional description"
    description: String
    "Regular expression to exclude validation stamps by name"
    exclude: String
    "Reference to the image to set"
    image: String
    "Regular expression to include validation stamps by name"
    include: String
    "Unique name for the promotion in the branch"
    name: String!
    "List of promotions triggering this promotion"
    promotions: [String!]!
    "List of validations triggering this promotion. Important: these names are the names of the validations after step name resolution."
    validations: [String!]!
}

"IngestionConfigCascSetup"
type IngestionConfigCascSetup {
    "Casc configuration for the entity"
    casc: JSON!
    "Regular expression to exclude branches"
    excludes: String!
    "Regular expression for the branches which can setup the entity"
    includes: String!
}

"IngestionConfigCascValidation"
type IngestionConfigCascValidation {
    "Data type"
    dataType: IngestionConfigCascValidationType
    "Optional description"
    description: String
    "Reference to the image to set"
    image: String
    "Unique name for the validation stamp in the branch"
    name: String!
}

"IngestionConfigCascValidationType"
type IngestionConfigCascValidationType {
    "Data type configuration"
    config: JSON
    "FQCN or shortcut for the data type"
    type: String!
}

"Configuration for the ingestion of the jobs"
type IngestionConfigJobs {
    "Filter on the jobs names"
    filter: GitHubIngestionFilterConfig!
    "Mapping between job names and validation stamps"
    mappings: [JobIngestionConfigValidation!]!
    "Using the job name as a prefix for the validation stamps"
    validationPrefix: Boolean!
}

"Setup of Ontrack resources"
type IngestionConfigSetup {
    "Casc for the branch"
    branch: IngestionConfigCascSetup!
    "Casc for the project"
    project: IngestionConfigCascSetup!
    "Configuration of the promotion levels"
    promotions: [IngestionConfigCascPromotion!]!
    "Configuration of the validation stamps"
    validations: [IngestionConfigCascValidation!]!
}

"Configuration for the ingestion of the steps"
type IngestionConfigSteps {
    "Filter on the steps names"
    filter: GitHubIngestionFilterConfig!
    "Mapping between step names and validation stamps"
    mappings: [StepIngestionConfigValidation!]!
}

"Creation of validation runs at the workflow level"
type IngestionConfigWorkflowValidations {
    "Is the creation of validation runs for workflows enabled?"
    enabled: Boolean!
    "Filter on workflows to select the ones for which a validation must be created"
    filter: GitHubIngestionFilterConfig!
    "Prefix to use for the validation stamp"
    prefix: String!
    "Suffix to use for the validation stamp"
    suffix: String!
}

"Configuration for the ingestion of the workflows"
type IngestionConfigWorkflows {
    "Filter on the Git branch names"
    branchFilter: GitHubIngestionFilterConfig!
    "Build identification strategy"
    buildIdStrategy: IngestionConfigBuildIdStategy!
    "List of events to accept for the processing of a workflow"
    events: [String!]!
    "Filter on the workflow names"
    filter: GitHubIngestionFilterConfig!
    "Filtering the pull requests"
    includePRs: Boolean!
    "Creation of validation runs at the workflow level"
    validations: IngestionConfigWorkflowValidations!
}

"Configuration for the tagging processing."
type IngestionTaggingConfig {
    "If the commit property strategy must be applied. True by default."
    commitProperty: Boolean!
    "List of tagging strategies to apply"
    strategies: [IngestionTaggingStrategyConfig!]!
}

"Configuration for a tagging strategy"
type IngestionTaggingStrategyConfig {
    "JSON configuration"
    config: JSON
    "ID of the tagging strategy"
    type: String!
}

"Representation of an Issue."
type Issue {
    "Display name for the issue"
    displayKey: String
    "Key of the issue"
    key: String
    "JSON representation of the issue containing custom fields"
    rawIssue: JSON!
    "Status of the issue"
    status: IssueStatus
    "Title / summary for the issue"
    summary: String
    "Last update time"
    updateTime: String
    "URL to the issue"
    url: String
}

"Format for exporting a list of issues"
type IssueExportFormat {
    "Unique ID for this format"
    id: String!
    "Display name for this format"
    name: String!
}

"Technical representation of an issue service and its configuration"
type IssueServiceConfigurationRepresentation {
    "ID of the issue service"
    id: String
    "Name of the issue service"
    name: String
    "Link to the issue service configuration"
    serviceId: String
}

"Abstraction for the status of an issue"
type IssueStatus {
    "Name of the status"
    name: String
}

"Jenkins configuration"
type JenkinsConfiguration {
    "Name of the configuration"
    name: String!
    "URL of Jenkins"
    url: String!
    "Username used to connect"
    user: String
}

"Jira configuration"
type JiraConfiguration {
    "List of projects to exclude"
    exclude: [String!]!
    "List of projects to include"
    include: [String!]!
    "Name of the configuration"
    name: String!
    "URL of Jira"
    url: String!
    "Username used to connect"
    user: String
}

type JobActionResult {
    "Error message"
    error: String
    "Result"
    ok: Boolean!
}

"JobCategory"
type JobCategory {
    "key field"
    key: String!
    "name field"
    name: String!
    "All job types for this category"
    types: [JobType!]!
}

type JobExecutionStatus {
    "All jobs are paused"
    paused: Boolean!
}

"JobIngestionConfigValidation"
type JobIngestionConfigValidation {
    "Description for the validation stamp"
    description: String
    "Exact name of the job/step in the workflow"
    name: String!
    "Name of the validation stamp to use (instead of a generated one)"
    validation: String
}

"JobKey"
type JobKey {
    "id field"
    id: String!
    "type field"
    type: JobType!
}

"JobRunProgress"
type JobRunProgress {
    "message field"
    message: String!
    "percentage field"
    percentage: Int
    "text field"
    text: String!
}

"Job state information"
type JobStateInfo {
    "description field"
    description: String!
    "displayName field"
    displayName: String!
    "Name of the state"
    name: String!
}

"JobStatus"
type JobStatus {
    "actualSchedule field"
    actualSchedule: Schedule!
    "Checks if the job can be deleted"
    canBeDeleted: Boolean!
    "Checks if the job can be stopped"
    canBeStopped: Boolean!
    "Checks if the job can be paused"
    canPause: Boolean!
    "Checks if the job can be resumed"
    canResume: Boolean!
    "Checks if the job can be run"
    canRun: Boolean!
    "description field"
    description: String!
    "id field"
    id: Int
    "isDisabled field"
    isDisabled: Boolean
    "isError field"
    isError: Boolean
    "isPaused field"
    isPaused: Boolean
    "isRunning field"
    isRunning: Boolean
    "isTimeout field"
    isTimeout: Boolean
    "isValid field"
    isValid: Boolean
    "key field"
    key: JobKey!
    "lastError field"
    lastError: String
    "lastErrorCount field"
    lastErrorCount: Int
    "lastRunDate field"
    lastRunDate: LocalDateTime
    "lastRunDurationMs field"
    lastRunDurationMs: Int
    "lastTimeoutCount field"
    lastTimeoutCount: Int
    "nextRunDate field"
    nextRunDate: LocalDateTime
    "progress field"
    progress: JobRunProgress
    "progressText field"
    progressText: String!
    "runCount field"
    runCount: Int
    "schedule field"
    schedule: Schedule!
    "state field"
    state: JobState!
}

type JobStatusPaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [JobStatus!]!
}

"JobType"
type JobType {
    "category field"
    category: JobCategory!
    "key field"
    key: String!
    "name field"
    name: String!
}

"Label"
type Label {
    "category field"
    category: String
    "color field"
    color: String!
    "computedBy field"
    computedBy: LabelProviderDescription
    "description field"
    description: String
    "foregroundColor field"
    foregroundColor: String!
    "id field"
    id: Int!
    "Links"
    links: LabelLinks @deprecated(reason: "Use the `actions` field instead.")
    "name field"
    name: String!
    "List of associated projects"
    projects: [Project!]!
}

"Label links"
type LabelLinks {
    _delete: String
    _update: String
}

"LabelProviderDescription"
type LabelProviderDescription {
    "id field"
    id: String!
    "name field"
    name: String!
}

"Output type for the launchWorkflow mutation."
type LaunchWorkflowPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Workflow instance ID"
    workflowInstanceId: String
}

type License {
    "Is the license active?"
    active: Boolean!
    "Name of the assignee"
    assignee: String!
    "Licenses features IDs"
    features: [String!]!
    "Available features"
    licensedFeatures: [LicensedFeature!]!
    "Maximum number of projects which can be created (0 for unlimited)"
    maxProjects: Int!
    "Display name for the license"
    name: String!
    "Type of license"
    type: String!
    " End of validity for this license (null for unlimited)"
    validUntil: String
}

type LicenseControl {
    active: Boolean!
    expiration: LicenseExpiration!
    projectCountExceeded: Boolean!
}

type LicenseResponse {
    license: License
    licenseControl: LicenseControl!
}

type LicensedFeature {
    enabled: Boolean!
    id: String!
    name: String!
}

"Output type for the linkBuildById mutation."
type LinkBuildByIdPayload implements Payload {
    "Build linked from"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the linkBuild mutation."
type LinkBuildPayload implements Payload {
    "Build linked from"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Description of a change on a linked dependency."
type LinkChange {
    "from field"
    from: Build
    "project field"
    project: Project!
    "qualifier field"
    qualifier: String!
    "to field"
    to: Build
}

"Output type for the linksBuild mutation."
type LinksBuildPayload implements Payload {
    "Build linked from"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the lockAccount mutation."
type LockAccountPayload implements Payload {
    "Updated account"
    account: Account
    "List of errors"
    errors: [UserError]
}

"Message"
type Message {
    "content field"
    content: String!
    "type field"
    type: MessageType!
}

type Mutation {
    "Bulk update of a promotion level"
    bulkUpdatePromotionLevelById(
        "Input for the mutation"
        input: BulkUpdatePromotionLevelByIdInput
    ): BulkUpdatePromotionLevelByIdPayload
    "Bulk update of a validation stamp"
    bulkUpdateValidationStampById(
        "Input for the mutation"
        input: BulkUpdateValidationStampByIdInput
    ): BulkUpdateValidationStampByIdPayload
    "Changing the password of the current user"
    changePassword(input: ChangePasswordInput!): ChangePasswordPayload
    "Change the status of a validation run"
    changeValidationRunStatus(
        "Input for the mutation"
        input: ChangeValidationRunStatusInput
    ): ChangeValidationRunStatusPayload
    "Change the comment on a validation run status"
    changeValidationRunStatusComment(
        "Input for the mutation"
        input: ChangeValidationRunStatusCommentInput
    ): ChangeValidationRunStatusCommentPayload
    "Checks the status of the auto versioning compared to the latest versions and creates an appropriate validation"
    checkAutoVersioning(
        "Input for the mutation"
        input: CheckAutoVersioningInput
    ): CheckAutoVersioningPayload
    "Creates a new branch"
    createBranch(
        "Input for the mutation"
        input: CreateBranchInput
    ): CreateBranchPayload
    "Creates a new branch or gets it if it already exists"
    createBranchOrGet(
        "Input for the mutation"
        input: CreateBranchOrGetInput
    ): CreateBranchOrGetPayload
    "Creates a new build"
    createBuild(
        "Input for the mutation"
        input: CreateBuildInput
    ): CreateBuildPayload
    "Creates a new build or gets it if it already exists"
    createBuildOrGet(
        "Input for the mutation"
        input: CreateBuildOrGetInput
    ): CreateBuildOrGetPayload
    "Creates a built-in account"
    createBuiltInAccount(
        "Input for the mutation"
        input: CreateBuiltInAccountInput
    ): CreateBuiltInAccountPayload
    "Creates a configuration"
    createConfiguration(
        "Input for the mutation"
        input: CreateConfigurationInput
    ): CreateConfigurationPayload
    "Creates a new environment"
    createEnvironment(
        "Input for the mutation"
        input: CreateEnvironmentInput
    ): CreateEnvironmentPayload
    "Creates a new GitHub configuration."
    createGitHubConfiguration(
        "Input for the mutation"
        input: CreateGitHubConfigurationInput
    ): CreateGitHubConfigurationPayload
    "Creates a Jenkins configuration"
    createJenkinsConfiguration(
        "Input for the mutation"
        input: CreateJenkinsConfigurationInput
    ): CreateJenkinsConfigurationPayload
    "Creates a new project"
    createProject(
        "Input for the mutation"
        input: CreateProjectInput
    ): CreateProjectPayload
    "Creates a new project or gets it if it already exists"
    createProjectOrGet(
        "Input for the mutation"
        input: CreateProjectOrGetInput
    ): CreateProjectOrGetPayload
    "Creates a new promotion level from a branch ID"
    createPromotionLevelById(
        "Input for the mutation"
        input: CreatePromotionLevelByIdInput
    ): CreatePromotionLevelByIdPayload
    "Creating a promotion run for a build identified by its name"
    createPromotionRun(
        "Input for the mutation"
        input: CreatePromotionRunInput
    ): CreatePromotionRunPayload
    "Creating a promotion run for a build identified by its ID"
    createPromotionRunById(
        "Input for the mutation"
        input: CreatePromotionRunByIdInput
    ): CreatePromotionRunByIdPayload
    "Creates several slots, one per provided environment"
    createSlots(
        "Input for the mutation"
        input: CreateSlotsInput
    ): CreateSlotsPayload
    "Creating a validation run for a build identified by its name"
    createValidationRun(
        "Input for the mutation"
        input: CreateValidationRunInput
    ): CreateValidationRunPayload
    "Creating a validation run for a build identified by its ID"
    createValidationRunById(
        "Input for the mutation"
        input: CreateValidationRunByIdInput
    ): CreateValidationRunByIdPayload
    "Creates a new validation stamp from a branch ID"
    createValidationStampById(
        "Input for the mutation"
        input: CreateValidationStampByIdInput
    ): CreateValidationStampByIdPayload
    "Creates an empty validation stamp filter"
    createValidationStampFilter(
        "Input for the mutation"
        input: CreateValidationStampFilterInput
    ): CreateValidationStampFilterPayload
    "Registers a webhook"
    createWebhook(
        "Input for the mutation"
        input: CreateWebhookInput
    ): CreateWebhookPayload
    "Deletes the auto-versioning configuration from a branch"
    deleteAutoVersioningConfig(
        "Input for the mutation"
        input: DeleteAutoVersioningConfigInput
    ): DeleteAutoVersioningConfigPayload
    "Deletes the git branch property on a branch identified by name."
    deleteBranchGitConfigProperty(
        "Input for the mutation"
        input: DeleteBranchGitConfigPropertyInput
    ): DeleteBranchGitConfigPropertyPayload
    "Deletes the git branch property on a branch."
    deleteBranchGitConfigPropertyById(
        "Input for the mutation"
        input: DeleteBranchGitConfigPropertyByIdInput
    ): DeleteBranchGitConfigPropertyByIdPayload
    "Deletes the message property on a branch identified by name."
    deleteBranchMessageProperty(
        "Input for the mutation"
        input: DeleteBranchMessagePropertyInput
    ): DeleteBranchMessagePropertyPayload
    "Deletes the message property on a branch."
    deleteBranchMessagePropertyById(
        "Input for the mutation"
        input: DeleteBranchMessagePropertyByIdInput
    ): DeleteBranchMessagePropertyByIdPayload
    "Deletes the meta information property on a branch identified by name."
    deleteBranchMetaInfoProperty(
        "Input for the mutation"
        input: DeleteBranchMetaInfoPropertyInput
    ): DeleteBranchMetaInfoPropertyPayload
    "Deletes the meta information property on a branch."
    deleteBranchMetaInfoPropertyById(
        "Input for the mutation"
        input: DeleteBranchMetaInfoPropertyByIdInput
    ): DeleteBranchMetaInfoPropertyByIdPayload
    "Deletes the validation on release/label property on a branch identified by name."
    deleteBranchReleaseValidationProperty(
        "Input for the mutation"
        input: DeleteBranchReleaseValidationPropertyInput
    ): DeleteBranchReleaseValidationPropertyPayload
    "Deletes the validation on release/label property on a branch."
    deleteBranchReleaseValidationPropertyById(
        "Input for the mutation"
        input: DeleteBranchReleaseValidationPropertyByIdInput
    ): DeleteBranchReleaseValidationPropertyByIdPayload
    "Deletes a build filter for current user and for all users if shared"
    deleteBuildFilter(
        "Input for the mutation"
        input: DeleteBuildFilterInput
    ): DeleteBuildFilterPayload
    "Deletes the git commit property on a build identified by name."
    deleteBuildGitCommitProperty(
        "Input for the mutation"
        input: DeleteBuildGitCommitPropertyInput
    ): DeleteBuildGitCommitPropertyPayload
    "Deletes the git commit property on a build."
    deleteBuildGitCommitPropertyById(
        "Input for the mutation"
        input: DeleteBuildGitCommitPropertyByIdInput
    ): DeleteBuildGitCommitPropertyByIdPayload
    "Deletes the message property on a build identified by name."
    deleteBuildMessageProperty(
        "Input for the mutation"
        input: DeleteBuildMessagePropertyInput
    ): DeleteBuildMessagePropertyPayload
    "Deletes the message property on a build."
    deleteBuildMessagePropertyById(
        "Input for the mutation"
        input: DeleteBuildMessagePropertyByIdInput
    ): DeleteBuildMessagePropertyByIdPayload
    "Deletes the meta information property on a build identified by name."
    deleteBuildMetaInfoProperty(
        "Input for the mutation"
        input: DeleteBuildMetaInfoPropertyInput
    ): DeleteBuildMetaInfoPropertyPayload
    "Deletes the meta information property on a build."
    deleteBuildMetaInfoPropertyById(
        "Input for the mutation"
        input: DeleteBuildMetaInfoPropertyByIdInput
    ): DeleteBuildMetaInfoPropertyByIdPayload
    "Deletes the release property on a build identified by name."
    deleteBuildReleaseProperty(
        "Input for the mutation"
        input: DeleteBuildReleasePropertyInput
    ): DeleteBuildReleasePropertyPayload
    "Deletes the release property on a build."
    deleteBuildReleasePropertyById(
        "Input for the mutation"
        input: DeleteBuildReleasePropertyByIdInput
    ): DeleteBuildReleasePropertyByIdPayload
    "Deletes a configuration"
    deleteConfiguration(
        "Input for the mutation"
        input: DeleteConfigurationInput
    ): DeleteConfigurationPayload
    "Deletes a dashboard"
    deleteDashboard(input: DeleteDashboardInput!): DeletionPayload
    "Generic deletion for a property and an entity"
    deleteGenericProperty(
        "Input for the mutation"
        input: DeleteGenericPropertyInput
    ): DeleteGenericPropertyPayload
    "Deletes a Jenkins configuration"
    deleteJenkinsConfiguration(
        "Input for the mutation"
        input: DeleteJenkinsConfigurationInput
    ): DeleteJenkinsConfigurationPayload
    "Deletes a job"
    deleteJob(id: Int!): JobActionResult!
    "Deleting notification records"
    deleteNotificationRecords(
        "Input for the mutation"
        input: DeleteNotificationRecordsInput
    ): DeleteNotificationRecordsPayload
    "Deletes an existing project"
    deleteProject(
        "Input for the mutation"
        input: DeleteProjectInput
    ): DeleteProjectPayload
    "Deletes the auto promotion levels property on a project identified by name."
    deleteProjectAutoPromotionLevelProperty(
        "Input for the mutation"
        input: DeleteProjectAutoPromotionLevelPropertyInput
    ): DeleteProjectAutoPromotionLevelPropertyPayload
    "Deletes the auto promotion levels property on a project."
    deleteProjectAutoPromotionLevelPropertyById(
        "Input for the mutation"
        input: DeleteProjectAutoPromotionLevelPropertyByIdInput
    ): DeleteProjectAutoPromotionLevelPropertyByIdPayload
    "Deletes the auto validation stamps property on a project identified by name."
    deleteProjectAutoValidationStampProperty(
        "Input for the mutation"
        input: DeleteProjectAutoValidationStampPropertyInput
    ): DeleteProjectAutoValidationStampPropertyPayload
    "Deletes the auto validation stamps property on a project."
    deleteProjectAutoValidationStampPropertyById(
        "Input for the mutation"
        input: DeleteProjectAutoValidationStampPropertyByIdInput
    ): DeleteProjectAutoValidationStampPropertyByIdPayload
    "Deletes the auto-versioning property on a project identified by name."
    deleteProjectAutoVersioningProjectProperty(
        "Input for the mutation"
        input: DeleteProjectAutoVersioningProjectPropertyInput
    ): DeleteProjectAutoVersioningProjectPropertyPayload
    "Deletes the auto-versioning property on a project."
    deleteProjectAutoVersioningProjectPropertyById(
        "Input for the mutation"
        input: DeleteProjectAutoVersioningProjectPropertyByIdInput
    ): DeleteProjectAutoVersioningProjectPropertyByIdPayload
    "Deletes the bitbucket Cloud configuration property on a project identified by name."
    deleteProjectBitbucketCloudConfigurationProperty(
        "Input for the mutation"
        input: DeleteProjectBitbucketCloudConfigurationPropertyInput
    ): DeleteProjectBitbucketCloudConfigurationPropertyPayload
    "Deletes the bitbucket Cloud configuration property on a project."
    deleteProjectBitbucketCloudConfigurationPropertyById(
        "Input for the mutation"
        input: DeleteProjectBitbucketCloudConfigurationPropertyByIdInput
    ): DeleteProjectBitbucketCloudConfigurationPropertyByIdPayload
    "Deletes the bitbucket Server configuration property on a project identified by name."
    deleteProjectBitbucketConfigurationProperty(
        "Input for the mutation"
        input: DeleteProjectBitbucketConfigurationPropertyInput
    ): DeleteProjectBitbucketConfigurationPropertyPayload
    "Deletes the bitbucket Server configuration property on a project."
    deleteProjectBitbucketConfigurationPropertyById(
        "Input for the mutation"
        input: DeleteProjectBitbucketConfigurationPropertyByIdInput
    ): DeleteProjectBitbucketConfigurationPropertyByIdPayload
    "Deletes the build link display options property on a project identified by name."
    deleteProjectBuildLinkDisplayProperty(
        "Input for the mutation"
        input: DeleteProjectBuildLinkDisplayPropertyInput
    ): DeleteProjectBuildLinkDisplayPropertyPayload
    "Deletes the build link display options property on a project."
    deleteProjectBuildLinkDisplayPropertyById(
        "Input for the mutation"
        input: DeleteProjectBuildLinkDisplayPropertyByIdInput
    ): DeleteProjectBuildLinkDisplayPropertyByIdPayload
    "Deletes the gitHub configuration property on a project identified by name."
    deleteProjectGitHubConfigurationProperty(
        "Input for the mutation"
        input: DeleteProjectGitHubConfigurationPropertyInput
    ): DeleteProjectGitHubConfigurationPropertyPayload
    "Deletes the gitHub configuration property on a project."
    deleteProjectGitHubConfigurationPropertyById(
        "Input for the mutation"
        input: DeleteProjectGitHubConfigurationPropertyByIdInput
    ): DeleteProjectGitHubConfigurationPropertyByIdPayload
    "Deletes the gitLab configuration property on a project identified by name."
    deleteProjectGitLabConfigurationProperty(
        "Input for the mutation"
        input: DeleteProjectGitLabConfigurationPropertyInput
    ): DeleteProjectGitLabConfigurationPropertyPayload
    "Deletes the gitLab configuration property on a project."
    deleteProjectGitLabConfigurationPropertyById(
        "Input for the mutation"
        input: DeleteProjectGitLabConfigurationPropertyByIdInput
    ): DeleteProjectGitLabConfigurationPropertyByIdPayload
    "Deletes the message property on a project identified by name."
    deleteProjectMessageProperty(
        "Input for the mutation"
        input: DeleteProjectMessagePropertyInput
    ): DeleteProjectMessagePropertyPayload
    "Deletes the message property on a project."
    deleteProjectMessagePropertyById(
        "Input for the mutation"
        input: DeleteProjectMessagePropertyByIdInput
    ): DeleteProjectMessagePropertyByIdPayload
    "Deletes the meta information property on a project identified by name."
    deleteProjectMetaInfoProperty(
        "Input for the mutation"
        input: DeleteProjectMetaInfoPropertyInput
    ): DeleteProjectMetaInfoPropertyPayload
    "Deletes the meta information property on a project."
    deleteProjectMetaInfoPropertyById(
        "Input for the mutation"
        input: DeleteProjectMetaInfoPropertyByIdInput
    ): DeleteProjectMetaInfoPropertyByIdPayload
    "Deletes the sonarQube property on a project identified by name."
    deleteProjectSonarQubeProperty(
        "Input for the mutation"
        input: DeleteProjectSonarQubePropertyInput
    ): DeleteProjectSonarQubePropertyPayload
    "Deletes the sonarQube property on a project."
    deleteProjectSonarQubePropertyById(
        "Input for the mutation"
        input: DeleteProjectSonarQubePropertyByIdInput
    ): DeleteProjectSonarQubePropertyByIdPayload
    "Deletes the stale branches property on a project identified by name."
    deleteProjectStaleProperty(
        "Input for the mutation"
        input: DeleteProjectStalePropertyInput
    ): DeleteProjectStalePropertyPayload
    "Deletes the stale branches property on a project."
    deleteProjectStalePropertyById(
        "Input for the mutation"
        input: DeleteProjectStalePropertyByIdInput
    ): DeleteProjectStalePropertyByIdPayload
    "Deletes the auto promotion property on a promotion level identified by name."
    deletePromotionLevelAutoPromotionProperty(
        "Input for the mutation"
        input: DeletePromotionLevelAutoPromotionPropertyInput
    ): DeletePromotionLevelAutoPromotionPropertyPayload
    "Deletes the auto promotion property on a promotion level."
    deletePromotionLevelAutoPromotionPropertyById(
        "Input for the mutation"
        input: DeletePromotionLevelAutoPromotionPropertyByIdInput
    ): DeletePromotionLevelAutoPromotionPropertyByIdPayload
    "Deletes an existing promotion level"
    deletePromotionLevelById(
        "Input for the mutation"
        input: DeletePromotionLevelByIdInput
    ): DeletePromotionLevelByIdPayload
    "Deletes the message property on a promotion level identified by name."
    deletePromotionLevelMessageProperty(
        "Input for the mutation"
        input: DeletePromotionLevelMessagePropertyInput
    ): DeletePromotionLevelMessagePropertyPayload
    "Deletes the message property on a promotion level."
    deletePromotionLevelMessagePropertyById(
        "Input for the mutation"
        input: DeletePromotionLevelMessagePropertyByIdInput
    ): DeletePromotionLevelMessagePropertyByIdPayload
    "Deletes the meta information property on a promotion level identified by name."
    deletePromotionLevelMetaInfoProperty(
        "Input for the mutation"
        input: DeletePromotionLevelMetaInfoPropertyInput
    ): DeletePromotionLevelMetaInfoPropertyPayload
    "Deletes the meta information property on a promotion level."
    deletePromotionLevelMetaInfoPropertyById(
        "Input for the mutation"
        input: DeletePromotionLevelMetaInfoPropertyByIdInput
    ): DeletePromotionLevelMetaInfoPropertyByIdPayload
    "Deletes an existing promotion run"
    deletePromotionRun(
        "Input for the mutation"
        input: DeletePromotionRunInput
    ): DeletePromotionRunPayload
    "Deletes the message property on a promotion run identified by name."
    deletePromotionRunMessageProperty(
        "Input for the mutation"
        input: DeletePromotionRunMessagePropertyInput
    ): DeletePromotionRunMessagePropertyPayload
    "Deletes the message property on a promotion run."
    deletePromotionRunMessagePropertyById(
        "Input for the mutation"
        input: DeletePromotionRunMessagePropertyByIdInput
    ): DeletePromotionRunMessagePropertyByIdPayload
    "Deletes the meta information property on a promotion run identified by name."
    deletePromotionRunMetaInfoProperty(
        "Input for the mutation"
        input: DeletePromotionRunMetaInfoPropertyInput
    ): DeletePromotionRunMetaInfoPropertyPayload
    "Deletes the meta information property on a promotion run."
    deletePromotionRunMetaInfoPropertyById(
        "Input for the mutation"
        input: DeletePromotionRunMetaInfoPropertyByIdInput
    ): DeletePromotionRunMetaInfoPropertyByIdPayload
    "Deletes an existing subscription using its ID"
    deleteSubscription(
        "Input for the mutation"
        input: DeleteSubscriptionInput
    ): DeleteSubscriptionPayload
    "Deletes the message property on a validation run identified by name."
    deleteValidationRunMessageProperty(
        "Input for the mutation"
        input: DeleteValidationRunMessagePropertyInput
    ): DeleteValidationRunMessagePropertyPayload
    "Deletes the message property on a validation run."
    deleteValidationRunMessagePropertyById(
        "Input for the mutation"
        input: DeleteValidationRunMessagePropertyByIdInput
    ): DeleteValidationRunMessagePropertyByIdPayload
    "Deletes the meta information property on a validation run identified by name."
    deleteValidationRunMetaInfoProperty(
        "Input for the mutation"
        input: DeleteValidationRunMetaInfoPropertyInput
    ): DeleteValidationRunMetaInfoPropertyPayload
    "Deletes the meta information property on a validation run."
    deleteValidationRunMetaInfoPropertyById(
        "Input for the mutation"
        input: DeleteValidationRunMetaInfoPropertyByIdInput
    ): DeleteValidationRunMetaInfoPropertyByIdPayload
    "Deletes an existing validation stamp"
    deleteValidationStampById(
        "Input for the mutation"
        input: DeleteValidationStampByIdInput
    ): DeleteValidationStampByIdPayload
    "Deletes the message property on a validation stamp identified by name."
    deleteValidationStampMessageProperty(
        "Input for the mutation"
        input: DeleteValidationStampMessagePropertyInput
    ): DeleteValidationStampMessagePropertyPayload
    "Deletes the message property on a validation stamp."
    deleteValidationStampMessagePropertyById(
        "Input for the mutation"
        input: DeleteValidationStampMessagePropertyByIdInput
    ): DeleteValidationStampMessagePropertyByIdPayload
    "Deletes the meta information property on a validation stamp identified by name."
    deleteValidationStampMetaInfoProperty(
        "Input for the mutation"
        input: DeleteValidationStampMetaInfoPropertyInput
    ): DeleteValidationStampMetaInfoPropertyPayload
    "Deletes the meta information property on a validation stamp."
    deleteValidationStampMetaInfoPropertyById(
        "Input for the mutation"
        input: DeleteValidationStampMetaInfoPropertyByIdInput
    ): DeleteValidationStampMetaInfoPropertyByIdPayload
    "Deleting an existing webhook"
    deleteWebhook(
        "Input for the mutation"
        input: DeleteWebhookInput
    ): DeleteWebhookPayload
    "Disables an account"
    disableAccount(
        "Input for the mutation"
        input: DisableAccountInput
    ): DisableAccountPayload
    "Disables an existing branch"
    disableBranch(
        "Input for the mutation"
        input: DisableBranchInput
    ): DisableBranchPayload
    "Disables an existing project"
    disableProject(
        "Input for the mutation"
        input: DisableProjectInput
    ): DisableProjectPayload
    "Disables an existing subscription"
    disableSubscription(
        "Input for the mutation"
        input: DisableSubscriptionInput
    ): DisableSubscriptionPayload
    "Enables an account"
    enableAccount(
        "Input for the mutation"
        input: EnableAccountInput
    ): EnableAccountPayload
    "Enables an existing branch"
    enableBranch(
        "Input for the mutation"
        input: EnableBranchInput
    ): EnableBranchPayload
    "Enables an existing project"
    enableProject(
        "Input for the mutation"
        input: EnableProjectInput
    ): EnableProjectPayload
    "Enables an existing subscription"
    enableSubscription(
        "Input for the mutation"
        input: EnableSubscriptionInput
    ): EnableSubscriptionPayload
    "Marks a branch as favourite"
    favouriteBranch(
        "Input for the mutation"
        input: FavouriteBranchInput
    ): FavouriteBranchPayload
    "Marks a project as favourite"
    favouriteProject(
        "Input for the mutation"
        input: FavouriteProjectInput
    ): FavouriteProjectPayload
    "Finishes the deployment of a pipeline"
    finishSlotPipelineDeployment(
        "Input for the mutation"
        input: FinishSlotPipelineDeploymentInput
    ): FinishSlotPipelineDeploymentPayload
    "Generate a new token"
    generateToken(
        "Input for the mutation"
        input: GenerateTokenInput
    ): GenerateTokenPayload
    "Checks the dependencies based on the auto versioning information."
    gitHubCheckAutoVersioningByBuildLabel(
        "Input for the mutation"
        input: GitHubCheckAutoVersioningByBuildLabelInput
    ): GitHubCheckAutoVersioningByBuildLabelPayload
    "Checks the dependencies based on the auto versioning information."
    gitHubCheckAutoVersioningByBuildName(
        "Input for the mutation"
        input: GitHubCheckAutoVersioningByBuildNameInput
    ): GitHubCheckAutoVersioningByBuildNamePayload
    "Checks the dependencies based on the auto versioning information."
    gitHubCheckAutoVersioningByRunId(
        "Input for the mutation"
        input: GitHubCheckAutoVersioningByRunIdInput
    ): GitHubCheckAutoVersioningByRunIdPayload
    "Sets some links on a build identified using its release property (label)"
    gitHubIngestionBuildLinksByBuildLabel(
        "Input for the mutation"
        input: GitHubIngestionBuildLinksByBuildLabelInput
    ): GitHubIngestionBuildLinksByBuildLabelPayload
    "Sets some links on a build identified using its name"
    gitHubIngestionBuildLinksByBuildName(
        "Input for the mutation"
        input: GitHubIngestionBuildLinksByBuildNameInput
    ): GitHubIngestionBuildLinksByBuildNamePayload
    "Sets some links on a build identified using a GHA workflow run ID"
    gitHubIngestionBuildLinksByRunId(
        "Input for the mutation"
        input: GitHubIngestionBuildLinksByRunIdInput
    ): GitHubIngestionBuildLinksByRunIdPayload
    "Sets some validation data on a build identified using its release property (label)"
    gitHubIngestionValidateDataByBuildLabel(
        "Input for the mutation"
        input: GitHubIngestionValidateDataByBuildLabelInput
    ): GitHubIngestionValidateDataByBuildLabelPayload
    "Sets some validation data on a build identified using its name"
    gitHubIngestionValidateDataByBuildName(
        "Input for the mutation"
        input: GitHubIngestionValidateDataByBuildNameInput
    ): GitHubIngestionValidateDataByBuildNamePayload
    "Sets some validation data on a build identified using a GHA workflow run ID"
    gitHubIngestionValidateDataByRunId(
        "Input for the mutation"
        input: GitHubIngestionValidateDataByRunIdInput
    ): GitHubIngestionValidateDataByRunIdPayload
    "Launches a job"
    launchJob(id: Int!): JobActionResult!
    "Launches an existing workflow"
    launchWorkflow(
        "Input for the mutation"
        input: LaunchWorkflowInput
    ): LaunchWorkflowPayload
    "Link two builds using their names"
    linkBuild(
        "Input for the mutation"
        input: LinkBuildInput
    ): LinkBuildPayload
    "Link two builds using their IDs"
    linkBuildById(
        "Input for the mutation"
        input: LinkBuildByIdInput
    ): LinkBuildByIdPayload
    "Link build to other ones using their names"
    linksBuild(
        "Input for the mutation"
        input: LinksBuildInput
    ): LinksBuildPayload
    "Locks an account"
    lockAccount(
        "Input for the mutation"
        input: LockAccountInput
    ): LockAccountPayload
    "Pausing the execution of all jobs"
    pauseAllJobs: JobActionResult!
    "Pauses a job"
    pauseJob(id: Int!): JobActionResult!
    "Basic test service"
    ping: String
    "Post a message on a queue"
    postQueue(
        "Input for the mutation"
        input: PostQueueInput
    ): PostQueuePayload
    "Purging all records for Hook messages"
    purgeHookRecordings: PurgeHookRecordingsPayload
    "Purging all records for Queue messages"
    purgeQueueRecordings: PurgeQueueRecordingsPayload
    "Reload the configuration from the CasC files"
    reloadCasc: ReloadCascPayload
    "Renames an existing subscription"
    renameSubscription(
        "Input for the mutation"
        input: RenameSubscriptionInput
    ): RenameSubscriptionPayload
    "Reordering the promotion levels in a branch"
    reorderPromotionLevelById(
        "Input for the mutation"
        input: ReorderPromotionLevelByIdInput
    ): ReorderPromotionLevelByIdPayload
    "Resuming the execution of all jobs"
    resumeAllJobs: JobActionResult!
    "Resumes a job"
    resumeJob(id: Int!): JobActionResult!
    "Revoke all tokens of the given account"
    revokeAccountTokens(
        "Input for the mutation"
        input: RevokeAccountTokensInput
    ): RevokeAccountTokensPayload
    "Revokes all tokens"
    revokeAllTokens: RevokeAllTokensPayload
    "Revoke the given token"
    revokeToken(
        "Input for the mutation"
        input: RevokeTokenInput
    ): RevokeTokenPayload
    "Saves a build filter in the user preferences"
    saveBuildFilter(
        "Input for the mutation"
        input: SaveBuildFilterInput
    ): SaveBuildFilterPayload
    "Saves a dashboard"
    saveDashboard(input: SaveDashboardInput!): SaveDashboardPayload
    "Saving some generic settings"
    saveSettings(input: SaveSettingsInput!): SaveSettingsPayload
    "Saves a workflow which is defined as YAML"
    saveYamlWorkflow(
        "Input for the mutation"
        input: SaveYamlWorkflowInput
    ): SaveYamlWorkflowPayload
    "Selects a dashboard"
    selectDashboard(input: SelectDashboardInput!): SelectDashboardPayload
    "Sets the auto versioning configuration for a branch"
    setAutoVersioningConfig(
        "Input for the mutation"
        input: SetAutoVersioningConfigInput
    ): SetAutoVersioningConfigPayload
    "Sets the auto versioning configuration for a branch identified by name"
    setAutoVersioningConfigByName(
        "Input for the mutation"
        input: SetAutoVersioningConfigByNameInput
    ): SetAutoVersioningConfigByNamePayload
    "Set the git branch property on a branch identified by name."
    setBranchGitConfigProperty(
        "Input for the mutation"
        input: SetBranchGitConfigPropertyInput
    ): SetBranchGitConfigPropertyPayload
    "Set the git branch property on a branch."
    setBranchGitConfigPropertyById(
        "Input for the mutation"
        input: SetBranchGitConfigPropertyByIdInput
    ): SetBranchGitConfigPropertyByIdPayload
    "Sets the GitHub Ingestion configuration programmatically"
    setBranchGitHubIngestionConfig(
        "Input for the mutation"
        input: SetBranchGitHubIngestionConfigInput
    ): SetBranchGitHubIngestionConfigPayload
    "Set the message property on a branch identified by name."
    setBranchMessageProperty(
        "Input for the mutation"
        input: SetBranchMessagePropertyInput
    ): SetBranchMessagePropertyPayload
    "Set the message property on a branch."
    setBranchMessagePropertyById(
        "Input for the mutation"
        input: SetBranchMessagePropertyByIdInput
    ): SetBranchMessagePropertyByIdPayload
    "Set the meta information property on a branch identified by name."
    setBranchMetaInfoProperty(
        "Input for the mutation"
        input: SetBranchMetaInfoPropertyInput
    ): SetBranchMetaInfoPropertyPayload
    "Set the meta information property on a branch."
    setBranchMetaInfoPropertyById(
        "Input for the mutation"
        input: SetBranchMetaInfoPropertyByIdInput
    ): SetBranchMetaInfoPropertyByIdPayload
    "Sets a property on a branch identified by name"
    setBranchProperty(
        "Input for the mutation"
        input: SetBranchPropertyInput
    ): SetBranchPropertyPayload
    "Sets a property on a branch identified by ID"
    setBranchPropertyById(
        "Input for the mutation"
        input: SetBranchPropertyByIdInput
    ): SetBranchPropertyByIdPayload
    "Set the validation on release/label property on a branch identified by name."
    setBranchReleaseValidationProperty(
        "Input for the mutation"
        input: SetBranchReleaseValidationPropertyInput
    ): SetBranchReleaseValidationPropertyPayload
    "Set the validation on release/label property on a branch."
    setBranchReleaseValidationPropertyById(
        "Input for the mutation"
        input: SetBranchReleaseValidationPropertyByIdInput
    ): SetBranchReleaseValidationPropertyByIdPayload
    "Set the git commit property on a build identified by name."
    setBuildGitCommitProperty(
        "Input for the mutation"
        input: SetBuildGitCommitPropertyInput
    ): SetBuildGitCommitPropertyPayload
    "Set the git commit property on a build."
    setBuildGitCommitPropertyById(
        "Input for the mutation"
        input: SetBuildGitCommitPropertyByIdInput
    ): SetBuildGitCommitPropertyByIdPayload
    "Set the message property on a build identified by name."
    setBuildMessageProperty(
        "Input for the mutation"
        input: SetBuildMessagePropertyInput
    ): SetBuildMessagePropertyPayload
    "Set the message property on a build."
    setBuildMessagePropertyById(
        "Input for the mutation"
        input: SetBuildMessagePropertyByIdInput
    ): SetBuildMessagePropertyByIdPayload
    "Set the meta information property on a build identified by name."
    setBuildMetaInfoProperty(
        "Input for the mutation"
        input: SetBuildMetaInfoPropertyInput
    ): SetBuildMetaInfoPropertyPayload
    "Set the meta information property on a build."
    setBuildMetaInfoPropertyById(
        "Input for the mutation"
        input: SetBuildMetaInfoPropertyByIdInput
    ): SetBuildMetaInfoPropertyByIdPayload
    "Sets a property on a build identified by name"
    setBuildProperty(
        "Input for the mutation"
        input: SetBuildPropertyInput
    ): SetBuildPropertyPayload
    "Sets a property on a build identified by ID"
    setBuildPropertyById(
        "Input for the mutation"
        input: SetBuildPropertyByIdInput
    ): SetBuildPropertyByIdPayload
    "Set the release property on a build identified by name."
    setBuildReleaseProperty(
        "Input for the mutation"
        input: SetBuildReleasePropertyInput
    ): SetBuildReleasePropertyPayload
    "Set the release property on a build."
    setBuildReleasePropertyById(
        "Input for the mutation"
        input: SetBuildReleasePropertyByIdInput
    ): SetBuildReleasePropertyByIdPayload
    "Generic update for a property and an entity"
    setGenericProperty(
        "Input for the mutation"
        input: SetGenericPropertyInput
    ): SetGenericPropertyPayload
    "Setting the preferences of the current user"
    setPreferences(
        "Input for the mutation"
        input: SetPreferencesInput
    ): SetPreferencesPayload
    "Set the auto promotion levels property on a project identified by name."
    setProjectAutoPromotionLevelProperty(
        "Input for the mutation"
        input: SetProjectAutoPromotionLevelPropertyInput
    ): SetProjectAutoPromotionLevelPropertyPayload
    "Set the auto promotion levels property on a project."
    setProjectAutoPromotionLevelPropertyById(
        "Input for the mutation"
        input: SetProjectAutoPromotionLevelPropertyByIdInput
    ): SetProjectAutoPromotionLevelPropertyByIdPayload
    "Set the auto validation stamps property on a project identified by name."
    setProjectAutoValidationStampProperty(
        "Input for the mutation"
        input: SetProjectAutoValidationStampPropertyInput
    ): SetProjectAutoValidationStampPropertyPayload
    "Set the auto validation stamps property on a project."
    setProjectAutoValidationStampPropertyById(
        "Input for the mutation"
        input: SetProjectAutoValidationStampPropertyByIdInput
    ): SetProjectAutoValidationStampPropertyByIdPayload
    "Set the auto-versioning property on a project identified by name."
    setProjectAutoVersioningProjectProperty(
        "Input for the mutation"
        input: SetProjectAutoVersioningProjectPropertyInput
    ): SetProjectAutoVersioningProjectPropertyPayload
    "Set the auto-versioning property on a project."
    setProjectAutoVersioningProjectPropertyById(
        "Input for the mutation"
        input: SetProjectAutoVersioningProjectPropertyByIdInput
    ): SetProjectAutoVersioningProjectPropertyByIdPayload
    "Set the bitbucket Cloud configuration property on a project identified by name."
    setProjectBitbucketCloudConfigurationProperty(
        "Input for the mutation"
        input: SetProjectBitbucketCloudConfigurationPropertyInput
    ): SetProjectBitbucketCloudConfigurationPropertyPayload
    "Set the bitbucket Cloud configuration property on a project."
    setProjectBitbucketCloudConfigurationPropertyById(
        "Input for the mutation"
        input: SetProjectBitbucketCloudConfigurationPropertyByIdInput
    ): SetProjectBitbucketCloudConfigurationPropertyByIdPayload
    "Set the bitbucket Server configuration property on a project identified by name."
    setProjectBitbucketConfigurationProperty(
        "Input for the mutation"
        input: SetProjectBitbucketConfigurationPropertyInput
    ): SetProjectBitbucketConfigurationPropertyPayload
    "Set the bitbucket Server configuration property on a project."
    setProjectBitbucketConfigurationPropertyById(
        "Input for the mutation"
        input: SetProjectBitbucketConfigurationPropertyByIdInput
    ): SetProjectBitbucketConfigurationPropertyByIdPayload
    "Set the build link display options property on a project identified by name."
    setProjectBuildLinkDisplayProperty(
        "Input for the mutation"
        input: SetProjectBuildLinkDisplayPropertyInput
    ): SetProjectBuildLinkDisplayPropertyPayload
    "Set the build link display options property on a project."
    setProjectBuildLinkDisplayPropertyById(
        "Input for the mutation"
        input: SetProjectBuildLinkDisplayPropertyByIdInput
    ): SetProjectBuildLinkDisplayPropertyByIdPayload
    "Set the gitHub configuration property on a project identified by name."
    setProjectGitHubConfigurationProperty(
        "Input for the mutation"
        input: SetProjectGitHubConfigurationPropertyInput
    ): SetProjectGitHubConfigurationPropertyPayload
    "Set the gitHub configuration property on a project."
    setProjectGitHubConfigurationPropertyById(
        "Input for the mutation"
        input: SetProjectGitHubConfigurationPropertyByIdInput
    ): SetProjectGitHubConfigurationPropertyByIdPayload
    "Set the gitLab configuration property on a project identified by name."
    setProjectGitLabConfigurationProperty(
        "Input for the mutation"
        input: SetProjectGitLabConfigurationPropertyInput
    ): SetProjectGitLabConfigurationPropertyPayload
    "Set the gitLab configuration property on a project."
    setProjectGitLabConfigurationPropertyById(
        "Input for the mutation"
        input: SetProjectGitLabConfigurationPropertyByIdInput
    ): SetProjectGitLabConfigurationPropertyByIdPayload
    "Set the message property on a project identified by name."
    setProjectMessageProperty(
        "Input for the mutation"
        input: SetProjectMessagePropertyInput
    ): SetProjectMessagePropertyPayload
    "Set the message property on a project."
    setProjectMessagePropertyById(
        "Input for the mutation"
        input: SetProjectMessagePropertyByIdInput
    ): SetProjectMessagePropertyByIdPayload
    "Set the meta information property on a project identified by name."
    setProjectMetaInfoProperty(
        "Input for the mutation"
        input: SetProjectMetaInfoPropertyInput
    ): SetProjectMetaInfoPropertyPayload
    "Set the meta information property on a project."
    setProjectMetaInfoPropertyById(
        "Input for the mutation"
        input: SetProjectMetaInfoPropertyByIdInput
    ): SetProjectMetaInfoPropertyByIdPayload
    "Sets a property on a project identified by name"
    setProjectProperty(
        "Input for the mutation"
        input: SetProjectPropertyInput
    ): SetProjectPropertyPayload
    "Sets a property on a project identified by ID"
    setProjectPropertyById(
        "Input for the mutation"
        input: SetProjectPropertyByIdInput
    ): SetProjectPropertyByIdPayload
    "Set the sonarQube property on a project identified by name."
    setProjectSonarQubeProperty(
        "Input for the mutation"
        input: SetProjectSonarQubePropertyInput
    ): SetProjectSonarQubePropertyPayload
    "Set the sonarQube property on a project."
    setProjectSonarQubePropertyById(
        "Input for the mutation"
        input: SetProjectSonarQubePropertyByIdInput
    ): SetProjectSonarQubePropertyByIdPayload
    "Set the stale branches property on a project identified by name."
    setProjectStaleProperty(
        "Input for the mutation"
        input: SetProjectStalePropertyInput
    ): SetProjectStalePropertyPayload
    "Set the stale branches property on a project."
    setProjectStalePropertyById(
        "Input for the mutation"
        input: SetProjectStalePropertyByIdInput
    ): SetProjectStalePropertyByIdPayload
    "Set the auto promotion property on a promotion level identified by name."
    setPromotionLevelAutoPromotionProperty(
        "Input for the mutation"
        input: SetPromotionLevelAutoPromotionPropertyInput
    ): SetPromotionLevelAutoPromotionPropertyPayload
    "Set the auto promotion property on a promotion level."
    setPromotionLevelAutoPromotionPropertyById(
        "Input for the mutation"
        input: SetPromotionLevelAutoPromotionPropertyByIdInput
    ): SetPromotionLevelAutoPromotionPropertyByIdPayload
    "Set the message property on a promotion level identified by name."
    setPromotionLevelMessageProperty(
        "Input for the mutation"
        input: SetPromotionLevelMessagePropertyInput
    ): SetPromotionLevelMessagePropertyPayload
    "Set the message property on a promotion level."
    setPromotionLevelMessagePropertyById(
        "Input for the mutation"
        input: SetPromotionLevelMessagePropertyByIdInput
    ): SetPromotionLevelMessagePropertyByIdPayload
    "Set the meta information property on a promotion level identified by name."
    setPromotionLevelMetaInfoProperty(
        "Input for the mutation"
        input: SetPromotionLevelMetaInfoPropertyInput
    ): SetPromotionLevelMetaInfoPropertyPayload
    "Set the meta information property on a promotion level."
    setPromotionLevelMetaInfoPropertyById(
        "Input for the mutation"
        input: SetPromotionLevelMetaInfoPropertyByIdInput
    ): SetPromotionLevelMetaInfoPropertyByIdPayload
    "Sets a property on a promotion level identified by name"
    setPromotionLevelProperty(
        "Input for the mutation"
        input: SetPromotionLevelPropertyInput
    ): SetPromotionLevelPropertyPayload
    "Sets a property on a promotion level identified by ID"
    setPromotionLevelPropertyById(
        "Input for the mutation"
        input: SetPromotionLevelPropertyByIdInput
    ): SetPromotionLevelPropertyByIdPayload
    "Set the message property on a promotion run identified by name."
    setPromotionRunMessageProperty(
        "Input for the mutation"
        input: SetPromotionRunMessagePropertyInput
    ): SetPromotionRunMessagePropertyPayload
    "Set the message property on a promotion run."
    setPromotionRunMessagePropertyById(
        "Input for the mutation"
        input: SetPromotionRunMessagePropertyByIdInput
    ): SetPromotionRunMessagePropertyByIdPayload
    "Set the meta information property on a promotion run identified by name."
    setPromotionRunMetaInfoProperty(
        "Input for the mutation"
        input: SetPromotionRunMetaInfoPropertyInput
    ): SetPromotionRunMetaInfoPropertyPayload
    "Set the meta information property on a promotion run."
    setPromotionRunMetaInfoPropertyById(
        "Input for the mutation"
        input: SetPromotionRunMetaInfoPropertyByIdInput
    ): SetPromotionRunMetaInfoPropertyByIdPayload
    "Sets a property on a promotion run identified by name"
    setPromotionRunProperty(
        "Input for the mutation"
        input: SetPromotionRunPropertyInput
    ): SetPromotionRunPropertyPayload
    "Sets a property on a promotion run identified by ID"
    setPromotionRunPropertyById(
        "Input for the mutation"
        input: SetPromotionRunPropertyByIdInput
    ): SetPromotionRunPropertyByIdPayload
    "Set the message property on a validation run identified by name."
    setValidationRunMessageProperty(
        "Input for the mutation"
        input: SetValidationRunMessagePropertyInput
    ): SetValidationRunMessagePropertyPayload
    "Set the message property on a validation run."
    setValidationRunMessagePropertyById(
        "Input for the mutation"
        input: SetValidationRunMessagePropertyByIdInput
    ): SetValidationRunMessagePropertyByIdPayload
    "Set the meta information property on a validation run identified by name."
    setValidationRunMetaInfoProperty(
        "Input for the mutation"
        input: SetValidationRunMetaInfoPropertyInput
    ): SetValidationRunMetaInfoPropertyPayload
    "Set the meta information property on a validation run."
    setValidationRunMetaInfoPropertyById(
        "Input for the mutation"
        input: SetValidationRunMetaInfoPropertyByIdInput
    ): SetValidationRunMetaInfoPropertyByIdPayload
    "Sets a property on a validation run identified by name"
    setValidationRunProperty(
        "Input for the mutation"
        input: SetValidationRunPropertyInput
    ): SetValidationRunPropertyPayload
    "Sets a property on a validation run identified by ID"
    setValidationRunPropertyById(
        "Input for the mutation"
        input: SetValidationRunPropertyByIdInput
    ): SetValidationRunPropertyByIdPayload
    "Set the message property on a validation stamp identified by name."
    setValidationStampMessageProperty(
        "Input for the mutation"
        input: SetValidationStampMessagePropertyInput
    ): SetValidationStampMessagePropertyPayload
    "Set the message property on a validation stamp."
    setValidationStampMessagePropertyById(
        "Input for the mutation"
        input: SetValidationStampMessagePropertyByIdInput
    ): SetValidationStampMessagePropertyByIdPayload
    "Set the meta information property on a validation stamp identified by name."
    setValidationStampMetaInfoProperty(
        "Input for the mutation"
        input: SetValidationStampMetaInfoPropertyInput
    ): SetValidationStampMetaInfoPropertyPayload
    "Set the meta information property on a validation stamp."
    setValidationStampMetaInfoPropertyById(
        "Input for the mutation"
        input: SetValidationStampMetaInfoPropertyByIdInput
    ): SetValidationStampMetaInfoPropertyByIdPayload
    "Sets a property on a validation stamp identified by name"
    setValidationStampProperty(
        "Input for the mutation"
        input: SetValidationStampPropertyInput
    ): SetValidationStampPropertyPayload
    "Sets a property on a validation stamp identified by ID"
    setValidationStampPropertyById(
        "Input for the mutation"
        input: SetValidationStampPropertyByIdInput
    ): SetValidationStampPropertyByIdPayload
    "Creates or updates a CHML validation stamp"
    setupCHMLValidationStamp(
        "Input for the mutation"
        input: SetupCHMLValidationStampInput
    ): SetupCHMLValidationStampPayload
    "Creates or updates a Metrics validation stamp"
    setupMetricsValidationStamp(
        "Input for the mutation"
        input: SetupMetricsValidationStampInput
    ): SetupMetricsValidationStampPayload
    "Creates or updates a Percentage validation stamp"
    setupPercentageValidationStamp(
        "Input for the mutation"
        input: SetupPercentageValidationStampInput
    ): SetupPercentageValidationStampPayload
    "Creates or updates a promotion level for a branch"
    setupPromotionLevel(
        "Input for the mutation"
        input: SetupPromotionLevelInput
    ): SetupPromotionLevelPayload
    "Creates or updates a TestSummary validation stamp"
    setupTestSummaryValidationStamp(
        "Input for the mutation"
        input: SetupTestSummaryValidationStampInput
    ): SetupTestSummaryValidationStampPayload
    "Creates or updates a validation stamp for a branch"
    setupValidationStamp(
        "Input for the mutation"
        input: SetupValidationStampInput
    ): SetupValidationStampPayload
    "Shares a build filter for all users"
    shareBuildFilter(
        "Input for the mutation"
        input: ShareBuildFilterInput
    ): ShareBuildFilterPayload
    "Shares a dashboard"
    shareDashboard(input: ShareDashboardInput!): ShareDashboardPayload
    "Shares or updates a filter at project level"
    shareSCMFileChangeFilter(
        "Input for the mutation"
        input: ShareSCMFileChangeFilterInput
    ): ShareSCMFileChangeFilterPayload
    "Starts a pipeline for a slot and a build"
    startSlotPipeline(
        "Input for the mutation"
        input: StartSlotPipelineInput
    ): StartSlotPipelinePayload
    "Starts the deployment of a pipeline"
    startSlotPipelineDeployment(
        "Input for the mutation"
        input: StartSlotPipelineDeploymentInput
    ): StartSlotPipelineDeploymentPayload
    "Stops a job"
    stopJob(id: Int!): JobActionResult!
    "Stopping a running workflow. Does not do anything if already stopped."
    stopWorkflow(
        "Input for the mutation"
        input: StopWorkflowInput
    ): StopWorkflowPayload
    "Set a list of subscriptions on a branch identified by name."
    subscribeBranchToEvents(
        "Input for the mutation"
        input: SubscribeBranchToEventsInput
    ): SubscribeBranchToEventsPayload
    "Set a list of subscriptions on a build identified by name."
    subscribeBuildToEvents(
        "Input for the mutation"
        input: SubscribeBuildToEventsInput
    ): SubscribeBuildToEventsPayload
    "Set a list of subscriptions on a project identified by name."
    subscribeProjectToEvents(
        "Input for the mutation"
        input: SubscribeProjectToEventsInput
    ): SubscribeProjectToEventsPayload
    "Set a list of subscriptions on a promotion level identified by name."
    subscribePromotionLevelToEvents(
        "Input for the mutation"
        input: SubscribePromotionLevelToEventsInput
    ): SubscribePromotionLevelToEventsPayload
    "Set a list of subscriptions on a promotion run identified by name."
    subscribePromotionRunToEvents(
        "Input for the mutation"
        input: SubscribePromotionRunToEventsInput
    ): SubscribePromotionRunToEventsPayload
    "Creates a subscription to a list of events"
    subscribeToEvents(
        "Input for the mutation"
        input: SubscribeToEventsInput
    ): SubscribeToEventsPayload
    "Set a list of subscriptions on a validation run identified by name."
    subscribeValidationRunToEvents(
        "Input for the mutation"
        input: SubscribeValidationRunToEventsInput
    ): SubscribeValidationRunToEventsPayload
    "Set a list of subscriptions on a validation stamp identified by name."
    subscribeValidationStampToEvents(
        "Input for the mutation"
        input: SubscribeValidationStampToEventsInput
    ): SubscribeValidationStampToEventsPayload
    "Tests a configuration"
    testConfiguration(
        "Input for the mutation"
        input: TestConfigurationInput
    ): TestConfigurationPayload
    "Tests a Jenkins configuration"
    testJenkinsConfiguration(
        "Input for the mutation"
        input: TestJenkinsConfigurationInput
    ): TestJenkinsConfigurationPayload
    "Unmarks a branch as favourite"
    unfavouriteBranch(
        "Input for the mutation"
        input: UnfavouriteBranchInput
    ): UnfavouriteBranchPayload
    "Unmarks a project as favourite"
    unfavouriteProject(
        "Input for the mutation"
        input: UnfavouriteProjectInput
    ): UnfavouriteProjectPayload
    "Unlocks an account"
    unlockAccount(
        "Input for the mutation"
        input: UnlockAccountInput
    ): UnlockAccountPayload
    "Unshares a filter at project level"
    unshareSCMFileChangeFilter(
        "Input for the mutation"
        input: UnshareSCMFileChangeFilterInput
    ): UnshareSCMFileChangeFilterPayload
    "Updates an existing build"
    updateBuild(
        "Input for the mutation"
        input: UpdateBuildInput
    ): UpdateBuildPayload
    "Updates a configuration"
    updateConfiguration(
        "Input for the mutation"
        input: UpdateConfigurationInput
    ): UpdateConfigurationPayload
    "Updates a Jenkins configuration"
    updateJenkinsConfiguration(
        "Input for the mutation"
        input: UpdateJenkinsConfigurationInput
    ): UpdateJenkinsConfigurationPayload
    "Updates an existing project"
    updateProject(
        "Input for the mutation"
        input: UpdateProjectInput
    ): UpdateProjectPayload
    "Updates an existing promotion level"
    updatePromotionLevelById(
        "Input for the mutation"
        input: UpdatePromotionLevelByIdInput
    ): UpdatePromotionLevelByIdPayload
    "Updates an existing validation stamp"
    updateValidationStampById(
        "Input for the mutation"
        input: UpdateValidationStampByIdInput
    ): UpdateValidationStampByIdPayload
    "Updates a validation stamp filter"
    updateValidationStampFilter(
        "Input for the mutation"
        input: UpdateValidationStampFilterInput
    ): UpdateValidationStampFilterPayload
    "Validates a build identified by id with CHML data"
    validateBuildByIdWithCHML(
        "Input for the mutation"
        input: ValidateBuildByIdWithCHMLInput
    ): ValidateBuildByIdWithCHMLPayload
    "Validates a build identified by id with Metrics data"
    validateBuildByIdWithMetrics(
        "Input for the mutation"
        input: ValidateBuildByIdWithMetricsInput
    ): ValidateBuildByIdWithMetricsPayload
    "Validates a build identified by id with Percentage data"
    validateBuildByIdWithPercentage(
        "Input for the mutation"
        input: ValidateBuildByIdWithPercentageInput
    ): ValidateBuildByIdWithPercentagePayload
    "Validates a build identified by id with Tests data"
    validateBuildByIdWithTests(
        "Input for the mutation"
        input: ValidateBuildByIdWithTestsInput
    ): ValidateBuildByIdWithTestsPayload
    "Validates a build identified by name with CHML data"
    validateBuildWithCHML(
        "Input for the mutation"
        input: ValidateBuildWithCHMLInput
    ): ValidateBuildWithCHMLPayload
    "Validates a build identified by name with Metrics data"
    validateBuildWithMetrics(
        "Input for the mutation"
        input: ValidateBuildWithMetricsInput
    ): ValidateBuildWithMetricsPayload
    "Validates a build identified by name with Percentage data"
    validateBuildWithPercentage(
        "Input for the mutation"
        input: ValidateBuildWithPercentageInput
    ): ValidateBuildWithPercentagePayload
    "Validates a build identified by name with Tests data"
    validateBuildWithTests(
        "Input for the mutation"
        input: ValidateBuildWithTestsInput
    ): ValidateBuildWithTestsPayload
    "Validates a workflow which is defined as JSON"
    validateJsonWorkflow(
        "Input for the mutation"
        input: ValidateJsonWorkflowInput
    ): ValidateJsonWorkflowPayload
}

"Association of a name with a value"
type NameValue {
    "Name"
    name: String!
    "Value"
    value: String!
}

"Notification channel"
type NotificationChannel {
    "enabled field"
    enabled: Boolean
    "type field"
    type: String!
}

"Notification record"
type NotificationRecord {
    "Channel type"
    channel: String!
    "Channel configuration"
    channelConfig: JSON!
    "Event being notified"
    event: JSON!
    "Record unique ID"
    id: String!
    "Result of the notification"
    result: NotificationRecordResult!
    "Source of the notification"
    source: NotificationSourceData
    "Record timestamp"
    timestamp: LocalDateTime
}

type NotificationRecordPaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [NotificationRecord!]!
}

"Result for a notification"
type NotificationRecordResult {
    "Result message"
    message: String
    "Output of the channel"
    output: JSON
    "Type of result"
    type: NotificationResultType!
}

"Notification settings"
type NotificationSettings {
    "Are the notifications enabled for this Ontrack instance?"
    enabled: Boolean!
}

"Data linking to the source of a notification"
type NotificationSourceData {
    "Data allowing the identification of the notification source"
    data: JSON!
    "ID of the notification source"
    id: String!
}

"Information about a commit"
type OntrackGitCommitInfo {
    "Associated branch info per types of branches"
    branchInfosList: [BranchInfos!]!
    "Information about the commit itself"
    uiCommit: GitUICommit
}

"Information about an issue"
type OntrackGitIssueInfo {
    "Information about the last commit associated with this issue"
    commitInfo: OntrackGitCommitInfo
    "JSON representation of the issue"
    issue: JSON
    "Issue service associated with the issue"
    issueServiceConfigurationRepresentation: IssueServiceConfigurationRepresentation
}

type PageInfo {
    "Offset for the current page"
    currentOffset: Int
    "Size for the current page"
    currentSize: Int
    "Next page offset and size"
    nextPage: PageRequest
    "Index of the page in the total number of pages (starting from 0)"
    pageIndex: Int
    "Total number of pages"
    pageTotal: Int
    "Previous page offset and size"
    previousPage: PageRequest
    "Total known size of the list"
    totalSize: Int
}

type PageRequest {
    "Offset for the page"
    offset: Int
    "Size for the page"
    size: Int
}

"Representation of an error."
type PayloadUserError {
    "Programmatic code to be used by client. Usually the FQCN of the corresponding exception."
    exception: String!
    "Additional information about the location of this error."
    location: String
    "The error message"
    message: String!
}

"Output type for the postQueue mutation."
type PostQueuePayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Result of the post"
    queueDispatchResult: QueueDispatchResult
}

"Predefined promotion level"
type PredefinedPromotionLevel {
    "description field"
    description: String
    "id field"
    id: Int
    "isImage field"
    isImage: Boolean
    "name field"
    name: String!
}

"Predefined validation stamp"
type PredefinedValidationStamp {
    "description field"
    description: String
    "id field"
    id: Int
    "isImage field"
    isImage: Boolean
    "name field"
    name: String!
}

"Preferences"
type Preferences {
    "Branch view VS groups"
    branchViewVsGroups: Boolean!
    "Branch view VS names"
    branchViewVsNames: Boolean!
    "Dashboard selected by default"
    dashboardUuid: String
    "Selected branch view"
    selectedBranchViewKey: String
}

type Project implements Authorizable & ProjectEntity {
    "Actions for a Project"
    actions: ProjectActions @deprecated(reason: "Will be removed in V5. User `userMenuActions` instead.")
    "Description with links."
    annotatedDescription: String
    "Authorizations for this context"
    authorizations: [Authorization!]!
    "Given a list of patterns and their behaviour, allows the disabling of branches based on their Ontrack names."
    autoDisablingBranchPatternsProperty: Property
    "If set, this property allows promotion levels to be created automatically from predefined promotion levels"
    autoPromotionLevelProperty: Property
    "If set, this property allows validation stamps to be created automatically from predefined validation stamps"
    autoValidationStampProperty: Property
    "Auto-versioning rules at project level"
    autoVersioningProjectProperty: Property
    "Associates the project with a Bitbucket Cloud repository"
    bitbucketCloudProjectConfigurationProperty: Property
    branches(
        "Maximum number of branches to return. No limit if not specified."
        count: Int,
        "Gets only favorite branches"
        favourite: Boolean,
        "Regular expression to match against the branch name"
        name: String,
        "If set to true, the branches will be ordered from the most recent build activity."
        order: Boolean,
        "If set to true, filter on branch matching the project's branching model"
        useModel: Boolean
    ): [Branch!]!
    "Defines the branching model used by a project"
    branchingModelProperty: Property
    "Configuration of display options for the build links towards this project."
    buildLinkDisplayProperty: Property
    creation: Signature
    "List of decorations"
    decorations(
        "Fully qualified name of the decoration type"
        type: String
    ): [Decoration!]!
    description: String
    disabled: Boolean!
    "Is this project a favourite of the current user?"
    favourite: Boolean
    "Information about a Git commit in the project"
    gitCommitInfo(
        "Full or abbreviated hash of the commit to look for"
        commit: String!,
        "Flag to display only the first branch per type"
        first: Boolean
    ): OntrackGitCommitInfo
    "Associates the project with a GitHub repository"
    gitHubProjectConfigurationProperty: Property
    "List of formats supported for the export of issues in this project"
    gitIssueExportFormats: [ExportFormat!]! @deprecated(reason: "List of issue export formats can be taken from the root and is now called issueExportFormats.")
    "Information about an issue in the project"
    gitIssueInfo(
        "Flag to display only the first branch per type"
        first: Boolean,
        "Key or full name of an issue"
        token: String!
    ): OntrackGitIssueInfo
    "Associates the project with a GitLab repository"
    gitLabProjectConfigurationProperty: Property
    "Associates the project with a Git repository"
    gitProjectConfigurationProperty: Property
    "URL to the HTML page of the Git repository associated with this project"
    gitRepositoryHtmlURL: String
    id: Int!
    "List of indicator portfolios associated with this project, through its labels."
    indicatorPortfolios: [IndicatorPortfolio!]!
    "List of information components attached to this entity"
    information: [EntityInformation!]!
    "List of links to follow when displaying information about an issue."
    jIRAFollowLinksProperty: Property
    "Link to a Jenkins Job"
    jenkinsJobProperty: Property
    "Labels for this project"
    labels: [Label!]!
    "For each promotion, returns the last promotion run within the project"
    lastBuildsWithPromotions(
        "List of promotion names"
        promotions: [String!]!
    ): [PromotionRun!]!
    "List of links."
    linkProperty: Property
    "Links"
    links: ProjectLinks @deprecated(reason: "Use the `actions` field instead.")
    """

    List of project labels which describes the list of build links
    to display in a build links decoration.
    """
    mainBuildLinksProjectProperty: Property
    "Associates an arbitrary message (and its type) to an entity. Will be displayed as a decorator in the UI."
    messageProperty: Property
    "List of meta information properties"
    metaInfoProperty: Property
    "Mock SCM used for testing only"
    mockSCMProjectProperty: Property
    name: String
    "Makes a promotion conditional based on the fact that a previous promotion has been granted."
    previousPromotionConditionProperty: Property
    "List of project indicators"
    projectIndicators: ProjectIndicators
    "Authorisations for the project"
    projectRoles(
        "Filter by role name"
        role: String
    ): [ProjectAuthorization!]!
    "List of properties"
    properties(
        "Keeps properties having a value"
        hasValue: Boolean = false,
        "Fully qualified name of the property type"
        type: String
    ): [Property!]!
    "SCM catalog entry the project is linked with, if any"
    scmCatalogEntry: SCMCatalogEntry
    "List of saved SCM file filters for the project"
    scmFileChangeFilters: SCMFileChangeFilters!
    "Association with a SonarQube project."
    sonarQubeProperty: Property
    "Allows to disable or delete stale branches"
    staleProperty: Property
    "Associates the project with a Bitbucket Server repository"
    stashProjectConfigurationProperty: Property
    "List of actions available for this entity"
    userMenuActions: [UserMenuAction!]!
    "Searching for validation runs in the project"
    validationRuns(
        "Branch where to look for validation runs (regular expression, defaults to all)"
        branch: String,
        "Offset for the page"
        offset: Int = 0,
        "Size of the page"
        size: Int = 20,
        "Validation status to look for (regular expression, defaults to all)"
        statuses: String,
        "Validation stamp where to look for validation runs (regular expression, defaults to all)"
        validationStamp: String
    ): ValidationRunPaginated
}

"Deleting the project"
type ProjectActionDeleteProject {
    "Description of the action"
    description: String!
    "Mutation associated with this action"
    mutation: String
}

"Disabling the project"
type ProjectActionDisableProject {
    "Description of the action"
    description: String!
    "Mutation associated with this action"
    mutation: String
}

"Enabling the project"
type ProjectActionEnableProject {
    "Description of the action"
    description: String!
    "Mutation associated with this action"
    mutation: String
}

"Marks the project as a favourite"
type ProjectActionFavouriteProject {
    "Description of the action"
    description: String!
    "Mutation associated with this action"
    mutation: String
}

"Unmarks the project as a favourite"
type ProjectActionUnfavouriteProject {
    "Description of the action"
    description: String!
    "Mutation associated with this action"
    mutation: String
}

"Updating the project"
type ProjectActionUpdateProject {
    "Description of the action"
    description: String!
    "Links attached to this action"
    links: ProjectActionUpdateProjectLinks
    "Mutation associated with this action"
    mutation: String
}

"Links attached to the updateProject action on the Project type."
type ProjectActionUpdateProjectLinks {
    "Updating the project"
    form: UIActionLink
}

"Actions for a Project"
type ProjectActions {
    "Deleting the project"
    deleteProject: ProjectActionDeleteProject
    "Disabling the project"
    disableProject: ProjectActionDisableProject
    "Enabling the project"
    enableProject: ProjectActionEnableProject
    "Marks the project as a favourite"
    favouriteProject: ProjectActionFavouriteProject
    "Unmarks the project as a favourite"
    unfavouriteProject: ProjectActionUnfavouriteProject
    "Updating the project"
    updateProject: ProjectActionUpdateProject
}

type ProjectAuthorization {
    "List of accounts having this role"
    accounts: [Account!]!
    "Description of the role"
    description: String
    "List of groups having this role"
    groups: [AccountGroup!]!
    "ID of the role"
    id: String
    "Unique name for the role"
    name: String
}

"Association of an indicator category and a list of associated indicators."
type ProjectCategoryIndicators {
    "Indicator category"
    category: IndicatorCategory
    "Indicator stats for this project and category"
    categoryStats(
        "Number of seconds (> 0) to get indicator trends from."
        duration: Int
    ): IndicatorCategoryStats
    "List of indicators"
    indicators: [ProjectIndicator!]!
}

"Information about a project entity"
type ProjectEntityInformation {
    "Project entity"
    entity: ProjectEntity!
    "Full name of the project entity"
    entityName: String!
    "ID of the project entity"
    id: Int
    "Name of the project entity"
    name: String!
    "List of properties for this entity"
    properties(
        "Keeps only properties which have a value"
        hasValue: Boolean
    ): [Property!]!
    "Type of the project entity"
    type: ProjectEntityType!
}

"Project indicator"
type ProjectIndicator {
    "Comment with links."
    annotatedComment: String
    "Comment for the indicator"
    comment: String
    "Compliance for the indicator"
    compliance: Int
    "Time elapsed (in seconds) since the indicator value was set."
    durationSecondsSince: Int
    "History of this indicator"
    history(
        "Offset for the page"
        offset: Int = 0,
        "Size of the page"
        size: Int = 20
    ): ProjectIndicatorHistoryItemPaginated
    "Links"
    links: ProjectIndicatorLinks @deprecated(reason: "Use the `actions` field instead.")
    "Previous value for this indicator"
    previousValue: ProjectIndicator
    "Associated project"
    project: Project
    "Rating for this indicator"
    rating: String
    "Signature for the indicator"
    signature: Signature
    "Trend since the previous value (if any)"
    trendSincePrevious: String
    "Type of indicator"
    type: ProjectIndicatorType
    "Value for the indicator"
    value: JSON
}

"Project indicator"
type ProjectIndicatorHistoryItem {
    "Comment with links."
    annotatedComment: String
    "Comment for the indicator"
    comment: String
    "Compliance for the indicator"
    compliance: Int
    "Time elapsed (in seconds) since the indicator value was set."
    durationSecondsSince: Int
    "Rating for this indicator"
    rating: String
    "Signature for the indicator"
    signature: Signature
    "Type of indicator"
    type: ProjectIndicatorType
    "Value for the indicator"
    value: JSON
}

type ProjectIndicatorHistoryItemPaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [ProjectIndicatorHistoryItem!]!
}

"ProjectIndicator links"
type ProjectIndicatorLinks {
    _delete: String
    _update: String
}

"Type of indicator"
type ProjectIndicatorType {
    "Associated category"
    category: IndicatorCategory
    "Flag which indicates if the associated project indicators are computed or not"
    computed: Boolean
    "Indicator type deprecation reason if any"
    deprecated: String
    "Unique ID for the type"
    id: String
    "List of indicators for this type"
    indicators(
        "Reports only projects where the indicator is filled in"
        filledOnly: Boolean,
        "Reports on the projects matching this label"
        label: String,
        "Reports on the projects belonging to this portfolio"
        portfolio: String,
        "Reports on the project matching this ID"
        projectId: Int,
        "Reports on the project matching this name"
        projectName: String,
        "Rate must be worse or equal."
        rate: String
    ): [ProjectIndicator!]!
    "Link to the definition of the indicator"
    link: String
    "Links"
    links: ProjectIndicatorTypeLinks @deprecated(reason: "Use the `actions` field instead.")
    "Name for the indicator type"
    name: String
    "Source for this type"
    source: IndicatorSource
    "Configuration for the value type"
    valueConfig: JSON
    "Value type"
    valueType: IndicatorValueType
}

"ProjectIndicatorType links"
type ProjectIndicatorTypeLinks {
    _delete: String
    _update: String
}

"List of indicators for a project"
type ProjectIndicators {
    "List of indicator categories"
    categories: [ProjectCategoryIndicators!]!
    "List of indicators"
    indicators(
        "Restriction on the indicator category"
        category: String,
        "Restriction on the indicator type"
        type: String
    ): [ProjectIndicator!]!
    "Associated project"
    project: Project
}

"Project links"
type ProjectLinks {
    _actions: String
    _branchStatusViews: String
    _branches: String
    _buildDiffActions: String
    _buildSearch: String
    _clone: String
    _createBranch: String
    _decorations: String
    _delete: String
    _disable: String
    _enable: String
    _events: String
    _extra: String
    _favourite: String
    _gitSync: String
    _labelFromToken: String
    _labels: String
    _labelsCreate: String
    _page: String
    _permissions: String
    _properties: String
    _self: String
    _unfavourite: String
    _update: String
}

type ProjectRole {
    "description field"
    description: String!
    "id field"
    id: String!
    "name field"
    name: String!
}

type PromotionLevel implements Authorizable & ProjectEntity {
    "Link to the image"
    _image: String
    "Description with links."
    annotatedDescription: String
    "Authorizations for this context"
    authorizations: [Authorization!]!
    "Allows a promotion level to be granted on a build as soon as a list of validation stamps and/or other promotions has been passed"
    autoPromotionProperty: Property
    "List of branches targeted for auto-versioning based on this promotion level"
    autoVersioningTargets: [AutoVersioningConfiguredBranch!]!
    "List of branches targeted for auto-versioning based on this promotion level or with their reason for rejection"
    autoVersioningTrail: AutoVersioningTrail
    "Reference to branch"
    branch: Branch
    creation: Signature
    "List of decorations"
    decorations(
        "Fully qualified name of the decoration type"
        type: String
    ): [Decoration!]!
    description: String
    id: Int!
    "Flag to indicate if an image is associated"
    image: Boolean
    "List of information components attached to this entity"
    information: [EntityInformation!]!
    "Link to a Jenkins Job"
    jenkinsJobProperty: Property
    "List of links."
    linkProperty: Property
    "Links"
    links: PromotionLevelLinks @deprecated(reason: "Use the `actions` field instead.")
    "Associates an arbitrary message (and its type) to an entity. Will be displayed as a decorator in the UI."
    messageProperty: Property
    "List of meta information properties"
    metaInfoProperty: Property
    name: String
    "Makes a promotion conditional based on the fact that a previous promotion has been granted."
    previousPromotionConditionProperty: Property
    "List of promotions a promotion depends on before being applied."
    promotionDependenciesProperty: Property
    "List of runs for this promotion"
    promotionRuns(
        "Number of items to return from the beginning of the list"
        first: Int,
        "Number of items to return from the end of the list"
        last: Int
    ): [PromotionRun!]! @deprecated(reason: "Use the paginated promotion runs with the `promotionRunsPaginated` field.")
    "Paginated list of promotion runs"
    promotionRunsPaginated(
        "Keeps only runs after this data / time"
        afterDate: LocalDateTime,
        "Keeps only runs before this data / time"
        beforeDate: LocalDateTime,
        "Regular expression on the name of the build name"
        name: String,
        "Offset for the page"
        offset: Int = 0,
        "Size of the page"
        size: Int = 20,
        "Regular expression on the release property attached to the build name"
        version: String
    ): PromotionRunPaginated
    "List of properties"
    properties(
        "Keeps properties having a value"
        hasValue: Boolean = false,
        "Fully qualified name of the property type"
        type: String
    ): [Property!]!
    "List of actions available for this entity"
    userMenuActions: [UserMenuAction!]!
}

"PromotionLevel links"
type PromotionLevelLinks {
    _actions: String
    _branch: String
    _bulkUpdate: String
    _decorations: String
    _delete: String
    _events: String
    _image: String
    _page: String
    _project: String
    _properties: String
    _runs: String
    _self: String
    _update: String
}

type PromotionRun implements Authorizable & ProjectEntity {
    "Description with links."
    annotatedDescription: String
    "Authorizations for this context"
    authorizations: [Authorization!]!
    "List of branches targeted for auto-versioning based on this promotion run or with their reason for rejection"
    autoVersioningTrail: AutoVersioningTrail
    "Associated build"
    build: Build!
    creation: Signature
    "List of decorations"
    decorations(
        "Fully qualified name of the decoration type"
        type: String
    ): [Decoration!]!
    description: String
    id: Int!
    "List of information components attached to this entity"
    information: [EntityInformation!]!
    "Link to a Jenkins Build"
    jenkinsBuildProperty: Property
    "List of links."
    linkProperty: Property
    "Links"
    links: PromotionRunLinks @deprecated(reason: "Use the `actions` field instead.")
    "Associates an arbitrary message (and its type) to an entity. Will be displayed as a decorator in the UI."
    messageProperty: Property
    "List of meta information properties"
    metaInfoProperty: Property
    name: String
    "Associated promotion level"
    promotionLevel: PromotionLevel!
    "List of properties"
    properties(
        "Keeps properties having a value"
        hasValue: Boolean = false,
        "Fully qualified name of the property type"
        type: String
    ): [Property!]!
    "List of actions available for this entity"
    userMenuActions: [UserMenuAction!]!
}

"PromotionRun links"
type PromotionRunLinks {
    _all: String
    _delete: String
    _image: String
    _page: String
    _properties: String
    _self: String
}

type PromotionRunPaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [PromotionRun!]!
}

type Property {
    "True is the field is editable"
    editable: Boolean
    "Property type"
    type: PropertyType
    "JSON representation of the value"
    value: JSON
}

"Definition for a property"
type PropertyType {
    "Property description"
    description: String!
    "Property display name"
    name: String!
    "List of project entity types supported by this property"
    supportedEntityTypes: [ProjectEntityType!]!
    "Full type name for the property"
    typeName: String!
}

"Output type for the purgeHookRecordings mutation."
type PurgeHookRecordingsPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the purgeQueueRecordings mutation."
type PurgeQueueRecordingsPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

type Query {
    accountGroupMappings(
        "Group name"
        group: String,
        "Mapping name"
        name: String,
        "Authentication source provider"
        provider: String,
        "Authentication source name"
        source: String
    ): [AccountGroupMapping!]!
    accountGroups(
        "Searching by ID"
        id: Int,
        "Searching by looking for a mapping"
        mapping: String,
        "Searching by looking for a string in the name or the description"
        name: String
    ): [AccountGroup!]
    accounts(
        "Searching by looking for a string in one of the groups the account belongs to"
        group: String,
        "Searching by ID"
        id: Int,
        "Searching by looking for a string in the name or the full name"
        name: String
    ): [Account!]
    "List of all authentication sources."
    authenticationSources(
        "Filters on authentication sources which allow the user's password to be changed"
        allowingPasswordChange: Boolean,
        "Filters on authentication source which are enabled"
        enabled: Boolean,
        "Filters on authentication sources which support group mapping"
        groupMappingSupported: Boolean
    ): [AuthenticationSource!]!
    "Getting a list of authorizations for the authenticated user"
    authorizations: [Authorization!]!
    "List of audit entries for auto versioning processing orders"
    autoVersioningAuditEntries(
        "Filter on the auto versioning entries"
        filter: AutoVersioningAuditQueryFilter,
        "Offset for the page"
        offset: Int = 0,
        "Size of the page"
        size: Int = 20
    ): AutoVersioningAuditEntryPaginated
    "List of possible states for auto version audit entries"
    autoVersioningAuditStates: [String!]!
    "Getting a branch using its ID"
    branch(
        "ID of the branch to look for"
        id: Int!
    ): Branch!
    branches(
        "Keeps only branches listed as favourute"
        favourite: Boolean,
        "ID of the branch to look for"
        id: Int,
        "Regular expression to match against the branch name"
        name: String,
        "Name of the project the branch belongs to"
        project: String,
        "Fragment to match against the branch name"
        token: String,
        "Filter on property type and optional value pattern."
        withProperty: PropertyFilter
    ): [Branch!]
    "Getting a build using its ID"
    build(
        "ID of the build to look for"
        id: Int!
    ): Build!
    buildFilterValidation(
        "ID of the branch to look for"
        branchId: Int!,
        "Generic filter based on a configured filter"
        filter: GenericBuildFilter!
    ): BuildFilterValidation
    builds(
        "Name of a branch - requires 'project' to be filled as well"
        branch: String,
        "Filter to apply for the builds on the branch - requires 'branch' to be filled."
        buildBranchFilter: StandardBuildFilter,
        "Filter to apply for the builds on the project - requires 'project' to be filled."
        buildProjectFilter: BuildSearchForm,
        "ID of the build to look for"
        id: Int,
        "Name of a build - requires 'project' & 'branch' to be filled as well"
        name: String,
        "Name of a project"
        project: String
    ): [Build!]
    "Configuration as Code"
    casc: CasC!
    "List of configurable indicators"
    configurableIndicators(
        "Filter the indicators on their category ID"
        category: String,
        "Filter the indicators on their type ID"
        type: String
    ): [ConfigurableIndicatorTypeState!]!
    "Gets a list of configuration for a given type."
    configurations(
        "Configuration type"
        configurationType: String!
    ): [Configuration!]!
    "List of available widgets"
    dashboardWidgets: [Widget!]!
    "Getting a project entity using its type and ID."
    entity(
        "ID of the entity"
        id: Int,
        "Type of the entity"
        type: ProjectEntityType!
    ): ProjectEntityInformation
    "Collection of entity counts"
    entityCounts: EntityCounts!
    "Getting an environment using its name"
    environmentByName(
        "Name of the environment"
        name: String!
    ): Environment
    "List of environments"
    environments(
        "Filter on the environments"
        filter: EnvironmentFilter
    ): [Environment!]!
    "List of event subscriptions"
    eventSubscriptions(
        "Filter for the subscriptions"
        filter: EventSubscriptionFilter,
        "Offset for the page"
        offset: Int = 0,
        "Size of the page"
        size: Int = 20
    ): EventSubscriptionPayloadPaginated
    "List of all event types"
    eventTypes: [EventType!]!
    "Getting data for a chart"
    getChart(
        "Parameters for getting the chart"
        input: GetChartInput!
    ): JSON
    gitChangeLog(
        "ID of the build to start the change log with"
        from: Int!,
        "ID of the build to end the change log with"
        to: Int!
    ): GitChangeLog @deprecated(reason: "Will be removed in V5. Prefer using the `scmChangeLog` query.")
    "Gets a change log by its UUID"
    gitChangeLogByUUID(
        "UUID of the change log"
        uuid: String!
    ): GitChangeLog @deprecated(reason: "Will be removed in V5. Prefer using the `scmChangeLog` query.")
    "Getting Ontrack information about a Git commit and a project."
    gitCommitInfo(
        "Commit hash (full form) to look for."
        commit: String!
    ): OntrackGitCommitInfo
    "List of GitHub configurations"
    gitHubConfigurations(
        "Name of the configuration to get"
        name: String
    ): [GitHubEngineConfiguration!]!
    "List of possible outcomes for the processing of ingestion hook payloads."
    gitHubIngestionEventProcessingResults: [IngestionEventProcessingResult!]!
    "List of statuses for the processing of ingestion hook payloads."
    gitHubIngestionHookPayloadStatuses: [IngestionHookPayloadStatus!]!
    "List of payloads received by the GitHub Ingestion Hook payload"
    gitHubIngestionHookPayloads(
        "Filter on the GitHub Delivery ID"
        gitHubDelivery: String,
        "Filter on the GitHub Event"
        gitHubEvent: String,
        "Offset for the page"
        offset: Int = 0,
        "Filter on the outcome"
        outcome: IngestionEventProcessingResult,
        "Filter on the GitHub repository owner name"
        owner: String,
        "Filter on the queue information"
        queue: String,
        "Filter on the GitHub repository name"
        repository: String,
        "Filter on the routing information"
        routing: String,
        "Size of the page"
        size: Int = 20,
        "Filter on the source (prefix)"
        source: String,
        "Filter on the statuses"
        statuses: [IngestionHookPayloadStatus!],
        "Filter on the UUID"
        uuid: String
    ): GitHubIngestionHookPayloadPaginated
    "Getting Ontrack information about a Git issue and a project."
    gitIssueInfo(
        "Issue key"
        issue: String!
    ): OntrackGitIssueInfo
    "List of global messages"
    globalMessages: [Message!]!
    "List of global security roles"
    globalRoles(
        "Filter by role name"
        role: String
    ): [GlobalRole!]!
    "Information for the hook record query filter"
    hookRecordFilterInfo: HookRecordFilterInfo!
    "List of recordings for hook messages"
    hookRecordings(
        "Filter"
        filter: HookRecordingFilterInput,
        "Offset for the page"
        offset: Int = 0,
        "Size of the page"
        size: Int = 20
    ): HookRecordingPaginated
    "List of indicator categories"
    indicatorCategories: IndicatorCategories
    "List of all portfolios"
    indicatorPortfolioOfPortfolios: IndicatorPortfolioOfPortfolios
    "List of indicator portfolios"
    indicatorPortfolios(
        "ID of the indicator portfolio"
        id: String
    ): [IndicatorPortfolio!]!
    "List of indicator types"
    indicatorTypes: IndicatorTypes
    "List of indicator views."
    indicatorViewList: IndicatorViewList
    "List of available commands for the management of the indicators"
    indicatorsManagement: IndicatorsManagement! @deprecated(reason: "Will be removed in 4.6")
    "Gets information about the application"
    info: Info
    "List of available export formats"
    issueExportFormats: [IssueExportFormat!]! @deprecated(reason: "Use the templating service")
    "List of issue services"
    issueServiceConfigurations: [IssueServiceConfigurationRepresentation!]!
    "Getting a Jenkins configuration by name"
    jenkinsConfiguration(name: String!): JenkinsConfiguration
    "List of Jenkins configurations"
    jenkinsConfigurations: [JenkinsConfiguration!]!
    "Getting a Jira configuration by name"
    jiraConfiguration(name: String!): JiraConfiguration
    "List of Jira configurations"
    jiraConfigurations: [JiraConfiguration!]!
    "List of all job categories and their types (at any given time)"
    jobCategories: [JobCategory!]!
    "Overall status of the execution of the jobs"
    jobExecutionStatus: JobExecutionStatus
    "List of job states"
    jobStateInfos: [JobStateInfo!]!
    "List of background jobs"
    jobs(
        "Category key"
        category: String,
        "Part of the description of the job"
        description: String,
        "Jobs on error"
        error: Boolean,
        "Offset for the page"
        offset: Int = 0,
        "Size of the page"
        size: Int = 20,
        "State of the job"
        state: JobState,
        "Jobs with timeout"
        timeout: Boolean,
        "Type key"
        type: String
    ): JobStatusPaginated
    "List of all labels"
    labels(
        "Category to look for"
        category: String,
        "Name to look for"
        name: String
    ): [Label!]!
    "Returns the list of last active projects"
    lastActiveProjects(
        "Maximum number of projects to return"
        count: Int = 10
    ): [Project!]!
    "License"
    licenseInfo: LicenseResponse!
    "Getting a list of texts generated for a mock workflow"
    mockWorkflowTexts(
        "ID of the workflow instance"
        instanceId: String
    ): [String!]!
    "List of all notification channels"
    notificationChannels: [NotificationChannel!]!
    "Getting a notification record using its ID"
    notificationRecord(
        "Record ID"
        id: String!
    ): NotificationRecord
    "Access to the notification recordings"
    notificationRecords(
        "Filtering on the channel"
        channel: String,
        "Filtering on the entity ID targeted by the event (eventEntityType must be provided as well)"
        eventEntityId: Int,
        "Filtering on the entity type targeted by the event (eventEntityId must be provided as well)"
        eventEntityType: ProjectEntityType,
        "Offset for the page"
        offset: Int = 0,
        "Filtering on the result type"
        resultType: NotificationResultType,
        "Size of the page"
        size: Int = 20,
        "Filtering on the source data"
        sourceData: JSON,
        "Filtering on the source type"
        sourceId: String
    ): NotificationRecordPaginated
    "Notification settings"
    notificationSettings: NotificationSettings
    "Basic test service"
    ping: String
    "Predefined promotion level by name"
    predefinedPromotionLevelByName(
        "Name"
        name: String!
    ): PredefinedPromotionLevel
    "Gets a predefined validation stamps by name"
    predefinedValidationStampByName(
        "Name"
        name: String!
    ): PredefinedValidationStamp
    "Gets the preferences of the current user"
    preferences: Preferences!
    project(
        "ID of the project to look for (required)"
        id: Int!
    ): Project
    projects(
        "Favourite projects only"
        favourites: Boolean,
        "ID of the project to look for"
        id: Int,
        "List of labels the project must have"
        labels: [String],
        "Name of the project to look for"
        name: String,
        "Part of the name of the project to look for"
        pattern: String,
        "Filter on property type and optional value pattern."
        withProperty: PropertyFilter
    ): [Project!]
    promotionLevel(
        "ID of the promotion level to look for (required)"
        id: Int!
    ): PromotionLevel
    "Promotion level by name"
    promotionLevelByName(
        "Branch name"
        branch: String!,
        "Promotion level name"
        name: String!,
        "Project name"
        project: String!
    ): PromotionLevel
    "Gets a list of existing available promotion level names"
    promotionLevelNames(
        "Part of the name to look for"
        token: String
    ): [String!]!
    promotionRuns(
        "ID of the promotion run to look for"
        id: Int!
    ): [PromotionRun!]!
    "Getting a list of properties"
    properties(
        "Project entity supported by the property"
        projectEntityType: ProjectEntityType,
        "FQCN of the property type"
        type: String
    ): [PropertyType!]!
    "Information for the queue record query filter"
    queueRecordFilterInfo: QueueRecordFilterInfo!
    "List of recordings for queue messages"
    queueRecordings(
        "Filter"
        filter: QueueRecordingFilterInput,
        "Offset for the page"
        offset: Int = 0,
        "Size of the page"
        size: Int = 20
    ): QueueRecordingPaginated
    "List of SCM catalog entries and/or orphan projects"
    scmCatalog(
        "Selects entries whose creation date is after this date."
        afterCreatedAt: String,
        "Selects entries whose last activity is after this date."
        afterLastActivity: String,
        "Selects entries whose creation date is before this date."
        beforeCreatedAt: String,
        "Selects entries whose last activity is before this date."
        beforeLastActivity: String,
        "Filters on SCM config name (exact match)"
        config: String,
        "Filters on entries which are linked or not to projects (ALL, ENTRY, LINKED, UNLINKED, ORPHAN)"
        link: String,
        "Offset for the page"
        offset: Int = 0,
        "Filters on the name of the orphan projects"
        project: String,
        "Filters on repository (regular expression)"
        repository: String,
        "Filters on SCM type (exact match)"
        scm: String,
        "Size of the page"
        size: Int = 20,
        "Sorting direction."
        sortAscending: Boolean,
        "Property to sort on. Supported: REPOSITORY, LAST_ACTIVITY, CREATED_AT"
        sortOn: String,
        "ID of the SCM team. Empty string to select entries without a team."
        team: String
    ): SCMCatalogEntryOrProjectPaginated
    "Counts of SCM catalog entries having N teams"
    scmCatalogTeamStats: [SCMCatalogTeamStats!]!
    "List of teams indexed by the SCM catalog"
    scmCatalogTeams: [SCMCatalogTeam!]!
    "Query to get a change log between two builds."
    scmChangeLog(
        "ID of the build from"
        from: Int!,
        """

        List of projects to follow one by one for a get deep change log. Each item
        in the list is either a project name, or a project name and qualifier separated
        by a colon (:).
        """
        projects: [String!],
        "ID of the build to"
        to: Int!
    ): SCMChangeLog
    "Performs a search in Ontrack"
    search(
        "Offset for the page"
        offset: Int = 0,
        "Size of the page"
        size: Int = 20,
        "Query string"
        token: String!,
        "Result type"
        type: String
    ): SearchResultPaginated
    "List of types of search results"
    searchResultTypes: [SearchResultType!]!
    "Ontrack settings"
    settings: Settings!
    "Getting a slot using its id"
    slotById(
        "ID of the slot"
        id: String!
    ): Slot
    "Getting a slot pipeline by ID"
    slotPipelineById(
        "Pipeline ID"
        id: String!
    ): SlotPipeline
    "Getting the list of template renderers"
    templatingRenderers: [TemplatingRenderer!]!
    "Gets the current user"
    user: User
    "Gets the current dashboard"
    userDashboard: Dashboard!
    "Gets the list of private & shared dashboards"
    userDashboards: [Dashboard!]!
    "List of user menu items"
    userMenuItems: [UserMenuGroup!]!
    "List of all available validation data types"
    validationDataTypes: [ValidationDataTypeDescriptor!]!
    "List of validation run statuses"
    validationRunStatusIDList: [ValidationRunStatusID!]!
    validationRuns(
        "ID of the validation run to look for"
        id: Int!
    ): [ValidationRun!]!
    validationStamp(
        "ID of the validation stamp to look for (required)"
        id: Int!
    ): ValidationStamp
    "Gets a list of existing available validation stamp names"
    validationStampNames(
        "Part of the name to look for"
        token: String!
    ): [String!]!
    "List of registred webhooks"
    webhooks(
        "Name of the webhook"
        name: String
    ): [Webhook!]!
    "Gets an existing workflow instance using its ID"
    workflowInstance(
        "ID of the workflow instance"
        id: String
    ): WorkflowInstance
    "List of workflow instances"
    workflowInstances(
        "Name of a workflow"
        name: String,
        "Offset for the page"
        offset: Int = 0,
        "Size of the page"
        size: Int = 20
    ): WorkflowInstancePaginated
    "List of all workflow node executors"
    workflowNodeExecutors: [WorkflowNodeExecutor!]!
}

"QueueDispatchResult"
type QueueDispatchResult {
    "Queue message ID is applicable"
    id: String
    "Additional information"
    message: String
    "Result of the dispatching"
    type: QueueDispatchResultType!
}

"Payload for a message sent on a queue for processing"
type QueuePayload {
    "Message body for the processor"
    body: JSON!
    "Unique ID of the message"
    id: String!
    "ID of the target processor"
    processor: String!
}

"QueueRecordFilterInfo"
type QueueRecordFilterInfo {
    "List of processors"
    processors: [String!]!
    "List of available queue message states"
    states: [String!]!
}

"Change of state for a queue message"
type QueueRecordHistory {
    "State at this time"
    state: QueueRecordState!
    "Time for the state change"
    time: LocalDateTime!
}

"Recording for queue messages"
type QueueRecording {
    "Actual payload sent to the processing"
    actualPayload: JSON
    "End of processing"
    endTime: LocalDateTime
    "Error on processing"
    exception: String
    "History of the states"
    history: [QueueRecordHistory!]!
    "id field"
    id: String!
    "Queue where the message was stored"
    queueName: String
    "Payload for the queue message"
    queuePayload: QueuePayload!
    "Queue routing key being used"
    routingKey: String
    "Source of the message"
    source: QueueSource
    "Time of creation"
    startTime: LocalDateTime!
    "State of the queuing"
    state: QueueRecordState!
}

type QueueRecordingPaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [QueueRecording!]!
}

"QueueSource"
type QueueSource {
    "JSON data as understood by the QueueSourceExtension"
    data: JSON!
    "ID of the ExtensionFeature which provides the information."
    feature: String!
    "ID of the QueueSourceExtension which provides the information."
    id: String!
}

"Rate limit representation"
type RateLimit {
    "Absolute limit"
    limit: Int
    "Remaining calls"
    remaining: Int
    "Used calls"
    used: Int
}

"Output type for the reloadCasc mutation."
type ReloadCascPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the renameSubscription mutation."
type RenameSubscriptionPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Renamed subscription"
    subscription: EventSubscriptionPayload
}

"Output type for the reorderPromotionLevelById mutation."
type ReorderPromotionLevelByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the revokeAccountTokens mutation."
type RevokeAccountTokensPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the revokeAllTokens mutation."
type RevokeAllTokensPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the revokeToken mutation."
type RevokeTokenPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Creating a project"
type RootUserActionCreateProject {
    "Description of the action"
    description: String!
    "Links attached to this action"
    links: RootUserActionCreateProjectLinks
    "Mutation associated with this action"
    mutation: String
}

"Links attached to the createProject action on the RootUser type."
type RootUserActionCreateProjectLinks {
    "Creating a project"
    form: UIActionLink
}

"Actions for a RootUser"
type RootUserActions {
    "Creating a project"
    createProject: RootUserActionCreateProject
}

type RunInfo {
    creation: Signature
    "Unique ID of the run info"
    id: Int
    "Time of the run (in seconds)"
    runTime: Int
    "Type of source (like \"jenkins\")"
    sourceType: String
    "URI to the source of the run (like the URL to a Jenkins job)"
    sourceUri: String
    "Data associated with the trigger (like a user ID or a commit)"
    triggerData: String
    "Type of trigger (like \"scm\" or \"user\")"
    triggerType: String
}

"SCM information for a given branch."
type SCMBranchInfo {
    "SCM branch"
    branch: String!
    "Are change logs enabled for this SCM?"
    changeLogs: Boolean
    "SCM engine or flavor (like GitHub, etc.)"
    engine: String!
    "SCM type (like git, etc.)"
    type: String!
    "URI of the repository"
    uri: String!
}

"SCM Catalog entry"
type SCMCatalogEntry {
    "SCM Config name"
    config: String
    "Creation timestamp"
    createdAt: LocalDateTime
    "Last activity timestamp"
    lastActivity: LocalDateTime
    "Flag to indicate if this SCM catalog entry is linked to a project"
    linked: Boolean
    "Project linked to this SCM catalog entry. Might be null"
    project: Project
    "SCM repository location"
    repository: String
    "URL to browse the repository"
    repositoryPage: String
    "Type of SCM"
    scm: String
    "List of teams this entry belongs to"
    teams: [SCMCatalogTeam!]
    "Collection timestamp"
    timestamp: LocalDateTime
}

"SCM Catalog entry or/and project"
type SCMCatalogEntryOrProject {
    "SCM Catalog entry"
    entry: SCMCatalogEntry
    "Associated project or orphan project"
    project: Project
}

type SCMCatalogEntryOrProjectPaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [SCMCatalogEntryOrProject!]!
}

"SCM Catalog team"
type SCMCatalogTeam {
    "Team description"
    description: String
    "List of SCM catalog entries for this team"
    entries: [SCMCatalogEntry!]!
    "Number of SCM catalog entries for this team"
    entryCount: Int!
    "Team ID in the SCM"
    id: String!
    "Team name"
    name: String
    "Team role in the SCM entry"
    role: String
    "Team URL"
    url: String
}

"Number of entries in the SCM catalog having this number of teams"
type SCMCatalogTeamStats {
    "Number of entries having this number of teams"
    entryCount: Int
    "Number of teams"
    teamCount: Int
}

"Representation of a change log between two builds"
type SCMChangeLog {
    "List of commits between the builds"
    commits: [SCMDecoratedCommit!]!
    "URL to get the file diff between the two builds"
    diffLink: String
    "Exporting the issues of a change log"
    export(
        "How to generate the exported change log"
        request: SCMChangeLogExportInput
    ): String
    "Boundary for the change log"
    from: Build!
    "List of issues between the builds"
    issues: SCMChangeLogIssues
    "All dependency changes"
    linkChanges: [LinkChange!]!
    "Boundary for the change log"
    to: Build!
}

"SCMChangeLogIssues"
type SCMChangeLogIssues {
    "issueServiceConfiguration field"
    issueServiceConfiguration: IssueServiceConfigurationRepresentation!
    "issues field"
    issues: [Issue!]!
}

"Common attributes for a commit (or revision)."
type SCMCommit {
    "Author of the commit"
    author: String!
    "Mail of the author of the commit. Can be `null` if not available."
    authorEmail: String
    "Identifier of the commit"
    id: String!
    "Link to the commit"
    link: String!
    "Message associated with the commit"
    message: String!
    "Short identifier for the commit"
    shortId: String!
    "Timestamp of the commit"
    timestamp: LocalDateTime!
}

"SCMDecoratedCommit"
type SCMDecoratedCommit {
    "Annotated message with links"
    annotatedMessage: String!
    "Any build linked to this commit"
    build: Build
    "commit field"
    commit: SCMCommit!
}

"Saved file change filter"
type SCMFileChangeFilter {
    "Name of the filter"
    name: String!
    "List of ANT-like patterns for the paths"
    patterns: [String!]!
}

"List of file change filters"
type SCMFileChangeFilters {
    "True if the user can manage shared filters"
    canManage: Boolean!
    "List of filters"
    filters: [SCMFileChangeFilter!]!
}

"Output type for the saveBuildFilter mutation."
type SaveBuildFilterPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

type SaveDashboardPayload implements PayloadInterface {
    "Saved dashboard"
    dashboard: Dashboard
    "List of errors"
    errors: [PayloadUserError]
}

type SaveSettingsPayload implements PayloadInterface {
    "List of errors"
    errors: [PayloadUserError]
}

"Output type for the saveYamlWorkflow mutation."
type SaveYamlWorkflowPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Saved workflow ID"
    workflowId: String
}

"Schedule"
type Schedule {
    "cron field"
    cron: String
    "initialPeriod field"
    initialPeriod: Int
    "period field"
    period: Int
    "periodText field"
    periodText: String!
    "unit field"
    unit: String
}

"Search result"
type SearchResult {
    "Score for the search"
    accuracy: Float
    "Meta-data associated with the result"
    data: JSON
    "Description linked to the item being found"
    description: String
    "Web access point"
    page: String @deprecated(reason: "Will be removed in V5. Use the generic type & data")
    "Short title"
    title: String
    "Type of result"
    type: SearchResultType
    "API access point"
    uri: String @deprecated(reason: "Will be removed in V5. Use the generic type & data")
}

type SearchResultPaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [SearchResult!]!
}

"Type of search result"
type SearchResultType {
    "Short help text explaining the format of the token"
    description: String
    "Associated feature"
    feature: ExtensionFeatureDescription
    "ID for the type of search result"
    id: String
    "Display name for the search result"
    name: String
}

type SelectDashboardPayload implements PayloadInterface {
    "List of errors"
    errors: [PayloadUserError]
}

"Service configuration or data associated with an ID"
type ServiceConfiguration {
    "Data for the service configuration"
    data: JSON
    "ID of the service configuration"
    id: String
}

"Output type for the setAutoVersioningConfigByName mutation."
type SetAutoVersioningConfigByNamePayload implements Payload {
    "Configured branch"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the setAutoVersioningConfig mutation."
type SetAutoVersioningConfigPayload implements Payload {
    "Configured branch"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the setBranchGitConfigPropertyById mutation."
type SetBranchGitConfigPropertyByIdPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the setBranchGitConfigProperty mutation."
type SetBranchGitConfigPropertyPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the setBranchGitHubIngestionConfig mutation."
type SetBranchGitHubIngestionConfigPayload implements Payload {
    "GitHub ingestion configuration"
    configuration: GitHubIngestionConfig
    "List of errors"
    errors: [UserError]
}

"Output type for the setBranchMessagePropertyById mutation."
type SetBranchMessagePropertyByIdPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the setBranchMessageProperty mutation."
type SetBranchMessagePropertyPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the setBranchMetaInfoPropertyById mutation."
type SetBranchMetaInfoPropertyByIdPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the setBranchMetaInfoProperty mutation."
type SetBranchMetaInfoPropertyPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the setBranchPropertyById mutation."
type SetBranchPropertyByIdPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the setBranchProperty mutation."
type SetBranchPropertyPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the setBranchReleaseValidationPropertyById mutation."
type SetBranchReleaseValidationPropertyByIdPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the setBranchReleaseValidationProperty mutation."
type SetBranchReleaseValidationPropertyPayload implements Payload {
    "Branch updated"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the setBuildGitCommitPropertyById mutation."
type SetBuildGitCommitPropertyByIdPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the setBuildGitCommitProperty mutation."
type SetBuildGitCommitPropertyPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the setBuildMessagePropertyById mutation."
type SetBuildMessagePropertyByIdPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the setBuildMessageProperty mutation."
type SetBuildMessagePropertyPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the setBuildMetaInfoPropertyById mutation."
type SetBuildMetaInfoPropertyByIdPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the setBuildMetaInfoProperty mutation."
type SetBuildMetaInfoPropertyPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the setBuildPropertyById mutation."
type SetBuildPropertyByIdPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the setBuildProperty mutation."
type SetBuildPropertyPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the setBuildReleasePropertyById mutation."
type SetBuildReleasePropertyByIdPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the setBuildReleaseProperty mutation."
type SetBuildReleasePropertyPayload implements Payload {
    "Build updated"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the setGenericProperty mutation."
type SetGenericPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Updated property"
    property: Property
}

"Output type for the setPreferences mutation."
type SetPreferencesPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Saved preferences"
    preferences: Preferences
}

"Output type for the setProjectAutoPromotionLevelPropertyById mutation."
type SetProjectAutoPromotionLevelPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectAutoPromotionLevelProperty mutation."
type SetProjectAutoPromotionLevelPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectAutoValidationStampPropertyById mutation."
type SetProjectAutoValidationStampPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectAutoValidationStampProperty mutation."
type SetProjectAutoValidationStampPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectAutoVersioningProjectPropertyById mutation."
type SetProjectAutoVersioningProjectPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectAutoVersioningProjectProperty mutation."
type SetProjectAutoVersioningProjectPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectBitbucketCloudConfigurationPropertyById mutation."
type SetProjectBitbucketCloudConfigurationPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectBitbucketCloudConfigurationProperty mutation."
type SetProjectBitbucketCloudConfigurationPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectBitbucketConfigurationPropertyById mutation."
type SetProjectBitbucketConfigurationPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectBitbucketConfigurationProperty mutation."
type SetProjectBitbucketConfigurationPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectBuildLinkDisplayPropertyById mutation."
type SetProjectBuildLinkDisplayPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectBuildLinkDisplayProperty mutation."
type SetProjectBuildLinkDisplayPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectGitHubConfigurationPropertyById mutation."
type SetProjectGitHubConfigurationPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectGitHubConfigurationProperty mutation."
type SetProjectGitHubConfigurationPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectGitLabConfigurationPropertyById mutation."
type SetProjectGitLabConfigurationPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectGitLabConfigurationProperty mutation."
type SetProjectGitLabConfigurationPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectMessagePropertyById mutation."
type SetProjectMessagePropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectMessageProperty mutation."
type SetProjectMessagePropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectMetaInfoPropertyById mutation."
type SetProjectMetaInfoPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectMetaInfoProperty mutation."
type SetProjectMetaInfoPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectPropertyById mutation."
type SetProjectPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectProperty mutation."
type SetProjectPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectSonarQubePropertyById mutation."
type SetProjectSonarQubePropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectSonarQubeProperty mutation."
type SetProjectSonarQubePropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectStalePropertyById mutation."
type SetProjectStalePropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setProjectStaleProperty mutation."
type SetProjectStalePropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Project updated"
    project: Project
}

"Output type for the setPromotionLevelAutoPromotionPropertyById mutation."
type SetPromotionLevelAutoPromotionPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion level updated"
    promotionLevel: PromotionLevel
}

"Output type for the setPromotionLevelAutoPromotionProperty mutation."
type SetPromotionLevelAutoPromotionPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion level updated"
    promotionLevel: PromotionLevel
}

"Output type for the setPromotionLevelMessagePropertyById mutation."
type SetPromotionLevelMessagePropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion level updated"
    promotionLevel: PromotionLevel
}

"Output type for the setPromotionLevelMessageProperty mutation."
type SetPromotionLevelMessagePropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion level updated"
    promotionLevel: PromotionLevel
}

"Output type for the setPromotionLevelMetaInfoPropertyById mutation."
type SetPromotionLevelMetaInfoPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion level updated"
    promotionLevel: PromotionLevel
}

"Output type for the setPromotionLevelMetaInfoProperty mutation."
type SetPromotionLevelMetaInfoPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion level updated"
    promotionLevel: PromotionLevel
}

"Output type for the setPromotionLevelPropertyById mutation."
type SetPromotionLevelPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion level updated"
    promotionLevel: PromotionLevel
}

"Output type for the setPromotionLevelProperty mutation."
type SetPromotionLevelPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion level updated"
    promotionLevel: PromotionLevel
}

"Output type for the setPromotionRunMessagePropertyById mutation."
type SetPromotionRunMessagePropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion run updated"
    promotionRun: PromotionRun
}

"Output type for the setPromotionRunMessageProperty mutation."
type SetPromotionRunMessagePropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion run updated"
    promotionRun: PromotionRun
}

"Output type for the setPromotionRunMetaInfoPropertyById mutation."
type SetPromotionRunMetaInfoPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion run updated"
    promotionRun: PromotionRun
}

"Output type for the setPromotionRunMetaInfoProperty mutation."
type SetPromotionRunMetaInfoPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion run updated"
    promotionRun: PromotionRun
}

"Output type for the setPromotionRunPropertyById mutation."
type SetPromotionRunPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion run updated"
    promotionRun: PromotionRun
}

"Output type for the setPromotionRunProperty mutation."
type SetPromotionRunPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Promotion run updated"
    promotionRun: PromotionRun
}

"Output type for the setValidationRunMessagePropertyById mutation."
type SetValidationRunMessagePropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation run updated"
    validationRun: ValidationRun
}

"Output type for the setValidationRunMessageProperty mutation."
type SetValidationRunMessagePropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation run updated"
    validationRun: ValidationRun
}

"Output type for the setValidationRunMetaInfoPropertyById mutation."
type SetValidationRunMetaInfoPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation run updated"
    validationRun: ValidationRun
}

"Output type for the setValidationRunMetaInfoProperty mutation."
type SetValidationRunMetaInfoPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation run updated"
    validationRun: ValidationRun
}

"Output type for the setValidationRunPropertyById mutation."
type SetValidationRunPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation run updated"
    validationRun: ValidationRun
}

"Output type for the setValidationRunProperty mutation."
type SetValidationRunPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation run updated"
    validationRun: ValidationRun
}

"Output type for the setValidationStampMessagePropertyById mutation."
type SetValidationStampMessagePropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation stamp updated"
    validationStamp: ValidationStamp
}

"Output type for the setValidationStampMessageProperty mutation."
type SetValidationStampMessagePropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation stamp updated"
    validationStamp: ValidationStamp
}

"Output type for the setValidationStampMetaInfoPropertyById mutation."
type SetValidationStampMetaInfoPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation stamp updated"
    validationStamp: ValidationStamp
}

"Output type for the setValidationStampMetaInfoProperty mutation."
type SetValidationStampMetaInfoPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation stamp updated"
    validationStamp: ValidationStamp
}

"Output type for the setValidationStampPropertyById mutation."
type SetValidationStampPropertyByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation stamp updated"
    validationStamp: ValidationStamp
}

"Output type for the setValidationStampProperty mutation."
type SetValidationStampPropertyPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation stamp updated"
    validationStamp: ValidationStamp
}

"Ontrack settings"
type Settings {
    "Home page settings"
    homePage: HomePageSettingsType!
    "List of all settings and their values"
    list: [SettingsEntry!]!
    "Getting some settings using their ID"
    settingsById(
        "ID of the settings to get"
        id: String!
    ): SettingsEntry
}

"SettingsEntry"
type SettingsEntry {
    "id field"
    id: String!
    "title field"
    title: String!
    "values field"
    values: JSON!
}

"Output type for the setupCHMLValidationStamp mutation."
type SetupCHMLValidationStampPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created or updated validation stamp"
    validationStamp: ValidationStamp
}

"Output type for the setupMetricsValidationStamp mutation."
type SetupMetricsValidationStampPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created or updated validation stamp"
    validationStamp: ValidationStamp
}

"Output type for the setupPercentageValidationStamp mutation."
type SetupPercentageValidationStampPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created or updated validation stamp"
    validationStamp: ValidationStamp
}

"Output type for the setupPromotionLevel mutation."
type SetupPromotionLevelPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created or updated promotion level"
    promotionLevel: PromotionLevel
}

"Output type for the setupTestSummaryValidationStamp mutation."
type SetupTestSummaryValidationStampPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created or updated validation stamp"
    validationStamp: ValidationStamp
}

"Output type for the setupValidationStamp mutation."
type SetupValidationStampPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created or updated validation stamp"
    validationStamp: ValidationStamp
}

"Output type for the shareBuildFilter mutation."
type ShareBuildFilterPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

type ShareDashboardPayload implements PayloadInterface {
    "Shared dashboard"
    dashboard: Dashboard
    "List of errors"
    errors: [PayloadUserError]
}

"Output type for the shareSCMFileChangeFilter mutation."
type ShareSCMFileChangeFilterPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

type Signature {
    "ISO timestamp"
    time: String
    "User name"
    user: String
}

"Deployment slot into an environment"
type Slot implements Authorizable {
    "Authorizations for this context"
    authorizations: [Authorization!]!
    "Current pipeline active in the slot"
    currentPipeline: SlotPipeline
    "description field"
    description: String
    "Last eligible build for this slot"
    eligibleBuild: Build
    "environment field"
    environment: Environment!
    "id field"
    id: String!
    "project field"
    project: Project!
    "qualifier field"
    qualifier: String!
}

"Holds a list of slots"
type SlotList {
    "Holds a list of slots"
    slots: [Slot!]!
}

"Pipeline for a slot"
type SlotPipeline {
    "build field"
    build: Build!
    "Deployment status for the pipeline"
    deploymentStatus: SlotPipelineDeploymentStatus
    "end field"
    end: LocalDateTime
    "id field"
    id: String!
    "number field"
    number: Int
    "slot field"
    slot: Slot!
    "start field"
    start: LocalDateTime!
    "status field"
    status: SlotPipelineStatus!
}

"Stored state for an admission rule in a pipeline"
type SlotPipelineAdmissionRuleStatus {
    "data field"
    data: JSON
    "id field"
    id: String!
    "override field"
    override: Boolean
    "overrideMessage field"
    overrideMessage: String
    "timestamp field"
    timestamp: LocalDateTime!
    "user field"
    user: String!
}

"List of checks for admission for a pipeline"
type SlotPipelineDeploymentCheck {
    "check field"
    check: DeployableCheck!
    "override field"
    override: SlotPipelineAdmissionRuleStatus
    "ruleConfig field"
    ruleConfig: JSON
    "ruleData field"
    ruleData: JSON
    "ruleId field"
    ruleId: String!
}

"Status returned when finishing a deployment"
type SlotPipelineDeploymentFinishStatus {
    "deployed field"
    deployed: Boolean
    "message field"
    message: String!
}

"Status for the admission check of a pipeline"
type SlotPipelineDeploymentStatus {
    "checks field"
    checks: [SlotPipelineDeploymentCheck!]!
    "override field"
    override: Boolean
    "status field"
    status: Boolean
}

"Output type for the startSlotPipelineDeployment mutation."
type StartSlotPipelineDeploymentPayload implements Payload {
    "Pipeline deployment status"
    deploymentStatus: SlotPipelineDeploymentStatus
    "List of errors"
    errors: [UserError]
}

"Output type for the startSlotPipeline mutation."
type StartSlotPipelinePayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created pipeline"
    pipeline: SlotPipeline
}

"StepIngestionConfigValidation"
type StepIngestionConfigValidation {
    "Description for the validation stamp"
    description: String
    "Exact name of the job/step in the workflow"
    name: String!
    "Name of the validation stamp to use (instead of a generated one)"
    validation: String
    "Must we use the job name as a prefix to the validation stamp?"
    validationPrefix: Boolean
}

"Output type for the stopWorkflow mutation."
type StopWorkflowPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the subscribeBranchToEvents mutation."
type SubscribeBranchToEventsPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Saved subscription"
    subscription: EventSubscriptionPayload
}

"Output type for the subscribeBuildToEvents mutation."
type SubscribeBuildToEventsPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Saved subscription"
    subscription: EventSubscriptionPayload
}

"Output type for the subscribeProjectToEvents mutation."
type SubscribeProjectToEventsPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Saved subscription"
    subscription: EventSubscriptionPayload
}

"Output type for the subscribePromotionLevelToEvents mutation."
type SubscribePromotionLevelToEventsPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Saved subscription"
    subscription: EventSubscriptionPayload
}

"Output type for the subscribePromotionRunToEvents mutation."
type SubscribePromotionRunToEventsPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Saved subscription"
    subscription: EventSubscriptionPayload
}

"Output type for the subscribeToEvents mutation."
type SubscribeToEventsPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Saved subscription"
    subscription: EventSubscriptionPayload
}

"Output type for the subscribeValidationRunToEvents mutation."
type SubscribeValidationRunToEventsPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Saved subscription"
    subscription: EventSubscriptionPayload
}

"Output type for the subscribeValidationStampToEvents mutation."
type SubscribeValidationStampToEventsPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Saved subscription"
    subscription: EventSubscriptionPayload
}

"Definition of a renderer"
type TemplatingRenderer {
    "Technical ID for the renderer"
    id: String!
    "Display name for the renderer"
    name: String!
}

"Output type for the testConfiguration mutation."
type TestConfigurationPayload implements Payload {
    "Result of the test"
    connectionResult: ConnectionResult
    "List of errors"
    errors: [UserError]
}

"Output type for the testJenkinsConfiguration mutation."
type TestJenkinsConfigurationPayload implements Payload {
    "Result of the test"
    connectionResult: ConnectionResult
    "List of errors"
    errors: [UserError]
}

"Authentication token"
type Token {
    "Token creation date."
    creation: LocalDateTime
    "Date when the token was last used."
    lastUsed: LocalDateTime
    "Name of the token"
    name: String
    "scope field"
    scope: TokenScope!
    "Is this token managed?"
    transient: Boolean!
    "Validity flag, computed in regard to current time."
    valid: Boolean
    "Date until the end of validity."
    validUntil: LocalDateTime
    "Value of the token"
    value: String
}

"""

An `ActionLink` refers to a HTTP end point,
having an uri, a HTTP method (like `PUT`
or `POST`) and a type.
The  type identifies the type of action,
like "download", "form", "upload", etc.
"""
type UIActionLink {
    "Link description"
    description: String!
    "Is this end point enabled, according to authorizations and state."
    enabled: Boolean!
    "HTTP method to use"
    method: String!
    "End point URI"
    uri: String
}

"Output type for the unfavouriteBranch mutation."
type UnfavouriteBranchPayload implements Payload {
    "Updated branch"
    branch: Branch
    "List of errors"
    errors: [UserError]
}

"Output type for the unfavouriteProject mutation."
type UnfavouriteProjectPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Updated project"
    project: Project
}

"Output type for the unlockAccount mutation."
type UnlockAccountPayload implements Payload {
    "Updated account"
    account: Account
    "List of errors"
    errors: [UserError]
}

"Output type for the unshareSCMFileChangeFilter mutation."
type UnshareSCMFileChangeFilterPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the updateBuild mutation."
type UpdateBuildPayload implements Payload {
    "Updated build"
    build: Build
    "List of errors"
    errors: [UserError]
}

"Output type for the updateConfiguration mutation."
type UpdateConfigurationPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the updateJenkinsConfiguration mutation."
type UpdateJenkinsConfigurationPayload implements Payload {
    "List of errors"
    errors: [UserError]
}

"Output type for the updateProject mutation."
type UpdateProjectPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Updated project"
    project: Project
}

"Output type for the updatePromotionLevelById mutation."
type UpdatePromotionLevelByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Updated promotion level"
    promotionLevel: PromotionLevel
}

"Output type for the updateValidationStampById mutation."
type UpdateValidationStampByIdPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Updated validation stamp"
    validationStamp: ValidationStamp
}

"Output type for the updateValidationStampFilter mutation."
type UpdateValidationStampFilterPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Validation stamp filter having been updated"
    validationStampFilter: ValidationStampFilter
}

"Representation of the current user"
type User {
    "Account associated to the user"
    account: Account
    "Actions for a RootUser"
    actions: RootUserActions @deprecated(reason: "Will be removed in V5. User `userMenuActions` instead.")
}

"Representation of an error."
type UserError {
    "Programmatic code to be used by client. Usually the FQCN of the corresponding exception."
    exception: String!
    "Additional information about the location of this error."
    location: String
    "The error message"
    message: String!
}

"Item in the user menu"
type UserMenuAction {
    "Extension contributing this user menu item"
    extension: String!
    "ID of the group this item belongs to"
    groupId: String!
    "Unique ID for this user menu item in the given extension"
    id: String!
    "Display name for this user menu item"
    name: String!
}

"Group of user menu items"
type UserMenuGroup {
    "ID of the group"
    id: String!
    "Items in this group"
    items: [UserMenuAction!]!
    "Name of the group"
    name: String!
}

"Output type for the validateBuildByIdWithCHML mutation."
type ValidateBuildByIdWithCHMLPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created validation run"
    validationRun: ValidationRun
}

"Output type for the validateBuildByIdWithMetrics mutation."
type ValidateBuildByIdWithMetricsPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created validation run"
    validationRun: ValidationRun
}

"Output type for the validateBuildByIdWithPercentage mutation."
type ValidateBuildByIdWithPercentagePayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created validation run"
    validationRun: ValidationRun
}

"Output type for the validateBuildByIdWithTests mutation."
type ValidateBuildByIdWithTestsPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created validation run"
    validationRun: ValidationRun
}

"Output type for the validateBuildWithCHML mutation."
type ValidateBuildWithCHMLPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created validation run"
    validationRun: ValidationRun
}

"Output type for the validateBuildWithMetrics mutation."
type ValidateBuildWithMetricsPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created validation run"
    validationRun: ValidationRun
}

"Output type for the validateBuildWithPercentage mutation."
type ValidateBuildWithPercentagePayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created validation run"
    validationRun: ValidationRun
}

"Output type for the validateBuildWithTests mutation."
type ValidateBuildWithTestsPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Created validation run"
    validationRun: ValidationRun
}

"Output type for the validateJsonWorkflow mutation."
type ValidateJsonWorkflowPayload implements Payload {
    "List of errors"
    errors: [UserError]
    "Result of the validation"
    validation: WorkflowValidation
}

type Validation {
    "Associated validation runs"
    validationRuns(
        "Maximum number of validation runs"
        count: Int = 50
    ): [ValidationRun!]!
    "Associated validation stamp"
    validationStamp: ValidationStamp
}

"Configuration for the data type associated with a validation stamp"
type ValidationDataTypeConfig {
    "Configuration object"
    config: JSON
    "Descriptor for the validation data type"
    descriptor: ValidationDataTypeDescriptor
}

"Descriptor for a validation data type"
type ValidationDataTypeDescriptor {
    "Display name of the validation data type"
    displayName: String
    "Associated extension feature"
    feature: ExtensionFeatureDescription
    "ID (FQDN) of the validation data type"
    id: String
}

"Association between an issue and some validation runs."
type ValidationIssue {
    "Associated issue"
    issue: Issue
    "List of validation runs where this issue was reported"
    validationRuns: [ValidationRun!]!
}

type ValidationRun implements Authorizable & ProjectEntity {
    "Description with links."
    annotatedDescription: String
    "Authorizations for this context"
    authorizations: [Authorization!]!
    "Associated build"
    build: Build!
    creation: Signature
    "Data associated with the validation run"
    data: ValidationRunData
    "List of decorations"
    decorations(
        "Fully qualified name of the decoration type"
        type: String
    ): [Decoration!]!
    description: String
    id: Int!
    "List of information components attached to this entity"
    information: [EntityInformation!]!
    "Link to a Jenkins Build"
    jenkinsBuildProperty: Property
    "Last validation status for this run"
    lastStatus: ValidationRunStatus!
    "List of links."
    linkProperty: Property
    "Links"
    links: ValidationRunLinks @deprecated(reason: "Use the `actions` field instead.")
    "Associates an arbitrary message (and its type) to an entity. Will be displayed as a decorator in the UI."
    messageProperty: Property
    "List of meta information properties"
    metaInfoProperty: Property
    name: String
    "List of properties"
    properties(
        "Keeps properties having a value"
        hasValue: Boolean = false,
        "Fully qualified name of the property type"
        type: String
    ): [Property!]!
    "Run info associated with this validation run"
    runInfo: RunInfo
    "Run order"
    runOrder: Int
    "List of actions available for this entity"
    userMenuActions: [UserMenuAction!]!
    "Link to the GitHub Workflow Job which created this validation run."
    validationRunGitHubWorkflowJobProperty: Property
    "List of validation statuses"
    validationRunStatuses(
        "True to get only the last status only."
        lastOnly: Boolean
    ): [ValidationRunStatus!]!
    "Associated validation stamp"
    validationStamp: ValidationStamp!
}

"Data associated with a validation run"
type ValidationRunData {
    "Data object"
    data: JSON
    "Descriptor for the validation data type"
    descriptor: ValidationDataTypeDescriptor
}

"ValidationRun links"
type ValidationRunLinks {
    _decorations: String
    _extra: String
    _image: String
    _page: String
    _properties: String
    _runInfo: String
    _self: String
    _validationRunStatusChange: String
    _validationStampLink: String
}

type ValidationRunPaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [ValidationRun!]!
}

type ValidationRunStatus implements Authorizable {
    "Description with links."
    annotatedDescription: String
    "Authorizations for this context"
    authorizations: [Authorization!]!
    creation: Signature
    description: String
    id: Int!
    "List of issues attached to this status"
    issues(
        "Filtering the issues on their status"
        status: String
    ): [Issue!]!
    "Links"
    links: ValidationRunStatusLinks @deprecated(reason: "Use the `actions` field instead.")
    "Status ID"
    statusID: ValidationRunStatusID
}

type ValidationRunStatusID {
    "List of following statuses"
    followingStatuses: [String!]!
    "id field"
    id: String!
    "name field"
    name: String!
    "passed field"
    passed: Boolean
    "root field"
    root: Boolean
}

"ValidationRunStatus links"
type ValidationRunStatusLinks {
    _comment: String
}

type ValidationStamp implements Authorizable & ProjectEntity {
    "Link to the image"
    _image: String
    "Description with links."
    annotatedDescription: String
    "Authorizations for this context"
    authorizations: [Authorization!]!
    "Reference to branch"
    branch: Branch
    "List of charts exposed by the validation stamp"
    charts: [ChartDefinition!]!
    creation: Signature
    "Data definition associated with the validation stamp"
    dataType: ValidationDataTypeConfig
    "List of decorations"
    decorations(
        "Fully qualified name of the decoration type"
        type: String
    ): [Decoration!]!
    description: String
    id: Int!
    "Flag to indicate if an image is associated"
    image: Boolean
    "List of information components attached to this entity"
    information: [EntityInformation!]!
    "Link to a Jenkins Job"
    jenkinsJobProperty: Property
    "List of links."
    linkProperty: Property
    "Links"
    links: ValidationStampLinks @deprecated(reason: "Use the `actions` field instead.")
    "Associates an arbitrary message (and its type) to an entity. Will be displayed as a decorator in the UI."
    messageProperty: Property
    "List of meta information properties"
    metaInfoProperty: Property
    name: String
    "List of properties"
    properties(
        "Keeps properties having a value"
        hasValue: Boolean = false,
        "Fully qualified name of the property type"
        type: String
    ): [Property!]!
    "List of actions available for this entity"
    userMenuActions: [UserMenuAction!]!
    "List of runs for this validation stamp"
    validationRuns(
        "Maximum number of validation runs"
        count: Int = 50
    ): [ValidationRun!]!
    "Paginated list of validation runs"
    validationRunsPaginated(
        "Validation runs for this build only"
        buildId: Int,
        "Offset for the page"
        offset: Int = 0,
        "Allows to filter on the last status of the run"
        passed: Boolean,
        "Size of the page"
        size: Int = 20
    ): ValidationRunPaginated
}

"Validation stamp filter"
type ValidationStampFilter implements Authorizable {
    "Authorizations for this context"
    authorizations: [Authorization!]!
    "ID of the filter"
    id: Int
    "Links"
    links: ValidationStampFilterLinks @deprecated(reason: "Use the `actions` field instead.")
    "Name of the filter"
    name: String!
    "Scope of the filter"
    scope: ValidationStampFilterScope!
    "List of validation stamps"
    vsNames: [String!]!
}

"ValidationStampFilter links"
type ValidationStampFilterLinks {
    _delete: String
    _shareAtGlobal: String
    _shareAtProject: String
    _update: String
}

"ValidationStamp links"
type ValidationStampLinks {
    _actions: String
    _branch: String
    _bulkUpdate: String
    _decorations: String
    _delete: String
    _events: String
    _image: String
    _page: String
    _project: String
    _properties: String
    _runs: String
    _self: String
    _update: String
}

"Version information"
type VersionInfo {
    "Git branch"
    branch: String!
    "Git commit"
    commit: String!
    "Creation date"
    date: LocalDateTime @deprecated(reason: "Date field will be removed in V5")
    "Display version"
    display: String!
    "Full version"
    full: String!
}

"Webhook registration"
type Webhook {
    "Webhook authentication"
    authenticationType: String
    "Webhook enabled or not"
    enabled: Boolean
    "Exchanges for this webhook"
    exchanges(
        "Filter for the exchanges"
        filter: WebhookExchangeFilter,
        "Offset for the page"
        offset: Int = 0,
        "Size of the page"
        size: Int = 20
    ): WebhookExchangePaginated
    "Webhook unique name"
    name: String!
    "Webhook execution timeout (in seconds)"
    timeoutSeconds: Int
    "Webhook endpoint"
    url: String!
}

"Webhook exchange"
type WebhookExchange {
    "Request sent to the webhook"
    request: WebhookRequest!
    "Response received from the webhook"
    response: WebhookResponse
    "Error raised during the exchange"
    stack: String
    "Unique ID for the exchange"
    uuid: UUID!
    "Webhook name"
    webhook: String!
}

type WebhookExchangePaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [WebhookExchange!]!
}

"Request sent to the webhook"
type WebhookRequest {
    "Payload sent to the webhook"
    payload: String!
    "Request timestamp"
    timestamp: LocalDateTime!
    "Type of payload"
    type: String!
}

"Response received from the webhook"
type WebhookResponse {
    "Response HTTP status code"
    code: Int!
    "Response payload"
    payload: String!
    "Response timestamp"
    timestamp: LocalDateTime!
}

type Widget {
    defaultConfig: JSON!
    description: String!
    key: String!
    name: String!
    preferredHeight: Int!
}

type WidgetInstance {
    config: JSON!
    key: String!
    layout: WidgetLayout!
    uuid: String!
}

"""

=================================================================================
Dashboards
=================================================================================
"""
type WidgetLayout {
    h: Int!
    w: Int!
    x: Int!
    y: Int!
}

"Workflow"
type Workflow {
    "Display name for the workflow"
    name: String!
    "List of nodes in the workflow"
    nodes: [WorkflowNode!]!
}

"Workflow context, data which is passed to the workflow initially"
type WorkflowContext {
    "data field"
    data: [WorkflowContextData!]!
}

"Data in a workflow context"
type WorkflowContextData {
    "key field"
    key: String!
    "value field"
    value: JSON
}

"Running workflow instance"
type WorkflowInstance {
    "context field"
    context: WorkflowContext!
    "durationMs field"
    durationMs: Int
    "endTime field"
    endTime: LocalDateTime
    "Is the workflow finished?"
    finished: Boolean!
    "id field"
    id: String!
    "List of node statuses in the workflow"
    nodesExecutions: [WorkflowInstanceNode!]!
    "startTime field"
    startTime: LocalDateTime
    "status field"
    status: WorkflowInstanceStatus!
    "timestamp field"
    timestamp: LocalDateTime!
    "workflow field"
    workflow: Workflow!
}

"Status of a node execution in a workflow"
type WorkflowInstanceNode {
    "durationMs field"
    durationMs: Int
    "endTime field"
    endTime: LocalDateTime
    "error field"
    error: String
    "id field"
    id: String!
    "output field"
    output: JSON
    "startTime field"
    startTime: LocalDateTime
    "status field"
    status: WorkflowInstanceNodeStatus!
}

type WorkflowInstancePaginated {
    "Information about the current page"
    pageInfo: PageInfo
    "Items in the current page"
    pageItems: [WorkflowInstance!]!
}

"Workflow node"
type WorkflowNode {
    "Raw data associated with the node, to be used by the node executor."
    data: JSON
    "Description of the node in its workflow."
    description: String
    "ID of the executor to use"
    executorId: String!
    "Unique ID of the node in its workflow."
    id: String!
    "List of the IDs of the parents for this node"
    parents: [WorkflowParentNode!]!
    "Timeout in seconds (5 minutes by default)"
    timeout: Int
}

"Workflow node executor"
type WorkflowNodeExecutor {
    "displayName field"
    displayName: String!
    "id field"
    id: String!
}

"Workflow parent node"
type WorkflowParentNode {
    "ID of the parent node"
    id: String!
}

"Workflow validation"
type WorkflowValidation {
    "error field"
    error: Boolean
    "errors field"
    errors: [String!]!
}

"List of ways the auto approval is managed."
enum AutoApprovalMode {
    CLIENT
    SCM
}

"State an auto versioning audit entry can be in"
enum AutoVersioningAuditState {
    CREATED
    ERROR
    POST_PROCESSING_END
    POST_PROCESSING_START
    PROCESSING_ABORTED
    PROCESSING_CANCELLED
    PROCESSING_CREATING_BRANCH
    PROCESSING_START
    PROCESSING_UPDATING_FILE
    PR_APPROVED
    PR_CREATED
    PR_CREATING
    PR_MERGED
    PR_TIMEOUT
    RECEIVED
}

"List of directions when getting auto versioning information between two builds."
enum AutoVersioningDirection {
    DOWN
    UP
}

"Scope for notifications in auto versioning."
enum AutoVersioningNotificationScope {
    ALL
    ERROR
    PR_TIMEOUT
    SUCCESS
}

"Direction for dependencies"
enum BranchLinksDirection {
    USED_BY
    USING
}

"CHML values"
enum CHML {
    CRITICAL
    HIGH
    LOW
    MEDIUM
}

"List of supported attribute types for configurable indicators"
enum ConfigurableIndicatorAttributeType {
    INT
    REGEX
    REQUIRED
}

"Type of result returned when checking a configuration"
enum ConnectionResultType {
    ERROR
    OK
}

enum DashboardContextUserScope {
    BUILT_IN
    PRIVATE
    SHARED
}

"State a hook request can be in"
enum HookRecordState {
    DENIED
    DISABLED
    ERROR
    RECEIVED
    SUCCESS
    UNDEFINED
}

"Types of responses returned by hooks."
enum HookResponseType {
    IGNORED
    PROCESSED
    PROCESSING
}

"Defines the way a computed name must be normalized before it can be used as a validation stamp name."
enum IngestionConfigVSNameNormalization {
    DEFAULT
    LEGACY
}

"Outcome of the processing of the payload"
enum IngestionEventProcessingResult {
    IGNORED
    PROCESSED
}

"Status of the processing of the payload"
enum IngestionHookPayloadStatus {
    COMPLETED
    ERRORED
    PROCESSING
    SCHEDULED
}

"Global state of a job"
enum JobState {
    DISABLED
    IDLE
    INVALID
    PAUSED
    RUNNING
}

enum LicenseExpiration {
    ALMOST
    EXPIRED
    OK
}

"List of types of messages"
enum MessageType {
    ERROR
    INFO
    SUCCESS
    WARNING
}

"Type of result for a notification"
enum NotificationResultType {
    ASYNC
    DISABLED
    ERROR
    INVALID_CONFIGURATION
    NOT_CONFIGURED
    OK
    ONGOING
    TIMEOUT
}

"Project entity type"
enum ProjectEntityType {
    BRANCH
    BUILD
    PROJECT
    PROMOTION_LEVEL
    PROMOTION_RUN
    VALIDATION_RUN
    VALIDATION_STAMP
}

"Result of a dispaching on a queue"
enum QueueDispatchResultType {
    IGNORED
    PROCESSED
    PROCESSING
}

"State of a message in a queue"
enum QueueRecordState {
    CANCELLED
    COMPLETED
    ERRORED
    PARSED
    PROCESSING
    RECEIVED
    ROUTING_READY
    SENT
    STARTED
}

"Type of change on a file."
enum SCMChangeLogFileChangeType {
    ADDED
    COPIED
    DELETED
    MODIFIED
    RENAMED
    UNDEFINED
}

"List of pipelines for a status"
enum SlotPipelineStatus {
    CANCELLED
    DEPLOYED
    DEPLOYING
    ERROR
    ONGOING
}

"Class of tokens"
enum TokenScope {
    NEXT_UI
    USER
}

"Defines how validation runs should be sorted"
enum ValidationRunSortingMode {
    ID
    NAME
    RUN_TIME
}

"ValidationStampFilterScope"
enum ValidationStampFilterScope {
    BRANCH
    GLOBAL
    PROJECT
}

"Status of a node in a workflow"
enum WorkflowInstanceNodeStatus {
    ERROR
    IDLE
    STARTED
    STOPPED
    SUCCESS
}

"Status of a running workflow"
enum WorkflowInstanceStatus {
    ERROR
    RUNNING
    STARTED
    STOPPED
    SUCCESS
}

"JSON node"
scalar JSON

"Local Date Time"
scalar LocalDateTime

"Long signed integer"
scalar Long

"UUID"
scalar UUID

"Filter when querying auto versioning processing orders"
input AutoVersioningAuditQueryFilter {
    "Name of the target branch"
    branch: String
    "Name of the target project"
    project: String
    "Actual queue the order was posted to"
    queue: String
    "Routing key used for the queuing"
    routing: String
    "Running state of the auto versioning processing order"
    running: Boolean
    "Name of the source project of the auto versioning processing order"
    source: String
    "Most recent state of the auto versioning processing order"
    state: String
    "UUID of the auto versioning processing order"
    uuid: String
    "Target version of the auto versioning processing order"
    version: String
}

input AutoVersioningNotificationInput {
    "channel field"
    channel: String!
    "config field"
    config: JSON!
    "Optional notification template used to override the default text"
    notificationTemplate: String
    "scope field"
    scope: [AutoVersioningNotificationScope!]!
}

input AutoVersioningSourceConfigInput {
    "Additional paths to change"
    additionalPaths: [AutoVersioningSourceConfigPathInput!]
    "Check if the PR must be approved automatically or not (`true` by default)"
    autoApproval: Boolean
    "Auto approval mode"
    autoApprovalMode: AutoApprovalMode
    "Validation stamp to create on the source build (optional)"
    backValidation: String
    "Build link creation. True by default."
    buildLinkCreation: Boolean
    "List of notifications subscriptions to setup for this auto versioning"
    notifications: [AutoVersioningNotificationInput!]
    "Type of post processing to launch after the version has been updated"
    postProcessing: String
    "Configuration of the post processing"
    postProcessingConfig: JSON
    "Template for the body of the pull request (optional)"
    prBodyTemplate: String
    "Template format for the body of the pull request (plain by default, html, markdown as possible values)"
    prBodyTemplateFormat: String
    "Template for the title of the pull request (optional)"
    prTitleTemplate: String
    "Qualifier for the build link to create (when links are created)"
    qualifier: String
    "List of reviewers to always set on the pull request created by the auto versioning"
    reviewers: [String!]
    "Branches to watch using a regular expression"
    sourceBranch: String!
    "Project to watch"
    sourceProject: String!
    "Promotion to watch"
    sourcePromotion: String!
    "Comma-separated list of file to update with the new version"
    targetPath: String!
    "Optional replacement for the regex, using only a property name"
    targetProperty: String
    "Optional regex to use on the targetProperty value"
    targetPropertyRegex: String
    "When targetProperty is defined, defines the type of property (defaults to Java properties file, but could be NPM, etc.)"
    targetPropertyType: String
    "Regex to use in the target file to identify the line to replace with the new version. The first matching group must be the version."
    targetRegex: String
    "Prefix to use for the upgrade branch in Git, defaults to `feature/auto-upgrade-<project>-<version>-<branch>`"
    upgradeBranchPattern: String
    "Validation stamp to create on auto versioning (optional)"
    validationStamp: String
    "Source of the version for the build. By default, uses the build label is the source project is configured so, or the build name itself. This allows the customization of this behavior."
    versionSource: String
}

input AutoVersioningSourceConfigPathInput {
    "Comma-separated list of file to update with the new version"
    path: String!
    "Optional replacement for the regex, using only a property name"
    property: String
    "Optional regex to use on the property value"
    propertyRegex: String
    "When property is defined, defines the type of property (defaults to Java properties file, but could be NPM, etc.)"
    propertyType: String
    "Regex to use in the target file to identify the line to replace with the new version. The first matching group must be the version."
    regex: String
    "Source of the version for the build. By default, uses the build label is the source project is configured so, or the build name itself. This allows the customization of this behavior."
    versionSource: String
}

"BuildSearchForm"
input BuildSearchForm {
    "Regular expression to match against the branch name."
    branchName: String
    "When `buildName` is set, considers an exact match on the build name."
    buildExactMatch: Boolean
    "Regular expression to match against the build name, unless `buildExactMatch` is set to `true`."
    buildName: String
    "`project:build` expression, matches against builds being linked from the build to match."
    linkedFrom: String
    "`project:build` expression, matches against builds being linked to the build to match."
    linkedTo: String
    "Maximum number of builds to return."
    maximumCount: Int
    "Matches a build having at least this promotion."
    promotionName: String
    "Matches a build having this property."
    property: String
    "When the property is set, matches against the property value."
    propertyValue: String
    "Matches a build having at least this validation with PASSED as a status."
    validationStampName: String
}

"Input type for the bulkUpdatePromotionLevelById mutation."
input BulkUpdatePromotionLevelByIdInput {
    "Promotion level ID"
    id: Int!
}

"Input type for the bulkUpdateValidationStampById mutation."
input BulkUpdateValidationStampByIdInput {
    "Validation stamp ID"
    id: Int!
}

"CHML level, associated a given CHML type and a value"
input CHMLLevel {
    "Type of level to count"
    level: CHML!
    "Count to reach to raise this level"
    value: Int!
}

"""

=================================================================================
User change password
=================================================================================
"""
input ChangePasswordInput {
    newPassword: String!
    oldPassword: String!
}

"Input type for the changeValidationRunStatusComment mutation."
input ChangeValidationRunStatusCommentInput {
    "comment field"
    comment: String
    "validationRunStatusId field"
    validationRunStatusId: Int!
}

"Input type for the changeValidationRunStatus mutation."
input ChangeValidationRunStatusInput {
    "Optional validation run status description"
    description: String
    "Validation run ID"
    validationRunId: Int!
    "Validation run status ID"
    validationRunStatusId: String!
}

"Input type for the checkAutoVersioning mutation."
input CheckAutoVersioningInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
}

"Input type for the createBranch mutation."
input CreateBranchInput {
    "Branch description"
    description: String
    "Branch state, null for not disabled"
    disabled: Boolean
    "Branch name"
    name: String!
    "Project ID (required unless project name is provided)"
    projectId: Int
    "Project Name (required unless project ID is provided)"
    projectName: String
}

"Input type for the createBranchOrGet mutation."
input CreateBranchOrGetInput {
    "Branch description"
    description: String
    "Branch state, null for not disabled"
    disabled: Boolean
    "Branch name"
    name: String!
    "Project ID (required unless project name is provided)"
    projectId: Int
    "Project Name (required unless project ID is provided)"
    projectName: String
}

"Input type for the createBuild mutation."
input CreateBuildInput {
    "Branch ID (required unless project & branch names are provided)"
    branchId: Int
    "Branch name (required together with project name, unless branch ID is provided)"
    branchName: String
    "Build description"
    description: String
    "Build name"
    name: String!
    "Project ID (required unless project name is provided)"
    projectId: Int
    "Project Name (required unless project ID is provided)"
    projectName: String
    "Optional run info"
    runInfo: RunInfoInput
}

"Input type for the createBuildOrGet mutation."
input CreateBuildOrGetInput {
    "Branch ID (required unless project & branch names are provided)"
    branchId: Int
    "Branch name (required together with project name, unless branch ID is provided)"
    branchName: String
    "Build description"
    description: String
    "Build name"
    name: String!
    "Project ID (required unless project name is provided)"
    projectId: Int
    "Project Name (required unless project ID is provided)"
    projectName: String
    "Optional run info"
    runInfo: RunInfoInput
}

"Input type for the createBuiltInAccount mutation."
input CreateBuiltInAccountInput {
    "email field"
    email: String!
    "fullName field"
    fullName: String!
    "name field"
    name: String!
    "password field"
    password: String!
}

"Input type for the createConfiguration mutation."
input CreateConfigurationInput {
    "data field"
    data: JSON!
    "name field"
    name: String!
    "type field"
    type: String!
}

"Input type for the createEnvironment mutation."
input CreateEnvironmentInput {
    "description field"
    description: String!
    "name field"
    name: String!
    "order field"
    order: Int!
    "tags field"
    tags: [String!]!
}

"Input type for the createGitHubConfiguration mutation."
input CreateGitHubConfigurationInput {
    "ID of the GitHub App to use for authentication"
    appId: String
    "Account name of the GitHub App installation (used when more than 1 installation for the app)"
    appInstallationAccountName: String
    "GitHub App private key"
    appPrivateKey: String
    "Token for an account used to approve pull requests for auto approval processes"
    autoMergeToken: String
    "Name of this configuration"
    name: String!
    "Personal Access Token"
    oauth2Token: String
    "Password for authentication"
    password: String
    "GitHub server URL. Null will be replaced by https://github.com"
    url: String
    "User name for authentication"
    user: String
}

"Input type for the createJenkinsConfiguration mutation."
input CreateJenkinsConfigurationInput {
    "name field"
    name: String!
    "password field"
    password: String
    "url field"
    url: String!
    "user field"
    user: String
}

"Input type for the createProject mutation."
input CreateProjectInput {
    "Project description"
    description: String
    "Project state, null for not disabled"
    disabled: Boolean
    "Project name"
    name: String!
}

"Input type for the createProjectOrGet mutation."
input CreateProjectOrGetInput {
    "Project description"
    description: String
    "Project state, null for not disabled"
    disabled: Boolean
    "Project name"
    name: String!
}

"Input type for the createPromotionLevelById mutation."
input CreatePromotionLevelByIdInput {
    "Branch ID"
    branchId: Int!
    "Promotion level description"
    description: String!
    "Promotion level name"
    name: String!
}

"Input type for the createPromotionRunById mutation."
input CreatePromotionRunByIdInput {
    "Build ID"
    buildId: Int!
    "Promotion date/time"
    dateTime: LocalDateTime
    "Promotion description"
    description: String
    "Promotion name"
    promotion: String!
}

"Input type for the createPromotionRun mutation."
input CreatePromotionRunInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Promotion date/time"
    dateTime: LocalDateTime
    "Promotion description"
    description: String
    "Project name"
    project: String!
    "Promotion name"
    promotion: String!
}

"Input type for the createSlots mutation."
input CreateSlotsInput {
    "description field"
    description: String
    "environmentIds field"
    environmentIds: [String!]!
    "projectId field"
    projectId: Int!
    "qualifier field"
    qualifier: String
}

"Input type for the createValidationRunById mutation."
input CreateValidationRunByIdInput {
    "Build ID"
    buildId: Int!
    "Data to associated with the validation"
    data: JSON
    "Type of the data to associated with the validation"
    dataTypeId: String
    "Validation description"
    description: String
    "Run info"
    runInfo: RunInfoInput
    "Validation run status"
    validationRunStatus: String
    "Validation stamp name"
    validationStamp: String!
}

"Input type for the createValidationRun mutation."
input CreateValidationRunInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Data to associated with the validation"
    data: JSON
    "Type of the data to associated with the validation"
    dataTypeId: String
    "Validation description"
    description: String
    "Project name"
    project: String!
    "Run info"
    runInfo: RunInfoInput
    "Validation run status"
    validationRunStatus: String
    "Validation stamp name"
    validationStamp: String!
}

"Input type for the createValidationStampById mutation."
input CreateValidationStampByIdInput {
    "Branch ID"
    branchId: Int!
    "FQCN of the data type"
    dataType: String
    "Configuration of the data type"
    dataTypeConfig: JSON
    "Validation stamp description"
    description: String!
    "Validation stamp name"
    name: String!
}

"Input type for the createValidationStampFilter mutation."
input CreateValidationStampFilterInput {
    "Name of the validation stamp filter"
    name: String!
}

"Input type for the createWebhook mutation."
input CreateWebhookInput {
    "authenticationConfig field"
    authenticationConfig: JSON!
    "authenticationType field"
    authenticationType: String!
    "enabled field"
    enabled: Boolean!
    "name field"
    name: String!
    "timeoutSeconds field"
    timeoutSeconds: Long!
    "url field"
    url: String!
}

"Input type for the deleteAutoVersioningConfig mutation."
input DeleteAutoVersioningConfigInput {
    "ID of the branch to clean"
    branchId: Int!
}

"Input type for the deleteBranchGitConfigPropertyById mutation."
input DeleteBranchGitConfigPropertyByIdInput {
    "ID of the branch"
    id: Int!
}

"Input type for the deleteBranchGitConfigProperty mutation."
input DeleteBranchGitConfigPropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
}

"Input type for the deleteBranchMessagePropertyById mutation."
input DeleteBranchMessagePropertyByIdInput {
    "ID of the branch"
    id: Int!
}

"Input type for the deleteBranchMessageProperty mutation."
input DeleteBranchMessagePropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
}

"Input type for the deleteBranchMetaInfoPropertyById mutation."
input DeleteBranchMetaInfoPropertyByIdInput {
    "ID of the branch"
    id: Int!
}

"Input type for the deleteBranchMetaInfoProperty mutation."
input DeleteBranchMetaInfoPropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
}

"Input type for the deleteBranchReleaseValidationPropertyById mutation."
input DeleteBranchReleaseValidationPropertyByIdInput {
    "ID of the branch"
    id: Int!
}

"Input type for the deleteBranchReleaseValidationProperty mutation."
input DeleteBranchReleaseValidationPropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
}

"Input type for the deleteBuildFilter mutation."
input DeleteBuildFilterInput {
    "branchId field"
    branchId: Int!
    "name field"
    name: String!
}

"Input type for the deleteBuildGitCommitPropertyById mutation."
input DeleteBuildGitCommitPropertyByIdInput {
    "ID of the build"
    id: Int!
}

"Input type for the deleteBuildGitCommitProperty mutation."
input DeleteBuildGitCommitPropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
}

"Input type for the deleteBuildMessagePropertyById mutation."
input DeleteBuildMessagePropertyByIdInput {
    "ID of the build"
    id: Int!
}

"Input type for the deleteBuildMessageProperty mutation."
input DeleteBuildMessagePropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
}

"Input type for the deleteBuildMetaInfoPropertyById mutation."
input DeleteBuildMetaInfoPropertyByIdInput {
    "ID of the build"
    id: Int!
}

"Input type for the deleteBuildMetaInfoProperty mutation."
input DeleteBuildMetaInfoPropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
}

"Input type for the deleteBuildReleasePropertyById mutation."
input DeleteBuildReleasePropertyByIdInput {
    "ID of the build"
    id: Int!
}

"Input type for the deleteBuildReleaseProperty mutation."
input DeleteBuildReleasePropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
}

"Input type for the deleteConfiguration mutation."
input DeleteConfigurationInput {
    "name field"
    name: String!
    "type field"
    type: String!
}

input DeleteDashboardInput {
    "UUID of the dashboard to delete"
    uuid: String!
}

"Input type for the deleteGenericProperty mutation."
input DeleteGenericPropertyInput {
    "entityId field"
    entityId: Int!
    "entityType field"
    entityType: ProjectEntityType!
    "type field"
    type: String!
}

"Input type for the deleteJenkinsConfiguration mutation."
input DeleteJenkinsConfigurationInput {
    "name field"
    name: String!
}

"Input type for the deleteNotificationRecords mutation."
input DeleteNotificationRecordsInput {
    "Retention period, in seconds. 0 or null for all records."
    retentionSeconds: Long
}

"Input type for the deleteProjectAutoPromotionLevelPropertyById mutation."
input DeleteProjectAutoPromotionLevelPropertyByIdInput {
    "ID of the project"
    id: Int!
}

"Input type for the deleteProjectAutoPromotionLevelProperty mutation."
input DeleteProjectAutoPromotionLevelPropertyInput {
    "Project name"
    project: String!
}

"Input type for the deleteProjectAutoValidationStampPropertyById mutation."
input DeleteProjectAutoValidationStampPropertyByIdInput {
    "ID of the project"
    id: Int!
}

"Input type for the deleteProjectAutoValidationStampProperty mutation."
input DeleteProjectAutoValidationStampPropertyInput {
    "Project name"
    project: String!
}

"Input type for the deleteProjectAutoVersioningProjectPropertyById mutation."
input DeleteProjectAutoVersioningProjectPropertyByIdInput {
    "ID of the project"
    id: Int!
}

"Input type for the deleteProjectAutoVersioningProjectProperty mutation."
input DeleteProjectAutoVersioningProjectPropertyInput {
    "Project name"
    project: String!
}

"Input type for the deleteProjectBitbucketCloudConfigurationPropertyById mutation."
input DeleteProjectBitbucketCloudConfigurationPropertyByIdInput {
    "ID of the project"
    id: Int!
}

"Input type for the deleteProjectBitbucketCloudConfigurationProperty mutation."
input DeleteProjectBitbucketCloudConfigurationPropertyInput {
    "Project name"
    project: String!
}

"Input type for the deleteProjectBitbucketConfigurationPropertyById mutation."
input DeleteProjectBitbucketConfigurationPropertyByIdInput {
    "ID of the project"
    id: Int!
}

"Input type for the deleteProjectBitbucketConfigurationProperty mutation."
input DeleteProjectBitbucketConfigurationPropertyInput {
    "Project name"
    project: String!
}

"Input type for the deleteProjectBuildLinkDisplayPropertyById mutation."
input DeleteProjectBuildLinkDisplayPropertyByIdInput {
    "ID of the project"
    id: Int!
}

"Input type for the deleteProjectBuildLinkDisplayProperty mutation."
input DeleteProjectBuildLinkDisplayPropertyInput {
    "Project name"
    project: String!
}

"Input type for the deleteProjectGitHubConfigurationPropertyById mutation."
input DeleteProjectGitHubConfigurationPropertyByIdInput {
    "ID of the project"
    id: Int!
}

"Input type for the deleteProjectGitHubConfigurationProperty mutation."
input DeleteProjectGitHubConfigurationPropertyInput {
    "Project name"
    project: String!
}

"Input type for the deleteProjectGitLabConfigurationPropertyById mutation."
input DeleteProjectGitLabConfigurationPropertyByIdInput {
    "ID of the project"
    id: Int!
}

"Input type for the deleteProjectGitLabConfigurationProperty mutation."
input DeleteProjectGitLabConfigurationPropertyInput {
    "Project name"
    project: String!
}

"Input type for the deleteProject mutation."
input DeleteProjectInput {
    "Project ID"
    id: Int!
}

"Input type for the deleteProjectMessagePropertyById mutation."
input DeleteProjectMessagePropertyByIdInput {
    "ID of the project"
    id: Int!
}

"Input type for the deleteProjectMessageProperty mutation."
input DeleteProjectMessagePropertyInput {
    "Project name"
    project: String!
}

"Input type for the deleteProjectMetaInfoPropertyById mutation."
input DeleteProjectMetaInfoPropertyByIdInput {
    "ID of the project"
    id: Int!
}

"Input type for the deleteProjectMetaInfoProperty mutation."
input DeleteProjectMetaInfoPropertyInput {
    "Project name"
    project: String!
}

"Input type for the deleteProjectSonarQubePropertyById mutation."
input DeleteProjectSonarQubePropertyByIdInput {
    "ID of the project"
    id: Int!
}

"Input type for the deleteProjectSonarQubeProperty mutation."
input DeleteProjectSonarQubePropertyInput {
    "Project name"
    project: String!
}

"Input type for the deleteProjectStalePropertyById mutation."
input DeleteProjectStalePropertyByIdInput {
    "ID of the project"
    id: Int!
}

"Input type for the deleteProjectStaleProperty mutation."
input DeleteProjectStalePropertyInput {
    "Project name"
    project: String!
}

"Input type for the deletePromotionLevelAutoPromotionPropertyById mutation."
input DeletePromotionLevelAutoPromotionPropertyByIdInput {
    "ID of the promotion level"
    id: Int!
}

"Input type for the deletePromotionLevelAutoPromotionProperty mutation."
input DeletePromotionLevelAutoPromotionPropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
    "Promotion name"
    promotion: String!
}

"Input type for the deletePromotionLevelById mutation."
input DeletePromotionLevelByIdInput {
    "Promotion level ID"
    id: Int!
}

"Input type for the deletePromotionLevelMessagePropertyById mutation."
input DeletePromotionLevelMessagePropertyByIdInput {
    "ID of the promotion level"
    id: Int!
}

"Input type for the deletePromotionLevelMessageProperty mutation."
input DeletePromotionLevelMessagePropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
    "Promotion name"
    promotion: String!
}

"Input type for the deletePromotionLevelMetaInfoPropertyById mutation."
input DeletePromotionLevelMetaInfoPropertyByIdInput {
    "ID of the promotion level"
    id: Int!
}

"Input type for the deletePromotionLevelMetaInfoProperty mutation."
input DeletePromotionLevelMetaInfoPropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
    "Promotion name"
    promotion: String!
}

"Input type for the deletePromotionRun mutation."
input DeletePromotionRunInput {
    "Promotion run ID"
    promotionRunId: Int!
}

"Input type for the deletePromotionRunMessagePropertyById mutation."
input DeletePromotionRunMessagePropertyByIdInput {
    "ID of the promotion run"
    id: Int!
}

"Input type for the deletePromotionRunMessageProperty mutation."
input DeletePromotionRunMessagePropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
    "Promotion name"
    promotion: String!
}

"Input type for the deletePromotionRunMetaInfoPropertyById mutation."
input DeletePromotionRunMetaInfoPropertyByIdInput {
    "ID of the promotion run"
    id: Int!
}

"Input type for the deletePromotionRunMetaInfoProperty mutation."
input DeletePromotionRunMetaInfoPropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
    "Promotion name"
    promotion: String!
}

"Input type for the deleteSubscription mutation."
input DeleteSubscriptionInput {
    "ID of the subscription to delete"
    id: String!
    "Target project entity (null for global events)"
    projectEntity: ProjectEntityIDInput
}

"Input type for the deleteValidationRunMessagePropertyById mutation."
input DeleteValidationRunMessagePropertyByIdInput {
    "ID of the validation run"
    id: Int!
}

"Input type for the deleteValidationRunMessageProperty mutation."
input DeleteValidationRunMessagePropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
    "Run name"
    run: String!
    "Validation name"
    validation: String!
}

"Input type for the deleteValidationRunMetaInfoPropertyById mutation."
input DeleteValidationRunMetaInfoPropertyByIdInput {
    "ID of the validation run"
    id: Int!
}

"Input type for the deleteValidationRunMetaInfoProperty mutation."
input DeleteValidationRunMetaInfoPropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
    "Run name"
    run: String!
    "Validation name"
    validation: String!
}

"Input type for the deleteValidationStampById mutation."
input DeleteValidationStampByIdInput {
    "Validation stamp ID"
    id: Int!
}

"Input type for the deleteValidationStampMessagePropertyById mutation."
input DeleteValidationStampMessagePropertyByIdInput {
    "ID of the validation stamp"
    id: Int!
}

"Input type for the deleteValidationStampMessageProperty mutation."
input DeleteValidationStampMessagePropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
    "Validation name"
    validation: String!
}

"Input type for the deleteValidationStampMetaInfoPropertyById mutation."
input DeleteValidationStampMetaInfoPropertyByIdInput {
    "ID of the validation stamp"
    id: Int!
}

"Input type for the deleteValidationStampMetaInfoProperty mutation."
input DeleteValidationStampMetaInfoPropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
    "Validation name"
    validation: String!
}

"Input type for the deleteWebhook mutation."
input DeleteWebhookInput {
    "Name of the webhook to delete"
    name: String!
}

"Input type for the disableAccount mutation."
input DisableAccountInput {
    "ID of the account"
    id: Int!
}

"Input type for the disableBranch mutation."
input DisableBranchInput {
    "Branch ID"
    id: Int!
}

"Input type for the disableProject mutation."
input DisableProjectInput {
    "Project ID"
    id: Int!
}

"Input type for the disableSubscription mutation."
input DisableSubscriptionInput {
    "ID of the subscription to disable"
    id: String
    "Name of the subscription to disable"
    name: String
    "Target project entity (null for global events)"
    projectEntity: ProjectEntityIDInput
}

"Input type for the enableAccount mutation."
input EnableAccountInput {
    "ID of the account"
    id: Int!
}

"Input type for the enableBranch mutation."
input EnableBranchInput {
    "Branch ID"
    id: Int!
}

"Input type for the enableProject mutation."
input EnableProjectInput {
    "Project ID"
    id: Int!
}

"Input type for the enableSubscription mutation."
input EnableSubscriptionInput {
    "ID of the subscription to enable"
    id: String
    "Name of the subscription to enable"
    name: String
    "Target project entity (null for global events)"
    projectEntity: ProjectEntityIDInput
}

input EnvironmentFilter {
    "tags field"
    tags: [String!]!
}

input EventSubscriptionFilter {
    "Filter against the channel type (exact match)"
    channel: String
    "Filter against the channel configuration (channel is required)"
    channelConfig: String
    "Subscriptions created before or on this date"
    createdBefore: LocalDateTime
    "Name of the user who created this subscription"
    creator: String
    "Entity subscribed to."
    entity: ProjectEntityIDInput
    "Event type"
    eventType: String
    "Name of the subscription"
    name: String
    "Origin"
    origin: String
    "Scope of the search (if true, includes the entity and the levels above."
    recursive: Boolean
}

"Input type for the favouriteBranch mutation."
input FavouriteBranchInput {
    "Branch ID"
    id: Int!
}

"Input type for the favouriteProject mutation."
input FavouriteProjectInput {
    "Project ID"
    id: Int!
}

"Input type for the finishSlotPipelineDeployment mutation."
input FinishSlotPipelineDeploymentInput {
    "forcing field"
    forcing: Boolean!
    "message field"
    message: String
    "pipelineId field"
    pipelineId: String!
}

"Input type for the generateToken mutation."
input GenerateTokenInput {
    "name field"
    name: String!
}

input GenericBuildFilter {
    "Filter data as JSON"
    data: String
    "FQCN of the filter type, null if no filter is to be applied"
    type: String
}

input GetChartInput {
    "Name of the chart"
    name: String!
    "General options for the chart"
    options: GetChartOptions!
    "Parameters for the chart (as JSON)"
    parameters: JSON!
}

input GetChartOptions {
    "Interval of time for the chart data"
    interval: String!
    "Period used to consolidate the chart data"
    period: String!
    "Reference data for computing the intervals (null for current time"
    ref: LocalDateTime
}

"Input type for the gitHubCheckAutoVersioningByBuildLabel mutation."
input GitHubCheckAutoVersioningByBuildLabelInput {
    "Label of the build"
    buildLabel: String!
    "owner field"
    owner: String!
    "repository field"
    repository: String!
}

"Input type for the gitHubCheckAutoVersioningByBuildName mutation."
input GitHubCheckAutoVersioningByBuildNameInput {
    "Name of the build"
    buildName: String!
    "owner field"
    owner: String!
    "repository field"
    repository: String!
}

"Input type for the gitHubCheckAutoVersioningByRunId mutation."
input GitHubCheckAutoVersioningByRunIdInput {
    "owner field"
    owner: String!
    "repository field"
    repository: String!
    "ID of the GHA workflow run"
    runId: Long!
}

"Input type for the gitHubIngestionBuildLinksByBuildLabel mutation."
input GitHubIngestionBuildLinksByBuildLabelInput {
    "True of the links must be added to any existing list of links"
    addOnly: Boolean
    "Label of the build"
    buildLabel: String!
    "List of links"
    buildLinks: [GitHubIngestionLink!]!
    "Name of the repository owner to target"
    owner: String!
    "Name of the repository to target"
    repository: String!
}

"Input type for the gitHubIngestionBuildLinksByBuildName mutation."
input GitHubIngestionBuildLinksByBuildNameInput {
    "True of the links must be added to any existing list of links"
    addOnly: Boolean
    "List of links"
    buildLinks: [GitHubIngestionLink!]!
    "Name of the build"
    buildName: String!
    "Name of the repository owner to target"
    owner: String!
    "Name of the repository to target"
    repository: String!
}

"Input type for the gitHubIngestionBuildLinksByRunId mutation."
input GitHubIngestionBuildLinksByRunIdInput {
    "True of the links must be added to any existing list of links"
    addOnly: Boolean
    "List of links"
    buildLinks: [GitHubIngestionLink!]!
    "Name of the repository owner to target"
    owner: String!
    "Name of the repository to target"
    repository: String!
    "ID of the GHA workflow run"
    runId: Long!
}

input GitHubIngestionLink {
    "Name or label of the build to link to (labels start with #)"
    buildRef: String!
    "Name of the project to link to"
    project: String!
    "Qualifier for the link. Blank by default."
    qualifier: String
}

"Input type for the gitHubIngestionValidateDataByBuildLabel mutation."
input GitHubIngestionValidateDataByBuildLabelInput {
    "Build release property (label)"
    buildLabel: String!
    "Name of the repository owner to target"
    owner: String!
    "Name of the repository to target"
    repository: String!
    "Name of the validation stamp to create"
    validation: String!
    "Validation data"
    validationData: GitHubIngestionValidationDataInput!
    "Optional validation status"
    validationStatus: String
}

"Input type for the gitHubIngestionValidateDataByBuildName mutation."
input GitHubIngestionValidateDataByBuildNameInput {
    "Build name"
    buildName: String!
    "Name of the repository owner to target"
    owner: String!
    "Name of the repository to target"
    repository: String!
    "Name of the validation stamp to create"
    validation: String!
    "Validation data"
    validationData: GitHubIngestionValidationDataInput!
    "Optional validation status"
    validationStatus: String
}

"Input type for the gitHubIngestionValidateDataByRunId mutation."
input GitHubIngestionValidateDataByRunIdInput {
    "Name of the repository owner to target"
    owner: String!
    "Name of the repository to target"
    repository: String!
    "ID of the GHA workflow run"
    runId: Long!
    "Name of the validation stamp to create"
    validation: String!
    "Validation data"
    validationData: GitHubIngestionValidationDataInput!
    "Optional validation status"
    validationStatus: String
}

input GitHubIngestionValidationDataInput {
    "Validation data"
    data: JSON!
    "FQCN of the validation data type"
    type: String!
}

"Recording filter input for hook messages"
input HookRecordingFilterInput {
    "hook field"
    hook: String
    "id field"
    id: String
    "state field"
    state: HookRecordState
    "text field"
    text: String
}

"""

Request for the export of a change log.

This request defines how to group issues by type and which format
to use for the export.

If no grouping is specified, the issues will be returned as a list, without any grouping.

The exclude field is used to exclude some issues from the export using their type.

Note that both the export format and the type of issues are specific notions linked to the issue service
(JIRA, GitHub...) that produces the issues.
"""
input IssueChangeLogExportRequest {
    """

    Title of the group to use when an issue does not belong to any group. It defaults to "Other".
    If left empty, any issue not belonging to a group would be excluded from the export. This field
    is not used when no grouping is specified.
    """
    altGroup: String
    "Comma separated list of issue types to exclude from the export."
    exclude: String
    "Export format, \"text\" by default"
    format: String
    """

    Specification for the grouping, none by default.

    This specification describes how to group issues using their type. This format is independent from
    the issue service and this service is responsible for the actual mapping of issue "types" into actual
    issue fields. For example, for GitHub, an issue type is mapped on a label.
    The format of the specification is:

    ----
    specification := "" | $group ( "|" $group)*
    group         := $name "=" $type ( "," $type)*
    ----

    For example:

    ----
    Bugs=bug|Features=feature,enhancement
    ----

    Any issue that would not be mapped in a group will be assigned arbitrarily to the group defined by
    altGroup property.

    If the specification is empty, no grouping will be done.
    """
    grouping: String
}

"Input type for the launchWorkflow mutation."
input LaunchWorkflowInput {
    "context field"
    context: [LaunchWorkflowInputContext!]!
    "workflowId field"
    workflowId: String!
}

input LaunchWorkflowInputContext {
    "key field"
    key: String!
    "value field"
    value: JSON!
}

"Input type for the linkBuildById mutation."
input LinkBuildByIdInput {
    "ID of the build from which the link must be created"
    fromBuild: Int!
    "Qualifier for the link"
    qualifier: String
    "ID of the build to which the link must be created"
    toBuild: Int!
}

"Input type for the linkBuild mutation."
input LinkBuildInput {
    "Name of the build from which the link must be created"
    fromBuild: String!
    "Name of the project from which the link must be created"
    fromProject: String!
    "Qualifier for the link"
    qualifier: String
    "Name of the build to which the link must be created"
    toBuild: String!
    "Name of the project to which the link must be created"
    toProject: String!
}

"Input type for the linksBuild mutation."
input LinksBuildInput {
    "Name of the build from which the link must be created"
    fromBuild: String!
    "Name of the project from which the link must be created"
    fromProject: String!
    "List of links to add"
    links: [LinksBuildInputItem!]!
}

"LinksBuildInputItem"
input LinksBuildInputItem {
    "Name of the build to which the link must be created"
    build: String!
    "Name of the project to which the link must be created"
    project: String!
    "Qualifier for the link"
    qualifier: String
}

"Input type for the lockAccount mutation."
input LockAccountInput {
    "ID of the account"
    id: Int!
}

"Meta information property"
input MetaInfoPropertyItemInput {
    "category field"
    category: String
    "link field"
    link: String
    "name field"
    name: String!
    "value field"
    value: String
}

"One metric: a name and a value"
input MetricsEntryInput {
    "Metric name"
    name: String!
    "Metric value"
    value: Float!
}

"Input type for the postQueue mutation."
input PostQueueInput {
    "payload field"
    payload: JSON!
    "processor field"
    processor: String!
}

input ProjectEntityIDInput {
    "Project entity ID"
    id: Int!
    "Project entity type"
    type: ProjectEntityType!
}

input PropertyFilter {
    "type field"
    type: String
    "value field"
    value: String
}

"Recording filter input for queue messages"
input QueueRecordingFilterInput {
    "Unique ID for the record"
    id: String
    "Filtering on the processor"
    processor: String
    "Filtering on the queue name"
    queueName: String
    "Filtering on the routing key"
    routingKey: String
    "Filtering on the state"
    state: QueueRecordState
    "Filtering using some free text in the payload"
    text: String
}

"Input type for the renameSubscription mutation."
input RenameSubscriptionInput {
    "Name of the subscription to rename"
    name: String!
    "New name to set"
    newName: String!
    "Target project entity (null for global events)"
    projectEntity: ProjectEntityIDInput
}

"Input type for the reorderPromotionLevelById mutation."
input ReorderPromotionLevelByIdInput {
    "Branch ID"
    branchId: Int!
    "New name to swap"
    newName: String!
    "Old name to swap"
    oldName: String!
}

"Input type for the revokeAccountTokens mutation."
input RevokeAccountTokensInput {
    "accountId field"
    accountId: Int!
}

"Input type for the revokeToken mutation."
input RevokeTokenInput {
    "name field"
    name: String!
}

"Input for some run info"
input RunInfoInput {
    "Time of the run (in seconds)"
    runTime: Int
    "Type of source (like \"github\")"
    sourceType: String
    "URI to the source of the run (like the URL to a Jenkins job)"
    sourceUri: String
    "Data associated with the trigger (like a user ID or a commit)"
    triggerData: String
    "Type of trigger (like \"scm\" or \"user\")"
    triggerType: String
}

"""

Request for the export of a change log.

This request defines how to group issues by type and which format
to use for the export.

If no grouping is specified, the issues will be returned as a list, without any grouping.

The exclude field is used to exclude some issues from the export using their type.

Note that both the export format and the type of issues are specific notions linked to the issue service
(JIRA, GitHub...) that produces the issues.
"""
input SCMChangeLogExportInput {
    """

    Title of the group to use when an issue does not belong to any group. It defaults to "Other".
    If left empty, any issue not belonging to a group would be excluded from the export. This field
    is not used when no grouping is specified.
    """
    altGroup: String
    exclude: String
    "Selected format. Defaults to plain text."
    format: String
    """

    Specification for the grouping, none by default.

    This specification describes how to group issues using their type. This format is independent from
    the issue service and this service is responsible for the actual mapping of issue "types" into actual
    issue fields. For example, for GitHub, an issue type is mapped on a label.
    The format of the specification is:

    ----
    specification := "" | ${'$'}group ( "|" ${'$'}group)*
    group         := ${'$'}name "=" ${'$'}type ( "," ${'$'}type)*
    ----

    For example:

    ----
    Bugs=bug|Features=feature,enhancement
    ----

    Any issue that would not be mapped in a group will be assigned arbitrarily to the group defined by
    altGroup property.

    If the specification is empty, no grouping will be done.
    """
    grouping: String
}

"Input type for the saveBuildFilter mutation."
input SaveBuildFilterInput {
    "branchId field"
    branchId: Int!
    "data field"
    data: JSON!
    "name field"
    name: String!
    "type field"
    type: String!
}

input SaveDashboardInput {
    name: String!
    select: Boolean! = true
    userScope: DashboardContextUserScope!
    uuid: String
    widgets: [WidgetInstanceInput!]!
}

input SaveSettingsInput {
    "ID of the settings"
    id: String!
    "Values for the settings"
    values: JSON!
}

"Input type for the saveYamlWorkflow mutation."
input SaveYamlWorkflowInput {
    "workflow field"
    workflow: String!
}

input SelectDashboardInput {
    "UUID of the dashboard to select"
    uuid: String!
}

"Input type for the setAutoVersioningConfigByName mutation."
input SetAutoVersioningConfigByNameInput {
    "Name of the branch to configure"
    branch: String!
    "List of configurations"
    configurations: [AutoVersioningSourceConfigInput!]!
    "Name of the branch project to configure"
    project: String!
}

"Input type for the setAutoVersioningConfig mutation."
input SetAutoVersioningConfigInput {
    "ID of the branch to configure"
    branchId: Int!
    "List of configurations"
    configurations: [AutoVersioningSourceConfigInput!]!
}

"Input type for the setBranchGitConfigPropertyById mutation."
input SetBranchGitConfigPropertyByIdInput {
    "Git branch name"
    gitBranch: String!
    "ID of the branch"
    id: Int!
}

"Input type for the setBranchGitConfigProperty mutation."
input SetBranchGitConfigPropertyInput {
    "Branch name"
    branch: String!
    "Git branch name"
    gitBranch: String!
    "Project name"
    project: String!
}

"Input type for the setBranchGitHubIngestionConfig mutation."
input SetBranchGitHubIngestionConfigInput {
    "ID of the branch to update"
    branchId: Int!
    "Ingestion configuration as YAML. Indentation will be trimmed automatically."
    yaml: String!
}

"Input type for the setBranchMessagePropertyById mutation."
input SetBranchMessagePropertyByIdInput {
    "ID of the branch"
    id: Int!
    "Text of the message"
    text: String!
    "Type of message"
    type: String!
}

"Input type for the setBranchMessageProperty mutation."
input SetBranchMessagePropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
    "Text of the message"
    text: String!
    "Type of message"
    type: String!
}

"Input type for the setBranchMetaInfoPropertyById mutation."
input SetBranchMetaInfoPropertyByIdInput {
    "True to add the items to the existing meta info, false to override it"
    append: Boolean = false
    "ID of the branch"
    id: Int!
    "List of meta info"
    items: [MetaInfoPropertyItemInput!]!
}

"Input type for the setBranchMetaInfoProperty mutation."
input SetBranchMetaInfoPropertyInput {
    "True to add the items to the existing meta info, false to override it"
    append: Boolean = false
    "Branch name"
    branch: String!
    "List of meta info"
    items: [MetaInfoPropertyItemInput!]!
    "Project name"
    project: String!
}

"Input type for the setBranchPropertyById mutation."
input SetBranchPropertyByIdInput {
    "ID of the branch"
    id: Int!
    "FQCN of the property to set"
    property: String!
    "JSON for the property value or null to delete the property"
    value: JSON
}

"Input type for the setBranchProperty mutation."
input SetBranchPropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
    "FQCN of the property to set"
    property: String!
    "JSON for the property value or null to delete the property"
    value: JSON
}

"Input type for the setBranchReleaseValidationPropertyById mutation."
input SetBranchReleaseValidationPropertyByIdInput {
    "ID of the branch"
    id: Int!
    "Name of the validation to create when a release/label is set on a build"
    validation: String!
}

"Input type for the setBranchReleaseValidationProperty mutation."
input SetBranchReleaseValidationPropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
    "Name of the validation to create when a release/label is set on a build"
    validation: String!
}

"Input type for the setBuildGitCommitPropertyById mutation."
input SetBuildGitCommitPropertyByIdInput {
    "Full commit hash"
    commit: String!
    "ID of the build"
    id: Int!
}

"Input type for the setBuildGitCommitProperty mutation."
input SetBuildGitCommitPropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Full commit hash"
    commit: String!
    "Project name"
    project: String!
}

"Input type for the setBuildMessagePropertyById mutation."
input SetBuildMessagePropertyByIdInput {
    "ID of the build"
    id: Int!
    "Text of the message"
    text: String!
    "Type of message"
    type: String!
}

"Input type for the setBuildMessageProperty mutation."
input SetBuildMessagePropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
    "Text of the message"
    text: String!
    "Type of message"
    type: String!
}

"Input type for the setBuildMetaInfoPropertyById mutation."
input SetBuildMetaInfoPropertyByIdInput {
    "True to add the items to the existing meta info, false to override it"
    append: Boolean = false
    "ID of the build"
    id: Int!
    "List of meta info"
    items: [MetaInfoPropertyItemInput!]!
}

"Input type for the setBuildMetaInfoProperty mutation."
input SetBuildMetaInfoPropertyInput {
    "True to add the items to the existing meta info, false to override it"
    append: Boolean = false
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "List of meta info"
    items: [MetaInfoPropertyItemInput!]!
    "Project name"
    project: String!
}

"Input type for the setBuildPropertyById mutation."
input SetBuildPropertyByIdInput {
    "ID of the build"
    id: Int!
    "FQCN of the property to set"
    property: String!
    "JSON for the property value or null to delete the property"
    value: JSON
}

"Input type for the setBuildProperty mutation."
input SetBuildPropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
    "FQCN of the property to set"
    property: String!
    "JSON for the property value or null to delete the property"
    value: JSON
}

"Input type for the setBuildReleasePropertyById mutation."
input SetBuildReleasePropertyByIdInput {
    "ID of the build"
    id: Int!
    "Name of the release/version tag to set"
    release: String!
}

"Input type for the setBuildReleaseProperty mutation."
input SetBuildReleasePropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
    "Name of the release/version tag to set"
    release: String!
}

"Input type for the setGenericProperty mutation."
input SetGenericPropertyInput {
    "entityId field"
    entityId: Int!
    "entityType field"
    entityType: ProjectEntityType!
    "type field"
    type: String!
    "value field"
    value: JSON!
}

"Input type for the setPreferences mutation."
input SetPreferencesInput {
    "branchViewVsGroups field"
    branchViewVsGroups: Boolean
    "branchViewVsNames field"
    branchViewVsNames: Boolean
    "Dashboard selected by default"
    dashboardUuid: String
    "Selected branch view"
    selectedBranchViewKey: String
}

"Input type for the setProjectAutoPromotionLevelPropertyById mutation."
input SetProjectAutoPromotionLevelPropertyByIdInput {
    "ID of the project"
    id: Int!
    "If promotion levels must be created from predefined promotion levels"
    isAutoCreate: Boolean
}

"Input type for the setProjectAutoPromotionLevelProperty mutation."
input SetProjectAutoPromotionLevelPropertyInput {
    "If promotion levels must be created from predefined promotion levels"
    isAutoCreate: Boolean
    "Project name"
    project: String!
}

"Input type for the setProjectAutoValidationStampPropertyById mutation."
input SetProjectAutoValidationStampPropertyByIdInput {
    "ID of the project"
    id: Int!
    "If validation stamps must be created from predefined validation stamps"
    isAutoCreate: Boolean
    "If validation stamps must be created even if predefined validation stamp is not available"
    isAutoCreateIfNotPredefined: Boolean
}

"Input type for the setProjectAutoValidationStampProperty mutation."
input SetProjectAutoValidationStampPropertyInput {
    "If validation stamps must be created from predefined validation stamps"
    isAutoCreate: Boolean
    "If validation stamps must be created even if predefined validation stamp is not available"
    isAutoCreateIfNotPredefined: Boolean
    "Project name"
    project: String!
}

"Input type for the setProjectAutoVersioningProjectPropertyById mutation."
input SetProjectAutoVersioningProjectPropertyByIdInput {
    "List of regular expressions. AV requests match if no regular expression is matched by the target branch name. If empty, the target branch is considered matching."
    branchExcludes: [String!]
    "List of regular expressions. AV requests match if at least one regular expression is matched by the target branch name. If empty, all target branches match (the default)."
    branchIncludes: [String!]
    "ID of the project"
    id: Int!
    "If defined, any target branch whose last activity (last build creation) is before this date will be ignored by the auto-versioning"
    lastActivityDate: LocalDateTime
}

"Input type for the setProjectAutoVersioningProjectProperty mutation."
input SetProjectAutoVersioningProjectPropertyInput {
    "List of regular expressions. AV requests match if no regular expression is matched by the target branch name. If empty, the target branch is considered matching."
    branchExcludes: [String!]
    "List of regular expressions. AV requests match if at least one regular expression is matched by the target branch name. If empty, all target branches match (the default)."
    branchIncludes: [String!]
    "If defined, any target branch whose last activity (last build creation) is before this date will be ignored by the auto-versioning"
    lastActivityDate: LocalDateTime
    "Project name"
    project: String!
}

"Input type for the setProjectBitbucketCloudConfigurationPropertyById mutation."
input SetProjectBitbucketCloudConfigurationPropertyByIdInput {
    "Name of the Bitbucket Cloud configuration to use"
    configuration: String!
    "ID of the project"
    id: Int!
    "Interval (in minutes) between each indexation of the repository by Ontrack"
    indexationInterval: Int
    "Issue identifier to use, for example jira//name where name is the name of the JIRA configuration in Ontrack."
    issueServiceConfigurationIdentifier: String
    "Bitbucket Cloud repository to use, in the form of `workspace/name`"
    repository: String!
}

"Input type for the setProjectBitbucketCloudConfigurationProperty mutation."
input SetProjectBitbucketCloudConfigurationPropertyInput {
    "Name of the Bitbucket Cloud configuration to use"
    configuration: String!
    "Interval (in minutes) between each indexation of the repository by Ontrack"
    indexationInterval: Int
    "Issue identifier to use, for example jira//name where name is the name of the JIRA configuration in Ontrack."
    issueServiceConfigurationIdentifier: String
    "Project name"
    project: String!
    "Bitbucket Cloud repository to use, in the form of `workspace/name`"
    repository: String!
}

"Input type for the setProjectBitbucketConfigurationPropertyById mutation."
input SetProjectBitbucketConfigurationPropertyByIdInput {
    "Key of the Bitbucket project to use"
    bitbucketProject: String!
    "Name of the Bitbucket repository to use"
    bitbucketRepository: String!
    "Name of the Bitbucket configuration to use"
    configuration: String!
    "ID of the project"
    id: Int!
    "Interval (in minutes) between each indexation of the repository by Ontrack"
    indexationInterval: Int
    "Issue identifier to use, for example jira//name where name is the name of the JIRA configuration in Ontrack."
    issueServiceConfigurationIdentifier: String
}

"Input type for the setProjectBitbucketConfigurationProperty mutation."
input SetProjectBitbucketConfigurationPropertyInput {
    "Key of the Bitbucket project to use"
    bitbucketProject: String!
    "Name of the Bitbucket repository to use"
    bitbucketRepository: String!
    "Name of the Bitbucket configuration to use"
    configuration: String!
    "Interval (in minutes) between each indexation of the repository by Ontrack"
    indexationInterval: Int
    "Issue identifier to use, for example jira//name where name is the name of the JIRA configuration in Ontrack."
    issueServiceConfigurationIdentifier: String
    "Project name"
    project: String!
}

"Input type for the setProjectBuildLinkDisplayPropertyById mutation."
input SetProjectBuildLinkDisplayPropertyByIdInput {
    "ID of the project"
    id: Int!
    "Configuration at project label to specify that a build link decoration should use the release/label of a build when available. By default, it displays the build name."
    useLabel: Boolean!
}

"Input type for the setProjectBuildLinkDisplayProperty mutation."
input SetProjectBuildLinkDisplayPropertyInput {
    "Project name"
    project: String!
    "Configuration at project label to specify that a build link decoration should use the release/label of a build when available. By default, it displays the build name."
    useLabel: Boolean!
}

"Input type for the setProjectGitHubConfigurationPropertyById mutation."
input SetProjectGitHubConfigurationPropertyByIdInput {
    "Name of the GitHub configuration to use"
    configuration: String!
    "ID of the project"
    id: Int!
    "Interval (in minutes) between each indexation of the repository by Ontrack"
    indexationInterval: Int
    "Issue identifier to use, for example jira//name where name is the name of the JIRA configuration in Ontrack."
    issueServiceConfigurationIdentifier: String
    "GitHub repository to use, in the form of `organization/name`"
    repository: String!
}

"Input type for the setProjectGitHubConfigurationProperty mutation."
input SetProjectGitHubConfigurationPropertyInput {
    "Name of the GitHub configuration to use"
    configuration: String!
    "Interval (in minutes) between each indexation of the repository by Ontrack"
    indexationInterval: Int
    "Issue identifier to use, for example jira//name where name is the name of the JIRA configuration in Ontrack."
    issueServiceConfigurationIdentifier: String
    "Project name"
    project: String!
    "GitHub repository to use, in the form of `organization/name`"
    repository: String!
}

"Input type for the setProjectGitLabConfigurationPropertyById mutation."
input SetProjectGitLabConfigurationPropertyByIdInput {
    "Name of the GitLab configuration to use"
    configuration: String!
    "ID of the project"
    id: Int!
    "Interval (in minutes) between each indexation of the repository by Ontrack"
    indexationInterval: Int
    "Issue identifier to use, for example jira//name where name is the name of the JIRA configuration in Ontrack."
    issueServiceConfigurationIdentifier: String
    "GitLab repository to use, in the form of `project/name`"
    repository: String!
}

"Input type for the setProjectGitLabConfigurationProperty mutation."
input SetProjectGitLabConfigurationPropertyInput {
    "Name of the GitLab configuration to use"
    configuration: String!
    "Interval (in minutes) between each indexation of the repository by Ontrack"
    indexationInterval: Int
    "Issue identifier to use, for example jira//name where name is the name of the JIRA configuration in Ontrack."
    issueServiceConfigurationIdentifier: String
    "Project name"
    project: String!
    "GitLab repository to use, in the form of `project/name`"
    repository: String!
}

"Input type for the setProjectMessagePropertyById mutation."
input SetProjectMessagePropertyByIdInput {
    "ID of the project"
    id: Int!
    "Text of the message"
    text: String!
    "Type of message"
    type: String!
}

"Input type for the setProjectMessageProperty mutation."
input SetProjectMessagePropertyInput {
    "Project name"
    project: String!
    "Text of the message"
    text: String!
    "Type of message"
    type: String!
}

"Input type for the setProjectMetaInfoPropertyById mutation."
input SetProjectMetaInfoPropertyByIdInput {
    "True to add the items to the existing meta info, false to override it"
    append: Boolean = false
    "ID of the project"
    id: Int!
    "List of meta info"
    items: [MetaInfoPropertyItemInput!]!
}

"Input type for the setProjectMetaInfoProperty mutation."
input SetProjectMetaInfoPropertyInput {
    "True to add the items to the existing meta info, false to override it"
    append: Boolean = false
    "List of meta info"
    items: [MetaInfoPropertyItemInput!]!
    "Project name"
    project: String!
}

"Input type for the setProjectPropertyById mutation."
input SetProjectPropertyByIdInput {
    "ID of the project"
    id: Int!
    "FQCN of the property to set"
    property: String!
    "JSON for the property value or null to delete the property"
    value: JSON
}

"Input type for the setProjectProperty mutation."
input SetProjectPropertyInput {
    "Project name"
    project: String!
    "FQCN of the property to set"
    property: String!
    "JSON for the property value or null to delete the property"
    value: JSON
}

"Input type for the setProjectSonarQubePropertyById mutation."
input SetProjectSonarQubePropertyByIdInput {
    "Using the branch model to restrict the collection of measures"
    branchModel: Boolean!
    "Regex to use to restrict the branches for which the measures are collected"
    branchPattern: String
    "Name of the SonarQube configuration to use"
    configuration: String!
    "ID of the project"
    id: Int!
    "Key of the project in SonarQube"
    key: String!
    "List of measures to collect"
    measures: [String!]!
    "Overriding the list of measures from the global settings"
    override: Boolean!
    "If checked, collected SQ measures will be attached as metrics to the validation."
    validationMetrics: Boolean!
    "Validation stamp to listen to"
    validationStamp: String!
}

"Input type for the setProjectSonarQubeProperty mutation."
input SetProjectSonarQubePropertyInput {
    "Using the branch model to restrict the collection of measures"
    branchModel: Boolean!
    "Regex to use to restrict the branches for which the measures are collected"
    branchPattern: String
    "Name of the SonarQube configuration to use"
    configuration: String!
    "Key of the project in SonarQube"
    key: String!
    "List of measures to collect"
    measures: [String!]!
    "Overriding the list of measures from the global settings"
    override: Boolean!
    "Project name"
    project: String!
    "If checked, collected SQ measures will be attached as metrics to the validation."
    validationMetrics: Boolean!
    "Validation stamp to listen to"
    validationStamp: String!
}

"Input type for the setProjectStalePropertyById mutation."
input SetProjectStalePropertyByIdInput {
    "Number of days of inactivity after a branch has been disabled after which the branch is deleted. If 0, the branches are never deleted."
    deletingDuration: Int
    "Number of days of inactivity after which the branch is disabled"
    disablingDuration: Int!
    "Can define a regular expression for exceptions to the includes rule"
    excludes: String
    "ID of the project"
    id: Int!
    "Regular expression to identify branches which will never be disabled not deleted"
    includes: String
    "List of promotions to always keep. If a branch has at least one build having one of these promotions, the branch will never be disabled not deleted."
    promotionsToKeep: [String!]
}

"Input type for the setProjectStaleProperty mutation."
input SetProjectStalePropertyInput {
    "Number of days of inactivity after a branch has been disabled after which the branch is deleted. If 0, the branches are never deleted."
    deletingDuration: Int
    "Number of days of inactivity after which the branch is disabled"
    disablingDuration: Int!
    "Can define a regular expression for exceptions to the includes rule"
    excludes: String
    "Regular expression to identify branches which will never be disabled not deleted"
    includes: String
    "Project name"
    project: String!
    "List of promotions to always keep. If a branch has at least one build having one of these promotions, the branch will never be disabled not deleted."
    promotionsToKeep: [String!]
}

"Input type for the setPromotionLevelAutoPromotionPropertyById mutation."
input SetPromotionLevelAutoPromotionPropertyByIdInput {
    "Regular expression to exclude validation stamps by name"
    exclude: String
    "ID of the promotion level"
    id: Int!
    "Regular expression to include validation stamps by name"
    include: String
    "List of needed promotion levels"
    promotionLevels: [String!]
    "List of needed validation stamps"
    validationStamps: [String!]
}

"Input type for the setPromotionLevelAutoPromotionProperty mutation."
input SetPromotionLevelAutoPromotionPropertyInput {
    "Branch name"
    branch: String!
    "Regular expression to exclude validation stamps by name"
    exclude: String
    "Regular expression to include validation stamps by name"
    include: String
    "Project name"
    project: String!
    "Promotion name"
    promotion: String!
    "List of needed promotion levels"
    promotionLevels: [String!]
    "List of needed validation stamps"
    validationStamps: [String!]
}

"Input type for the setPromotionLevelMessagePropertyById mutation."
input SetPromotionLevelMessagePropertyByIdInput {
    "ID of the promotion level"
    id: Int!
    "Text of the message"
    text: String!
    "Type of message"
    type: String!
}

"Input type for the setPromotionLevelMessageProperty mutation."
input SetPromotionLevelMessagePropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
    "Promotion name"
    promotion: String!
    "Text of the message"
    text: String!
    "Type of message"
    type: String!
}

"Input type for the setPromotionLevelMetaInfoPropertyById mutation."
input SetPromotionLevelMetaInfoPropertyByIdInput {
    "True to add the items to the existing meta info, false to override it"
    append: Boolean = false
    "ID of the promotion level"
    id: Int!
    "List of meta info"
    items: [MetaInfoPropertyItemInput!]!
}

"Input type for the setPromotionLevelMetaInfoProperty mutation."
input SetPromotionLevelMetaInfoPropertyInput {
    "True to add the items to the existing meta info, false to override it"
    append: Boolean = false
    "Branch name"
    branch: String!
    "List of meta info"
    items: [MetaInfoPropertyItemInput!]!
    "Project name"
    project: String!
    "Promotion name"
    promotion: String!
}

"Input type for the setPromotionLevelPropertyById mutation."
input SetPromotionLevelPropertyByIdInput {
    "ID of the promotion level"
    id: Int!
    "FQCN of the property to set"
    property: String!
    "JSON for the property value or null to delete the property"
    value: JSON
}

"Input type for the setPromotionLevelProperty mutation."
input SetPromotionLevelPropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
    "Promotion name"
    promotion: String!
    "FQCN of the property to set"
    property: String!
    "JSON for the property value or null to delete the property"
    value: JSON
}

"Input type for the setPromotionRunMessagePropertyById mutation."
input SetPromotionRunMessagePropertyByIdInput {
    "ID of the promotion run"
    id: Int!
    "Text of the message"
    text: String!
    "Type of message"
    type: String!
}

"Input type for the setPromotionRunMessageProperty mutation."
input SetPromotionRunMessagePropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
    "Promotion name"
    promotion: String!
    "Text of the message"
    text: String!
    "Type of message"
    type: String!
}

"Input type for the setPromotionRunMetaInfoPropertyById mutation."
input SetPromotionRunMetaInfoPropertyByIdInput {
    "True to add the items to the existing meta info, false to override it"
    append: Boolean = false
    "ID of the promotion run"
    id: Int!
    "List of meta info"
    items: [MetaInfoPropertyItemInput!]!
}

"Input type for the setPromotionRunMetaInfoProperty mutation."
input SetPromotionRunMetaInfoPropertyInput {
    "True to add the items to the existing meta info, false to override it"
    append: Boolean = false
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "List of meta info"
    items: [MetaInfoPropertyItemInput!]!
    "Project name"
    project: String!
    "Promotion name"
    promotion: String!
}

"Input type for the setPromotionRunPropertyById mutation."
input SetPromotionRunPropertyByIdInput {
    "ID of the promotion run"
    id: Int!
    "FQCN of the property to set"
    property: String!
    "JSON for the property value or null to delete the property"
    value: JSON
}

"Input type for the setPromotionRunProperty mutation."
input SetPromotionRunPropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
    "Promotion name"
    promotion: String!
    "FQCN of the property to set"
    property: String!
    "JSON for the property value or null to delete the property"
    value: JSON
}

"Input type for the setValidationRunMessagePropertyById mutation."
input SetValidationRunMessagePropertyByIdInput {
    "ID of the validation run"
    id: Int!
    "Text of the message"
    text: String!
    "Type of message"
    type: String!
}

"Input type for the setValidationRunMessageProperty mutation."
input SetValidationRunMessagePropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
    "Run name"
    run: String!
    "Text of the message"
    text: String!
    "Type of message"
    type: String!
    "Validation name"
    validation: String!
}

"Input type for the setValidationRunMetaInfoPropertyById mutation."
input SetValidationRunMetaInfoPropertyByIdInput {
    "True to add the items to the existing meta info, false to override it"
    append: Boolean = false
    "ID of the validation run"
    id: Int!
    "List of meta info"
    items: [MetaInfoPropertyItemInput!]!
}

"Input type for the setValidationRunMetaInfoProperty mutation."
input SetValidationRunMetaInfoPropertyInput {
    "True to add the items to the existing meta info, false to override it"
    append: Boolean = false
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "List of meta info"
    items: [MetaInfoPropertyItemInput!]!
    "Project name"
    project: String!
    "Run name"
    run: String!
    "Validation name"
    validation: String!
}

"Input type for the setValidationRunPropertyById mutation."
input SetValidationRunPropertyByIdInput {
    "ID of the validation run"
    id: Int!
    "FQCN of the property to set"
    property: String!
    "JSON for the property value or null to delete the property"
    value: JSON
}

"Input type for the setValidationRunProperty mutation."
input SetValidationRunPropertyInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Project name"
    project: String!
    "FQCN of the property to set"
    property: String!
    "Run name"
    run: String!
    "Validation name"
    validation: String!
    "JSON for the property value or null to delete the property"
    value: JSON
}

"Input type for the setValidationStampMessagePropertyById mutation."
input SetValidationStampMessagePropertyByIdInput {
    "ID of the validation stamp"
    id: Int!
    "Text of the message"
    text: String!
    "Type of message"
    type: String!
}

"Input type for the setValidationStampMessageProperty mutation."
input SetValidationStampMessagePropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
    "Text of the message"
    text: String!
    "Type of message"
    type: String!
    "Validation name"
    validation: String!
}

"Input type for the setValidationStampMetaInfoPropertyById mutation."
input SetValidationStampMetaInfoPropertyByIdInput {
    "True to add the items to the existing meta info, false to override it"
    append: Boolean = false
    "ID of the validation stamp"
    id: Int!
    "List of meta info"
    items: [MetaInfoPropertyItemInput!]!
}

"Input type for the setValidationStampMetaInfoProperty mutation."
input SetValidationStampMetaInfoPropertyInput {
    "True to add the items to the existing meta info, false to override it"
    append: Boolean = false
    "Branch name"
    branch: String!
    "List of meta info"
    items: [MetaInfoPropertyItemInput!]!
    "Project name"
    project: String!
    "Validation name"
    validation: String!
}

"Input type for the setValidationStampPropertyById mutation."
input SetValidationStampPropertyByIdInput {
    "ID of the validation stamp"
    id: Int!
    "FQCN of the property to set"
    property: String!
    "JSON for the property value or null to delete the property"
    value: JSON
}

"Input type for the setValidationStampProperty mutation."
input SetValidationStampPropertyInput {
    "Branch name"
    branch: String!
    "Project name"
    project: String!
    "FQCN of the property to set"
    property: String!
    "Validation name"
    validation: String!
    "JSON for the property value or null to delete the property"
    value: JSON
}

"Input type for the setupCHMLValidationStamp mutation."
input SetupCHMLValidationStampInput {
    "Name of the branch"
    branch: String!
    "Description of the validation stamp"
    description: String
    "Level needed to raise a failure"
    failedLevel: CHMLLevel!
    "Name of the project"
    project: String!
    "Name of the validation stamp"
    validation: String!
    "Level needed to raise a warning"
    warningLevel: CHMLLevel!
}

"Input type for the setupMetricsValidationStamp mutation."
input SetupMetricsValidationStampInput {
    "Name of the branch"
    branch: String!
    "Description of the validation stamp"
    description: String
    "Name of the project"
    project: String!
    "Name of the validation stamp"
    validation: String!
}

"Input type for the setupPercentageValidationStamp mutation."
input SetupPercentageValidationStampInput {
    "Name of the branch"
    branch: String!
    "Description of the validation stamp"
    description: String
    "Threshold value for a failure"
    failureThreshold: Int
    "Direction of the value scale"
    okIfGreater: Boolean
    "Name of the project"
    project: String!
    "Name of the validation stamp"
    validation: String!
    "Threshold value for a warning"
    warningThreshold: Int
}

"Input type for the setupPromotionLevel mutation."
input SetupPromotionLevelInput {
    "branch field"
    branch: String!
    "description field"
    description: String
    "project field"
    project: String!
    "promotion field"
    promotion: String!
}

"Input type for the setupTestSummaryValidationStamp mutation."
input SetupTestSummaryValidationStampInput {
    "Name of the branch"
    branch: String!
    "Description of the validation stamp"
    description: String
    "Name of the project"
    project: String!
    "Name of the validation stamp"
    validation: String!
    "If set to true, the status is set to warning if there is at least one skipped test."
    warningIfSkipped: Boolean
}

"Input type for the setupValidationStamp mutation."
input SetupValidationStampInput {
    "branch field"
    branch: String!
    "dataType field"
    dataType: String
    "dataTypeConfig field"
    dataTypeConfig: JSON
    "description field"
    description: String
    "project field"
    project: String!
    "validation field"
    validation: String!
}

"Input type for the shareBuildFilter mutation."
input ShareBuildFilterInput {
    "branchId field"
    branchId: Int!
    "data field"
    data: JSON!
    "name field"
    name: String!
    "type field"
    type: String!
}

input ShareDashboardInput {
    "UUID of the dashboard to share"
    uuid: String!
}

"Input type for the shareSCMFileChangeFilter mutation."
input ShareSCMFileChangeFilterInput {
    "Name of the filter"
    name: String!
    "List of patterns"
    patterns: [String!]!
    "ID of the project"
    projectId: Int!
}

input StandardBuildFilter {
    "Build created after or on this date"
    afterDate: String
    "Build created before or on this date"
    beforeDate: String
    "Maximum number of builds to display"
    count: Int = 10
    """

    The build must be linked FROM the builds selected by the pattern.
    Syntax: PRJ:BLD where PRJ is a project name and BLD a build expression - with * as placeholder
    """
    linkedFrom: String
    "The build must be linked FROM a build having this promotion (requires \"linkedFrom\")"
    linkedFromPromotion: String
    """

    The build must be linked TO the builds selected by the pattern.
    Syntax: PRJ:BLD where PRJ is a project name and BLD a build expression - with * as placeholder
    """
    linkedTo: String
    "The build must be linked TO a build having this promotion (requires \"linkedTo\")"
    linkedToPromotion: String
    "Builds since the last one which was promoted to this level"
    sincePromotionLevel: String
    "Since property"
    sinceProperty: String
    "...with value"
    sincePropertyValue: String
    "Builds since the last one which had this validation stamp"
    sinceValidationStamp: String
    "... with status"
    sinceValidationStampStatus: String
    "Builds with this promotion level"
    withPromotionLevel: String
    "With property"
    withProperty: String
    "...with value"
    withPropertyValue: String
    "Builds with this validation stamp"
    withValidationStamp: String
    "... with status"
    withValidationStampStatus: String
}

"Input type for the startSlotPipelineDeployment mutation."
input StartSlotPipelineDeploymentInput {
    "pipelineId field"
    pipelineId: String!
}

"Input type for the startSlotPipeline mutation."
input StartSlotPipelineInput {
    "buildId field"
    buildId: Int!
    "slotId field"
    slotId: String!
}

"Input type for the stopWorkflow mutation."
input StopWorkflowInput {
    "workflowInstanceId field"
    workflowInstanceId: String!
}

"Input type for the subscribeBranchToEvents mutation."
input SubscribeBranchToEventsInput {
    "Branch name"
    branch: String!
    "Channel to send this event to"
    channel: String!
    "Channel configuration"
    channelConfig: JSON!
    "Optional template to use for the message"
    contentTemplate: String
    "List of events types to subscribe to"
    events: [String!]!
    "Optional space-separated list of tokens to look for in the events"
    keywords: String
    "Unique name of the channel in its scope (null for backward compatibility, will be required in V5)"
    name: String
    "Project name"
    project: String!
}

"Input type for the subscribeBuildToEvents mutation."
input SubscribeBuildToEventsInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Channel to send this event to"
    channel: String!
    "Channel configuration"
    channelConfig: JSON!
    "Optional template to use for the message"
    contentTemplate: String
    "List of events types to subscribe to"
    events: [String!]!
    "Optional space-separated list of tokens to look for in the events"
    keywords: String
    "Unique name of the channel in its scope (null for backward compatibility, will be required in V5)"
    name: String
    "Project name"
    project: String!
}

"Input type for the subscribeProjectToEvents mutation."
input SubscribeProjectToEventsInput {
    "Channel to send this event to"
    channel: String!
    "Channel configuration"
    channelConfig: JSON!
    "Optional template to use for the message"
    contentTemplate: String
    "List of events types to subscribe to"
    events: [String!]!
    "Optional space-separated list of tokens to look for in the events"
    keywords: String
    "Unique name of the channel in its scope (null for backward compatibility, will be required in V5)"
    name: String
    "Project name"
    project: String!
}

"Input type for the subscribePromotionLevelToEvents mutation."
input SubscribePromotionLevelToEventsInput {
    "Branch name"
    branch: String!
    "Channel to send this event to"
    channel: String!
    "Channel configuration"
    channelConfig: JSON!
    "Optional template to use for the message"
    contentTemplate: String
    "List of events types to subscribe to"
    events: [String!]!
    "Optional space-separated list of tokens to look for in the events"
    keywords: String
    "Unique name of the channel in its scope (null for backward compatibility, will be required in V5)"
    name: String
    "Project name"
    project: String!
    "Promotion name"
    promotion: String!
}

"Input type for the subscribePromotionRunToEvents mutation."
input SubscribePromotionRunToEventsInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Channel to send this event to"
    channel: String!
    "Channel configuration"
    channelConfig: JSON!
    "Optional template to use for the message"
    contentTemplate: String
    "List of events types to subscribe to"
    events: [String!]!
    "Optional space-separated list of tokens to look for in the events"
    keywords: String
    "Unique name of the channel in its scope (null for backward compatibility, will be required in V5)"
    name: String
    "Project name"
    project: String!
    "Promotion name"
    promotion: String!
}

"Input type for the subscribeToEvents mutation."
input SubscribeToEventsInput {
    "Channel to send this event to"
    channel: String!
    "Channel configuration"
    channelConfig: JSON!
    "Optional template to use for the message"
    contentTemplate: String
    "List of events types to subscribe to"
    events: [String!]!
    "Optional space-separated list of tokens to look for in the events"
    keywords: String
    "Unique name of the channel in its scope (null for backward compatibility, will be required in V5)"
    name: String
    "Target project entity (null for global events)"
    projectEntity: ProjectEntityIDInput
}

"Input type for the subscribeValidationRunToEvents mutation."
input SubscribeValidationRunToEventsInput {
    "Branch name"
    branch: String!
    "Build name"
    build: String!
    "Channel to send this event to"
    channel: String!
    "Channel configuration"
    channelConfig: JSON!
    "Optional template to use for the message"
    contentTemplate: String
    "List of events types to subscribe to"
    events: [String!]!
    "Optional space-separated list of tokens to look for in the events"
    keywords: String
    "Unique name of the channel in its scope (null for backward compatibility, will be required in V5)"
    name: String
    "Project name"
    project: String!
    "Run name"
    run: String!
    "Validation name"
    validation: String!
}

"Input type for the subscribeValidationStampToEvents mutation."
input SubscribeValidationStampToEventsInput {
    "Branch name"
    branch: String!
    "Channel to send this event to"
    channel: String!
    "Channel configuration"
    channelConfig: JSON!
    "Optional template to use for the message"
    contentTemplate: String
    "List of events types to subscribe to"
    events: [String!]!
    "Optional space-separated list of tokens to look for in the events"
    keywords: String
    "Unique name of the channel in its scope (null for backward compatibility, will be required in V5)"
    name: String
    "Project name"
    project: String!
    "Validation name"
    validation: String!
}

"Input type for the testConfiguration mutation."
input TestConfigurationInput {
    "data field"
    data: JSON!
    "name field"
    name: String!
    "type field"
    type: String!
}

"Input type for the testJenkinsConfiguration mutation."
input TestJenkinsConfigurationInput {
    "name field"
    name: String!
    "password field"
    password: String
    "url field"
    url: String!
    "user field"
    user: String
}

"Input type for the unfavouriteBranch mutation."
input UnfavouriteBranchInput {
    "Branch ID"
    id: Int!
}

"Input type for the unfavouriteProject mutation."
input UnfavouriteProjectInput {
    "Project ID"
    id: Int!
}

"Input type for the unlockAccount mutation."
input UnlockAccountInput {
    "ID of the account"
    id: Int!
}

"Input type for the unshareSCMFileChangeFilter mutation."
input UnshareSCMFileChangeFilterInput {
    "Name of the filter"
    name: String!
    "ID of the project"
    projectId: Int!
}

"Input type for the updateBuild mutation."
input UpdateBuildInput {
    "Creation timestamp to update"
    creation: LocalDateTime
    "ID of the build to update"
    id: Int!
}

"Input type for the updateConfiguration mutation."
input UpdateConfigurationInput {
    "data field"
    data: JSON!
    "name field"
    name: String!
    "type field"
    type: String!
}

"Input type for the updateJenkinsConfiguration mutation."
input UpdateJenkinsConfigurationInput {
    "name field"
    name: String!
    "password field"
    password: String
    "url field"
    url: String!
    "user field"
    user: String
}

"Input type for the updateProject mutation."
input UpdateProjectInput {
    "Project description (leave null to not change)"
    description: String
    "Project state (leave null to not change)"
    disabled: Boolean
    "Project ID"
    id: Int!
    "Project name (leave null to not change)"
    name: String
}

"Input type for the updatePromotionLevelById mutation."
input UpdatePromotionLevelByIdInput {
    "Promotion level description"
    description: String!
    "Promotion level ID"
    id: Int!
    "Promotion level name"
    name: String!
}

"Input type for the updateValidationStampById mutation."
input UpdateValidationStampByIdInput {
    "FQCN of the data type"
    dataType: String
    "Configuration of the data type"
    dataTypeConfig: JSON
    "Validation stamp description"
    description: String
    "Validation stamp ID"
    id: Int!
    "Validation stamp name"
    name: String
}

"Input type for the updateValidationStampFilter mutation."
input UpdateValidationStampFilterInput {
    "ID of the validation stamp filter"
    id: Int!
    "Validation stamp names"
    vsNames: [String!]!
}

"Input type for the validateBuildByIdWithCHML mutation."
input ValidateBuildByIdWithCHMLInput {
    "Number of critical issues"
    critical: Int
    "Description of the validation run"
    description: String
    "Number of high issues"
    high: Int
    "ID of the build"
    id: Int!
    "Number of low issues"
    low: Int
    "Number of medium issues"
    medium: Int
    "Optional run info to associated with this validation run"
    runInfo: RunInfoInput
    "Status of the validation run"
    status: String
    "Name of the validation stamp"
    validation: String!
}

"Input type for the validateBuildByIdWithMetrics mutation."
input ValidateBuildByIdWithMetricsInput {
    "Description of the validation run"
    description: String
    "ID of the build"
    id: Int!
    "List of metrics"
    metrics: [MetricsEntryInput!]!
    "Optional run info to associated with this validation run"
    runInfo: RunInfoInput
    "Status of the validation run"
    status: String
    "Name of the validation stamp"
    validation: String!
}

"Input type for the validateBuildByIdWithPercentage mutation."
input ValidateBuildByIdWithPercentageInput {
    "Description of the validation run"
    description: String
    "ID of the build"
    id: Int!
    "Optional run info to associated with this validation run"
    runInfo: RunInfoInput
    "Status of the validation run"
    status: String
    "Name of the validation stamp"
    validation: String!
    "Percentage"
    value: Int!
}

"Input type for the validateBuildByIdWithTests mutation."
input ValidateBuildByIdWithTestsInput {
    "Description of the validation run"
    description: String
    "Count of failed tests"
    failed: Int!
    "ID of the build"
    id: Int!
    "Count of passed tests"
    passed: Int!
    "Optional run info to associated with this validation run"
    runInfo: RunInfoInput
    "Count of skipped tests"
    skipped: Int!
    "Status of the validation run"
    status: String
    "Name of the validation stamp"
    validation: String!
}

"Input type for the validateBuildWithCHML mutation."
input ValidateBuildWithCHMLInput {
    "Name of the branch"
    branch: String!
    "Name of the build"
    build: String!
    "Number of critical issues"
    critical: Int
    "Description of the validation run"
    description: String
    "Number of high issues"
    high: Int
    "Number of low issues"
    low: Int
    "Number of medium issues"
    medium: Int
    "Name of the project"
    project: String!
    "Optional run info to associated with this validation run"
    runInfo: RunInfoInput
    "Status of the validation run"
    status: String
    "Name of the validation stamp"
    validation: String!
}

"Input type for the validateBuildWithMetrics mutation."
input ValidateBuildWithMetricsInput {
    "Name of the branch"
    branch: String!
    "Name of the build"
    build: String!
    "Description of the validation run"
    description: String
    "List of metrics"
    metrics: [MetricsEntryInput!]!
    "Name of the project"
    project: String!
    "Optional run info to associated with this validation run"
    runInfo: RunInfoInput
    "Status of the validation run"
    status: String
    "Name of the validation stamp"
    validation: String!
}

"Input type for the validateBuildWithPercentage mutation."
input ValidateBuildWithPercentageInput {
    "Name of the branch"
    branch: String!
    "Name of the build"
    build: String!
    "Description of the validation run"
    description: String
    "Name of the project"
    project: String!
    "Optional run info to associated with this validation run"
    runInfo: RunInfoInput
    "Status of the validation run"
    status: String
    "Name of the validation stamp"
    validation: String!
    "Percentage"
    value: Int!
}

"Input type for the validateBuildWithTests mutation."
input ValidateBuildWithTestsInput {
    "Name of the branch"
    branch: String!
    "Name of the build"
    build: String!
    "Description of the validation run"
    description: String
    "Count of failed tests"
    failed: Int!
    "Count of passed tests"
    passed: Int!
    "Name of the project"
    project: String!
    "Optional run info to associated with this validation run"
    runInfo: RunInfoInput
    "Count of skipped tests"
    skipped: Int!
    "Status of the validation run"
    status: String
    "Name of the validation stamp"
    validation: String!
}

"Input type for the validateJsonWorkflow mutation."
input ValidateJsonWorkflowInput {
    "workflow field"
    workflow: JSON!
}

input WebhookExchangeFilter {
    "Payload timestamp after this"
    payloadAfter: LocalDateTime
    "Payload timestamp before this"
    payloadBefore: LocalDateTime
    "Keyword in the payload"
    payloadKeyword: String
    "Type of payload which was sent (event, ...)"
    payloadType: String
    "HTTP Status Code of the response"
    responseCode: Int
    "Keyword in the response"
    responseKeyword: String
    "Name of the webhook (regular expression)"
    webhook: String
}

input WidgetInstanceInput {
    config: JSON!
    key: String!
    layout: WidgetLayoutInput!
    uuid: String
}

input WidgetLayoutInput {
    h: Int!
    w: Int!
    x: Int!
    y: Int!
}
