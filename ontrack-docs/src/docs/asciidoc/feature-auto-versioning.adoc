[[auto-versioning]]
=== Auto versioning on promotion

[[auto-versioning-pr]]
==== Pull requests

After a branch is created to hold the new version, after this branch has been optionally post-processed, Ontrack will create a pull request from this branch to the initial target branch.

The `autoApproval` <<auto-versioning-config,branch configuration property>> (set to `true` by default) is used by Ontrack to check if created pull requests must managed at all.

If set to `false`, Ontrack will just create a pull request and stop here.

If set to `true`, the fate of the pull request depends on the _auto approval mode_ which has been set in the <<auto-versioning-config,branch configuration>>:

|===
|Auto approval mode |Description |Pro's |Con's

|`CLIENT`
a|This is the default behaviour. Ontrack takes the ownership of the pull request lifecycle:

* PR is approved automatically
* Ontrack waits for the PR to become mergeable
* Ontrack merges the PR
|Full visibility on the PR lifecycle within Ontrack
|This creates additional load on Ontrack

|`SCM`
a|Ontrack relies on the SCM (GitHub for example) for the lifecycle of the pull request, in a "fire and forget" mode:

* PR is approved automatically
* PR is set for auto merge
* In the background, the PR will be merged automatically once all the conditions are met, but Ontrack does not follow that up
|Less load on Ontrack since the PR lifecycle is fully managed by the SCM
|Less visibility on the PR lifecycle from Ontrack

|===

[[auto-versioning-pr-config]]
===== General configuration

Both modes, `CLIENT` and `SCM`, need the SCM configuration used by Ontrack to have additional attributes.

[[auto-versioning-pr-config-github]]
====== General configuration for GitHub

The GitHub configuration used by the Ontrack project must have its `autoMergeToken` attribute set to a GitHub Personal Access Token with the following permissions:

* `repo`

and the corresponding user must have at least the `Triage` role on the target repositories.

[IMPORTANT]
====
This `autoMergeToken` must be linked to a user _which is not_ the user used by the GitHub configuration.
It's because a user cannot approve their own pull requests.
====

[[auto-versioning-pr-client]]
===== `CLIENT` mode

No specific configuration is needed for the `CLIENT` mode.

[[auto-versioning-pr-scm]]
===== `SCM` mode

There is some configuration to be done at SCM level.

[[auto-versioning-pr-scm-github]]
===== `SCM` mode for GitHub

The target repository, the one defining the project being auto-versioned, must have the following settings:

* the `Allow auto-merge` feature must be enabled in the repository

[[auto-versioning-check]]
==== Auto versioning checks

While auto versioning is configured to automatically upgrade branches upon the promotion of some other projects, it's also possible to use this very configuration to check if a given build is up-to-date or not with the latest dependencies.

By calling the `POST /extension/auto-versioning/build/{buildId}/check` end point, where `buildId` is the ID of the build to check, you create a <<model,validation run>> on this build:

* it'll be PASSED if the dependencies are up-to-date
* FAILED otherwise

The name of the validation stamp is defined by the `validationStamp` parameter in the <<auto-versioning-config,configuration of the branch>>:

* if defined, will use this name
* if set to `auto`, the validation stamp name will be `auto-versioning-<project>`, with `<project>` being the name of the source project
* if not set, no validation is created

[NOTE]
====
You should seldom call this endpoint directly and rather use one of the existing integrations:

* <<integration-github-ingestion,GitHub ingestion>>
* <<feeding-jenkins-library,the Jenkins pipeline library>>
====

[[auto-versioning-audit]]
==== Audit logs

All auto versioning processes and all their statuses are recorded in an audit log, which can be accessed using dedicated pages (and the <<integration-graphql,GraphQL API>>).

The auto versioning audit can be accessed:

* from the _Auto versioning audit_ user menu, for all projects and branches
* from the _Tools > Auto versioning audit (target)_ from a project page when the project is considered a _target_ of the auto versioning
* from the _Tools > Auto versioning audit (source)_ from a project page when the project is considered a _source_ of the auto versioning
* from the _Tools > Auto versioning audit_ from a branch page when the branch is targeted by the auto versioning

All these pages are similar and show:

* a form to filter the audit log entries
* a paginated list of audit log entries

Each log entry contains the following information:

* target project and branch (only available in global & project views)
* source project
* version being updated
* <<auto-versioning-post-processing,post-processing>> ID if any
* <<auto-versioning-pr,auto approval mode>> if any
* running flag - is the auto versioning process still running?
* current state of the auto versioning process
* link to the <<auto-versioning-pr,PR>> if any
* timestamp of the latest state
* duration of the process until the latest state
* a button to show more details about the process

When the details are shown, the following information is available:

* the history of the states of the process
* a JSON representation of the auto versioning order

[[auto-versioning-audit-cleanup]]
===== Audit cleanup

To avoid accumulating audit log entries forever, a cleanup job is run every day to remove obsolete entries.
The behaviour of the cleanup is controlled through the <<auto-versioning-settings,global settings>>.

[[auto-versioning-audit-metrics]]
===== Audit metrics

The following operational metrics is exposed as a gauge by the Ontrack auto versioning feature:

* `ontrack_extension_auto_versioning_audit_state`
* tags: `state` auto versioning state
* count of auto versioning entries having this state

[[auto-versioning-notifications]]
==== Notifications

The auto versioning feature integrates with the <<notifications>> framework by emitting several events you can subscribe to:

* `auto-versioning-success` - whenever an auto versioning process completes
* `auto-versioning-error` - whenever an auto versioning process finishes with an error
* `auto-versioning-pr-merge-timeout-error` - whenever an auto versioning process cannot merge a pull request because of a timeout on its merge condition (only when `autoApprovalMode` is set to `CLIENT` - see <<auto-versioning-pr>>)

[[auto-versioning-cancellations]]
==== Cancellations

By default, when auto versioning requests pile up for a given source and target, all the intermediary processing requests are cancelled.

For example, given the following scenario, for a given source project and a given target branch:

* (1) auto versioning to version 1.0.1
* auto versioning to version 1.0.2 while (1) is still processed
* auto versioning to version 1.0.3 while (1) is still processed
* auto versioning to version 1.0.4 while (1) is finished

In this scenario, the processing of 1.0.1 and 1.0.4 will have been processed and completed while 1.0.2 and 1.0.3 would have been cancelled.

[NOTE]
====
The auto cancellation can be disabled by setting the `ontrack.extension.auto-versioning.queue.cancelling` <<configuration-properties-auto-versioning,configuration property>> to `false`.
====

[[auto-versioning-metrics]]
==== Metrics

The following operational metrics are exposed by Ontrack, which allow to track the load of the auto versioning processes:

|===
|Metric |Tags |Description |Type

|ontrack_extension_auto_versioning_queue_produced_count
a|
* `routingKey` - RabbitMQ routing key used for the processing
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Number of processing orders queued
| Count

|ontrack_extension_auto_versioning_queue_consumed_count
a|
* `queue` - RabbitMQ queue used for the processing
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Number of processing orders queued
| Count

|ontrack_extension_auto_versioning_processing_completed_count
a|
* `outcome` - Result of the processing, one of `CREATED`, `SAME_VERSION` or `NO_CONFIG`
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Number of processing orders queued
| Count

|ontrack_extension_auto_versioning_processing_error_count
| None
| Number of processing orders stopped because of an error
| Count

|ontrack_extension_auto_versioning_processing_time
a|
* `queue` - RabbitMQ queue used for the processing
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Time it took to process an order
| Timer

|ontrack_extension_auto_versioning_post_processing_started_count
a|
* `postProcessing` - ID of the post-processor (`github`, ...)
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Number of post-processing having started
| Count

|ontrack_extension_auto_versioning_post_processing_success_count
a|
* `postProcessing` - ID of the post-processor (`github`, ...)
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Number of post-processing having completed with success
| Count

|ontrack_extension_auto_versioning_post_processing_error_count
a|
* `postProcessing` - ID of the post-processor (`github`, ...)
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Number of post-processing having completed with an error
| Count

|ontrack_extension_auto_versioning_post_processing_time
a|
* `postProcessing` - ID of the post-processor (`github`, ...)
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Time it took to complete the post-processing
| Timer
|===

