[[auto-versioning]]
=== Auto versioning on promotion

Beside collecting data about the performance of your delivery, Ontrack can in turn use this information to drive other automation processes.

One of these processes that Ontrack can drive is the "auto promotion on promotion", which allows the propagation of versions from one repository to others using quality gates based on Ontrack <<model,promotions>>.

Let's imagine a project `parent` which has a dependency on a `module` expressed through a version property somewhere in a file.

Ideally, whenever the `module` has a new version is a given range, we want this version to be used automatically by the `parent`.

Manually, we can do this of course:

* we update the version in the `parent`
* we perform any needed post-processing like a resolution of locks
* we commit and push the change.
Voil√†.

If we put extra automation in the mix, you can define a perfectly valid auto versioning process.

This becomes more complex whenever having a new version of the `module` is not enough of a criteria to have it used.
This may be a release which has not been qualified yet by extra quality processes (long running ones maybe).

That's where the concept of <<model,promotion>> in Ontrack can play a very important rule:

* the `module` is promoted
* this starts the following process:
* Ontrack creates a pull request for the `parent` where the version of the `module` has been changed to the one being promoted
* any required post processing is performed on this PR
* when the PR is ready to be merged (with all its controls), it's merged automatically

Result:

* versions are propagated automatically only when "promotion gates" are opened

This is valid from one module to a project, and can be easily extended to a full tree of dependent modules.

The diagram below shows how this works:

image::images/auto-versioning-overview.png[alt="Auto versioning overview"]

[[auto-versioning-not]]
==== When not to use auto versioning

While auto versioning is pretty easy to put in place, it should not be used where traditional dependency management based on locks can be used instead for simple code libraries.

Auto versioning on promotion is however particularly well suited to deal with situations like:

* modular monoliths
* GitOps repositories with fixed versions

[[auto-versioning-settings]]
==== General configuration

Auto versioning is not enabled by default.
This can be done in the _Settings > Auto Versioning_.

Three parameters are available:

* _Enabled_ - check to enable auto versioning
* _Audit retention_ - maximum number of seconds to keep non-running audit entries for auto versioning requests (see <<auto-versioning-audit>> for more information)
* _Audit cleanup_ - maximum number of seconds to keep audit entries for auto versioning requests.
This time is counted after the retention period for the non-running entries (see <<auto-versioning-audit>> for more information)

[NOTE]
====
These settings can also be <<casc,configured as code>>.
For example using:

[source,yaml]
----
ontrack:
  config:
    settings:
      auto-versioning:
        enabled: true
        auditRetentionDuration: 14d
        auditCleanupDuration: 90d
----
====

[[auto-versioning-queue]]
===== Queue configuration

Ontrack uses queues in RabbitMQ to schedule and process auto versioning events.

By default, one and only one queue, called `auto-versioning.default.1` is available.
When the load becomes too important, you can use two mechanisms to scale the auto versioning:

* increase the number of default queues.
You can set the `ontrack.extension.auto-versioning.queue.scale` <<configuration-properties-auto-versioning,configuration property>> to a higher number than 1

* create dedicated queues for some projects, see below.

[[auto-versioning-queue-dedicated]]
====== Dedicated queues

For a given Ontrack <<model,project>>, you can setup a dedicated queue, which will be used exclusively for this project (whereas the default queues are shared between all projects).

Use the `ontrack.extension.auto-versioning.queue.projects` <<configuration-properties-auto-versioning,configuration property>> to defined a comma-separated list of projects which must have dedicated queues.
For example, using environment variables:

[source,bash]
----
ONTRACK_EXTENSION_AUTO_VERSIONING_QUEUE_PROJECTS=project-one,project-two
----

[[auto-versioning-config]]
==== Branch configuration

The configuration of a branch for the auto versioning of its dependencies can be done using:

* the <<integration-graphql,GraphQL>> `setAutoVersioningConfig` or `setAutoVersioningConfigByName` mutation
* <<auto-versioning-config-integrations-jenkins,Jenkins Ontrack pipeline library>> for Jenkins pipelines
* <<auto-versioning-config-integrations-github,GitHub>> for the <<integration-github-ingestion,GitHub ingestion>>

All these integrations rely on setting up a version of the _auto versioning model_ for a branch which contains a list of _auto versioning source configurations_.
This can be represented as YAML using:

[source,yaml]
----
# List of configurations
configurations:
    # Project to watch
  - sourceProject: String
    # Name of the branch to take into account for the dependency. Several branches can be selected using
    # a regular expression. If several branches are eligible, only the latest version
    # can be used, based on inverted order of semantic versioning. Branches which
    # do not comply with semantic versioning are discarded.
    #
    # See <Targeting a series of branches> for more information.
    #
    # Alternatively, the sourceBranch parameter can be set to "&<expression>" where `<expression>` is
    # used to detect the valid source branch from the source project.
    #
    # See <Branch expressions> below for more information.
    sourceBranch: String
    # Promotion to watch
    sourcePromotion: String
    # Comma-separated list of file to update with the new version
    targetPath: String
    # Regex to use in the target file to identify the line to replace with the new version.
    # It must have a capturing group in position 1, which will be replaced by the actual version.
    # For example:
    # `coreVersion = (.*)`
    targetRegex: String?
    # Can be used instead of the `regex` when we consider
    # property files. In the sample above, the target property can be set to `coreVersion`
    targetProperty: String?
    # When `property` is used, `propertyRegex` can define a regular expression to extract / update
    # the actual version from/into the property value. The regular expression must contain at least
    # one capturing group, holding the actual version value. This `propertyRegex` is useful for cases
    # when the version is part of a bigger string, for example, for a Docker image qualified name.
    # Example:
    # When targetProperty = "repository/image:tag"
    # to target tag, you can use targetPropertyRegex: "repository\/image\:(.*)"
    targetPropertyRegex: String
    # when `property` is set, defines how the target file
    # must be handled. For example, it could be a dependency notation in a NPM `package.json` file, or
    # a property entry in Java properties file for Gradle. For NPM, use `npm`. For Java properties,
    # use `properties`. When not specified, it defaults to `properties`. Other types are available,
    # see <Target files types>
    targetPropertyType: String?
    # Check if the PR must be approved automatically or not (`true` by default)
    autoApproval: Boolean?,
    # Prefix to use for the upgrade branch in Git, defaults to `feature/auto-upgrade-<project>-<version>-<branch>`.
    # If set manually, the `<project>` and `<version>` tokens can be used to be replaced respectively
    # by the dependency project (the `project` above) and the actual version.
    #
    # The `<branch>` token is replaced by the MD5 digest of the target branch.
    #
    # Only the `<version>` token is required.
    #
    # Starting from 4.7.30 & 4.8.14, the `<branch>` token is not required but will be added (with the `-<branch>` suffix) if not present.
    upgradeBranchPattern: String?
    # Type of post-processing to launch after the version has been updated
    postProcessing: String?
    # Configuration of the post processing
    postProcessingConfig: JsonNode?
    # See "Auto versioning checks"
    validationStamp: String?
    # Auto approval mode
    autoApprovalMode: CLIENT | SCM
    # Build link creation when running the checks. True by default.
    buildLinkCreation: Boolean?
    # Qualifier to use for the build links
    qualifier: String?
    # How must the version to use be computed from the source build?
    # See "Version source" below
    versionSource: String?
    # Additional paths to change.
    # See "Additional paths" below
    additionalPaths:
      - # Comma-separated list of file to update with the new version
        path: String
        # Regex to use in the target file to identify the line to replace with the new version.
        # The first matching group must be the version.")
        regex: String?
        # Optional replacement for the regex, using only a property name
        property: String?
        # Optional regex to use on the property value
        propertyRegex: String?
        # When property is defined, defines the type of property (defaults to Java properties
        # file, but could be NPM, etc.)
        propertyType: String?
        # Source of the version for the build. By default, uses the build label is the source project
        # is configured so, or the build name itself. This allows the customization of this behavior.
        versionSource: String?
----

[NOTE]
====
The auto versioning model for a branch, if set, is shown on the branch page.
====

[[auto-versioning-config-branch]]
===== Targeting a series of branches

In this scenario, the parent wants to be notified of a promotion on a series of branches, and Ontrack triggers the upgrade _only_ if the promotion has occurred on the _latest_ branch.

Setup:

* set the `branch` parameter to a regular expression on the Git branch, for example: `release\/.\..*`

How does it work?

* when a promotion occurs on the desired level, Ontrack gets the list of branches for the dependency, orders them by descending version, filter them using the regular version, and triggers an upgrade only if the promoted branch is the first in this list (latest in terms of version)

Pro's:

* simple
* allows auto upgrades fairly easily

Con's:

* the dependency must really take care of a strong semantic versioning

[[auto-versioning-config-branch-expression]]
===== Branch expressions

The `sourceBranch` parameter can be set to `&<expression>` where `<expression>` is an expression used to detect the source branch on the source project for a branch eligible for auto versioning.

Supported values are:

====== `&regex`

By using:

[source,yaml]
----
sourceBranch: "&regex:<regex>"
----

this is equivalent to the default behaviour:

[source,yaml]
----
sourceBranch: "<regex>"
----

====== `&same`

The source branch must have the exact same name as the target branch.

Example: if you have a branch `release-1.24` on a parent project `P` and you want to get updates from a `dependency` project only for the same branch, `release-1.24`, you can use:

[source,yaml]
----
sourceBranch: "&same"
----

====== `&most-recent`

Two branches (`release/1.1` & `release/1.2`) are available for a project which is dependency of an auto versioned parent project with the following default branch source:

[source,yaml]
----
branch: 'release\/1\..*'
----

In this scenario, no promotion has been granted yet in `release 1.2` of the dependency.

When 1.1 is promoted, Ontrack identifies a branch on the parent project to be a potential candidate for auto versioning.

This branch is configured to accept only the latest `release/1.*` branch, which is - now - the `release/1.2`.

Therefore, a 1.1 promotion is no longer eligible as soon as the 1.2 branch was created (and registered in Ontrack).

What exactly do we want to achieve? In this scenario, we always want the version promoted in 1.1 as long as there is none in 1.2. Let's imagine we promote a 1.1 while 1.2 was already promoted, what then? How do we protect ourselves?

The idea is to accept a promotion as long as there is no such a promotion in later branches.

* a 1.1 is promoted and there is no such promotion in more recent branches (1.2, etc.) - we accept it
* a 1.1 is promoted and there is already such a promotion in a more recent branch (1.2 for example) - we reject it

To implement this strategy, we have to use:

[source,yaml]
----
branch: '&most-recent:release\/1\..*'
----

====== `&same-release`

On the same model as the "&same" `sourceBranch` parameter, there is the possibility to get a "&same-release" branch source.

This is to be used in cases where the dependency and its parent follow the same branch policy at `release/` branch level, but only for a limited number of levels.

For example, a parent has release branches like release/1.24.10, with a dependency using on release/1.24.15. We want release/1.x.y to always depend on the latest release/1.x.z branch (using 1. as a common prefix).

One way to do this is to use: `sourceBranch: "release/1.24.*"`  but this would force you to always update the source branch parameter for every branch:

* release/1.24.* in release/1.24.x branch
* release/1.25.* in release/1.25.x branch
* etc.

A better way is to use, in this scenario:

[source,yaml]
----
sourceBranch: "&same-release:2"
----

This means:

* if you're on a release/x.y.z branch, use release/x.y.* for the latest branch
* for any other branch (main) for example, we use the same branch

[NOTE]
====
Note that `:2` means: take the first two numbers of the version of the release branch. By default, it'd be `:1` and can be omitted: `sourceBranch: "&same-release"`.
====

[[auto-versioning-config-version-source]]
===== Version source

By default, the version to use in the target project is computed directly from the <<model,build>> which has been promoted.

The default behavior is:

* if the source project is configured to use the labels for the builds ("Build name display" property), the label (or release, or version) of the build is used. If this label is not present, the auto versioning request will be rejected
* if the source project is not configured, the build name is taken as the version

This version computation can be adapted using the <<auto-versioning-config,`versionSource`>> configuration parameter.

The different options for this parameter are:

* `default` - uses the default behavior described above
* `name` - uses the name of the build, regardless of the source project configuration
* `labelOnly` - uses the label attached to the build, regardless of the source project configuration. If there is no label, the auto versioning request is rejected
* `metaInfo/<category>/<name>` or `metaInfo/<name>` - the version is the value of a meta information item of the request category (optional) or name. If so such meta information is found, the auto versioning request is rejected.

[[auto-versioning-additional-paths]]
===== Additional paths

The `additionalPaths` configuration property allows the specification of additional paths to update
instead of just the main one.

[NOTE]
====
This can somehow be considered as a form of <<auto-versioning-post-processing,post-processing>> but
without the need to call an external service.
====

Example:

[source,yaml]
----
configurations:
  - # ...
    targetPath: "gradle.properties"
    targetProperty: "one-version"
    additionalPaths:
      - path: manifest.toml
        property: global.oneVersion
        propertyType: toml
        versionSource: metaInfo/rpmVersion
----

In this example, we want the auto-versioning to:

* update the `one-version` property of the `gradle.properties` file using the version of the build having been promoted
* update the `global.oneVersion` property of the `manifest.toml` file, but this time using the `rpmVersion` meta-information of the build having been promoted

Both changes will be part of the same PR.

<<auto-versioning-post-processing,Post-processing>> is still possible and would be run after all changes have been applied first (default path & additional paths).

[[auto-versioning-config-type]]
===== Target files types

Auto versioning, in the end, works by updating a _target file_, designed in the configuration by the `path` property.
Typically, it'll be a `gradle.properties` or a `package.json` file but it could be anything else.

A regular expression (`regex` parameter) can be used to identify the change.
This expression is used to 1) identify the current version 2) replace the current version by a new one.
In order for this to work, the regular expression must:

* match the whole target line in the target file
* have a capturing group in position 1 identifying the version to read or replace

It is also possible to use a higher level of file type, by specifying a _propertyName_ and optionally a _propertyType_.

The _propertyName_ designates a _property_ in the target file and the _propertyType_ designates the type of the file to replace.
Two types are currently supported:

* `properties` (default) - Java properties file, typically used for a `gradle.properties` file
* `npm` - NPM package file, typically used for `package.json`
* `maven` - <<auto-versioning-config-type-maven,Maven POM file>>
* `yaml` - YAML file, see <<auto-versioning-config-type-yaml>>
* `toml` - TOML file, see <<auto-versioning-config-type-toml>>

See the <<auto-versioning-config-examples,examples section>> for their usage.

[[auto-versioning-config-type-maven]]
====== Maven POM file

For the `maven` type, the file to transform is a Maven `pom.xml` file. The `property` is _required_ to be one of the `<properties>` elements of the file.

For example, given the following POM:

[source,xml]
----
<project>
    <properties>
        <dep.version>1.10</dep.version>
        <ontrack.version>4.4.10</ontrack.version>
    </properties>
</project>
----

we can refer to the `ontrack.version` using the following auto versioning configuration:

[source,yaml]
----
configurations:
  # ...
  targetPath: pom.xml
  propertyType: maven
  property: ontrack.version
----

[[auto-versioning-config-type-yaml]]
====== YAML files

When `propertyType` is set to `yaml`, `property` is expected to define a path inside the YAML file.

This path is expressed using the https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#expressions[Spring Expression Language].

For example, given the following YAML file (a deployment fragment in Kubernetes):

[source,yaml]
----
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  template:
    spec:
      containers:
      - name: component
        image: repo/component:0.1.1
----

In order to get to the `repo/component:0.1.1` value, the path to set will be:

[source]
----
#root.^[kind == 'Deployment' and metadata.name == 'my-app'].spec.template.spec.containers.^[name == 'component'].image
----

See the https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#expressions[Spring Expression Language] reference for a complete reference but this expression already illustrates some key points:

* `#root` refers to the "root object", used to evaluate the expression, in our case, the list of YAML "documents", separated by `---`
* `.^[<filter>]` is an operator for a list, evaluating the given filter for each element until one element is found.
Only the found element is returned.
* `.name` returns the value of the `name` property on an object
* literal strings are using single quotes, for example: `'Deployment'`

If `property` is set to the expression mentioned above, the value being returned will be
`repo/component:0.1.1`.
However, we want to use `0.1.1`only.

For this purpose, you need to specify also the `propertyRegex` and set it, for this example to:

[source]
----
^repo\/component:(.*)$
----

[[auto-versioning-config-type-tomml]]
====== TOML files


When `propertyType` is set to `yaml`, `property` is expected to define a path inside the YAML file.

For example, given the following TOML file:

[source,toml]
----
[images]
myVersion = "2.0.0"
----

To update the `myVersion` property in the `images` table, one can set the auto versioning `property` to `images.myVersion`.

[WARNING]
====
The support of TOML in the Ontrack auto versioning uses the https://github.com/valderman/4koma[4koma] library and this comes with some caveats:

* comments are not supported and will be _stripped_ from the file after the auto versioning request has been processed
* only basic expressions like `a.b.c` are supported. Arrays and other structures are not supported.

Request for help: if you know of a better TOML Java/Kotlin library which would support comments, updates of the TOML structure, more complex queries, please let me know.
====

[[auto-versioning-config-integrations]]
===== Integrations

[[auto-versioning-config-integrations-jenkins]]
====== Jenkins pipeline

By using the https://github.com/nemerosa/ontrack-jenkins-cli-pipeline[Jenkins Ontrack pipeline library], you can setup the auto versioning configuration for a branch.

For example:

[source,groovy]
----
ontrackCliAutoVersioning {
    branch "main"
    yaml "auto-versioning.yml"
}
----

where `auto-versioning.yml` is a file in the repository containing for example:

[source,yaml]
----
dependencies:
  - project: my-library
    branch: release-1.3"
    promotion: IRON
    path: gradle.properties
    property: my-version
    postProcessing: jenkins
    postProcessingConfig:
        dockerImage  : openjdk:8
        dockerCommand: ./gradlew clean
----

[[auto-versioning-config-integrations-github]]
====== GitHub Actions

TBD

https://github.com/nemerosa/ontrack-github-ingestion-auto-versioning[`ontrack-github-ingestion-auto-versioning`] GitHub action which sets up auto versioning for the <<integration-github-ingestion,GitHub ingestion>>

[[auto-versioning-config-examples]]
===== Examples

[[auto-versioning-config-examples-gradle]]
====== Gradle update for last release

To automatically update the `dependencyVersion` in `gradle.properties` to the latest version
`1.*` of the project `dependency` when it is promoted to `GOLD`:

* project: `dependency`
* branch: `release/1\..*`
* promotion: `GOLD`
* path: `gradle.properties`
* propertyName: `dependencyVersion`
* propertyType: `properties` (or nothing, it's a default)
* postProcessing: `...`
* postProcessingConfig:
** `dockerImage`: `openjdk/8`
** `dockerCommand`: `./gradlew resolveAndLockAll --write-locks`

[[auto-versioning-config-examples-npm]]
====== NPM update for last release

To automatically update the `@test/module` in `package.json` to the latest version
`1.*` of the project `dependency` when it is promoted to `GOLD`:

* project: `dependency`
* branch: `release/1\..*`
* promotion: `GOLD`
* path: `package.json`
* propertyName: `@test/module`
* propertyType: `npm`
* postProcessing: `...`
* postProcessingConfig:
** `dockerImage`: `node:jessie`
** `dockerCommand`: `npm -i`

[[auto-versioning-post-processing]]
==== Post processing

In some cases, it's not enough to have only a version being updated into one file.
Some additional post-processing may be needed.

For example, if using Gradle or NPM dependency locks, after the version is updated, you'd need to resolve and write the new dependency locks.

The Auto Versioning feature allows you to configure this post-processing.

In the <<auto-versioning-config,branch configuration>>, you can set two properties for each source configuration:

* `postProcessing` - ID of the post-processing mechanism
* `postProcessingConfig` - configuration for the post-processing mechanism

As of now, only two post-processing mechanisms are supported.
See the sections below for their respective configurations.

[[auto-versioning-post-processing-github]]
===== GitHub post-processing

You can delegate the post-processing to a GitHub workflow.

There is a global configuration and there are a specific configuration at branch level (in the `postProcessingConfig` <<auto-versioning-config,property>>).

For the global configuration, you can go to _Settings > GitHub Auto Versioning Post Processing_ and define the following attributes:

* _Configuration_ - Default GitHub configuration to use for the connection
* _Repository_ - Default repository (like `owner/repository`) containing the workflow to run
* _Workflow_ - Name of the workflow containing the post-processing (like `post-processing.yml`)
* _Branch_ - Branch to launch for the workflow
* _Retries_ - The amount of times we check for successful scheduling and completion of the post-processing job
* _Retry interval_ - The time (in seconds) between two checks for successful scheduling and completion of the post-processing job

The `postProcessingConfig` <<auto-versioning-config,property>> at branch level must contain the following parameters:

* `dockerImage` - (required) This image defines the environment for the upgrade command to run in
* `dockerCommand` - (required) Command to run in the Docker container
* `commitMessage`  - (required) Commit message to use to commit and push the result of the post-processing
* `version` - (required) the version which is upgraded to
* `config` - GitHub configuration to use for the connection (optional, using defaults if not specified)
* `workflow` - If defined, name of the workflow in _this_ repository containing the post-processing (like `post-processing.yml`)

The following parameters are <<appendix-templating,templated>>:

* `dockerImage`
* `dockerCommand`
* `commitMessage`

The `workflow` branch configuration property can be used to set the post-processing workflow to one in the very branch targeted by the auto versioning process.
This would override the global settings.

Example of a simple configuration relying on the global settings:

[source,yaml]
----
postProcessing: github
postProcessingConfig:
  dockerImage: openjdk:11
  dockerCommand: ./gradlew dependencies --write-locks
  commitMessage: "Resolving the dependency locks"
----

The code below shows an example of a workflow suitable for post-processing:

[source,yaml]
.post-processing.yml
----
name: post-processing

on:
  # Manual trigger only
  workflow_dispatch:
    inputs:
      id:
        description: "Unique client ID"
        required: true
        type: string
      repository:
        description: "Repository to process, like 'nemerosa/ontrack'"
        required: true
        type: string
      upgrade_branch:
        description: "Branch containing the changes to process"
        required: true
        type: string
      docker_image:
        description: "This image defines the environment for the upgrade command to run in"
        required: true
        type: string
      docker_command:
        description: "Command to run in the Docker container"
        required: true
        type: string
      commit_message:
        description: "Commit message to use to commit and push the result of the post processing"
        required: true
        type: string

jobs:
  processing:
    runs-on: ubuntu-latest
    container:
      image: ${{ inputs.docker_image }}
    steps:
      - name: logging
        run: |
          echo id = ${{ inputs.id }} > inputs.properties
          echo repository = ${{ inputs.repository }} >> inputs.properties
          echo upgrade_branch = ${{ inputs.upgrade_branch }} >> inputs.properties
          echo docker_image = ${{ inputs.docker_image }} >> inputs.properties
          echo docker_command = ${{ inputs.docker_command }} >> inputs.properties
          echo commit_message = ${{ inputs.commit_message }} >> inputs.properties
      - name: artifact
        uses: actions/upload-artifact@v3
        with:
          name: inputs-${{ inputs.id }}.properties
          path: inputs.properties
          if-no-files-found: error
      - name: checkout
        uses: actions/checkout@v3
        with:
          repository: ${{ inputs.repository }}
          ref: ${{ inputs.upgrade_branch }}
          token: ${{ secrets.ONTRACK_AUTO_VERSIONING_POST_PROCESSING }}
      - name: processing
        run: ${{ inputs.docker_command }}
      - name: publication
        run: |
          git config --local user.email "<some email>"
          git config --local user.name "<some name>"
          git add --all
          git commit -m "${{ inputs.commit_message }}"
          git push origin "${{ inputs.upgrade_branch }}"
----

[IMPORTANT]
====
* all mentioned `inputs` are required by Ontrack
* the `id` input and its output into a local file artifact is required by Ontrack to follow up on the workflow process (the GitHub API does not allow to explicitly retrieve a workflow run when it's launched) - see the generation & archiving of the `inputs.properties` file in the example above.
* commit & pushing the changed files is required for the post-processing to be considered complete

The rest of the workflow can be adapted at will.
====

[[auto-versioning-post-processing-jenkins]]
===== Jenkins post-processing

You can delegate the post-processing to a Jenkins job.

There is a global configuration and there are a specific configuration at branch level (in the `postProcessingConfig` <<auto-versioning-config,property>>).

For the global configuration, you can go to _Settings > Jenkins Auto Versioning Processing_ and define the following attributes:

* _Configuration_ - default Jenkins configuration to use for the connection
* _Job_ - default path to the job to launch for the post-processing, relative to the Jenkins root URL (note that `/job/` separators can be omitted)
* _Retries_ - the amount of times we check for successful scheduling and completion of the post-processing job
* _Retry interval_ - the time (in seconds) between two checks for successful scheduling and completion of the post-processing job

The `postProcessingConfig` <<auto-versioning-config,property>> at branch level must contain the following parameters:

|===
|Parameter |Default value |Description

|`dockerImage`
|_Required_
|Docker image defining the environment

|`dockerCommand`
|_Required_
|Command to run in the working copy inside the Docker container

|`commitMessage`
|_Required_
|Commit message for the post processed files. If not defined, a default message will be provided

|`config`
|_Optional_
| Jenkins configuration to use for the connection (optional, using defaults if not specified)

|`job`
|_Optional_
| Path to the job to launch for the post processing (optional, using defaults if not specified)

|`credentials`
|_Optional_
|List of credentials to inject in the command (see below)
|===

Example of such a configuration:

[source,yaml]
----
postProcessing: jenkins
postProcessingConfig:
  dockerImage: openjdk:11
  dockerCommand: ./gradlew dependencies --write-locks
  commitMessage: "Resolving the dependency locks"
----

The Jenkins job must accept the following parameters:

|===
|Parameter |Description

|`REPOSITORY_URI`
|Git URI of the repository to upgrade

|`DOCKER_IMAGE`
|This image defines the environment for the upgrade command to run in.

|`DOCKER_COMMAND`
|Command to perform the upgrade.

|`COMMIT_MESSAGE`
|Commit message to use to commit and push the upgrade.

|`UPGRADE_BRANCH`
|Branch containing the code to upgrade.

|`CREDENTIALS`
|Pipe (\|) separated list of credential entries to pass to the command.

|`VERSION`
|The version which is upgraded to

|===

The Jenkins job is responsible to:

* running a Docker container based on the `DOCKER_IMAGE` image
* inject any credentials defined by `CREDENTIALS` parameter
* checkout the `UPGRADE_BRANCH` branch of the repository at `REPOSITORY_URI` inside the container
* run the `DOCKER_COMMAND` command inside the container
* commit and push any change using the `COMMIT_MESSAGE` message to the `UPGRADE_BRANCH` branch

[[auto-versioning-pr]]
==== Pull requests

After a branch is created to hold the new version, after this branch has been optionally post-processed, Ontrack will create a pull request from this branch to the initial target branch.

The `autoApproval` <<auto-versioning-config,branch configuration property>> (set to `true` by default) is used by Ontrack to check if created pull requests must managed at all.

If set to `false`, Ontrack will just create a pull request and stop here.

If set to `true`, the fate of the pull request depends on the _auto approval mode_ which has been set in the <<auto-versioning-config,branch configuration>>:

|===
|Auto approval mode |Description |Pro's |Con's

|`CLIENT`
a|This is the default behaviour. Ontrack takes the ownership of the pull request lifecycle:

* PR is approved automatically
* Ontrack waits for the PR to become mergeable
* Ontrack merges the PR
|Full visibility on the PR lifecycle within Ontrack
|This creates additional load on Ontrack

|`SCM`
a|Ontrack relies on the SCM (GitHub for example) for the lifecycle of the pull request, in a "fire and forget" mode:

* PR is approved automatically
* PR is set for auto merge
* In the background, the PR will be merged automatically once all the conditions are met, but Ontrack does not follow that up
|Less load on Ontrack since the PR lifecycle is fully managed by the SCM
|Less visibility on the PR lifecycle from Ontrack

|===

[[auto-versioning-pr-config]]
===== General configuration

Both modes, `CLIENT` and `SCM`, need the SCM configuration used by Ontrack to have additional attributes.

[[auto-versioning-pr-config-github]]
====== General configuration for GitHub

The GitHub configuration used by the Ontrack project must have its `autoMergeToken` attribute set to a GitHub Personal Access Token with the following permissions:

* `repo`

and the corresponding user must have at least the `Triage` role on the target repositories.

[IMPORTANT]
====
This `autoMergeToken` must be linked to a user _which is not_ the user used by the GitHub configuration.
It's because a user cannot approve their own pull requests.
====

[[auto-versioning-pr-client]]
===== `CLIENT` mode

No specific configuration is needed for the `CLIENT` mode.

[[auto-versioning-pr-scm]]
===== `SCM` mode

There is some configuration to be done at SCM level.

[[auto-versioning-pr-scm-github]]
===== `SCM` mode for GitHub

The target repository, the one defining the project being auto-versioned, must have the following settings:

* the `Allow auto-merge` feature must be enabled in the repository

[[auto-versioning-check]]
==== Auto versioning checks

While auto versioning is configured to automatically upgrade branches upon the promotion of some other projects, it's also possible to use this very configuration to check if a given build is up-to-date or not with the latest dependencies.

By calling the `POST /extension/auto-versioning/build/{buildId}/check` end point, where `buildId` is the ID of the build to check, you create a <<model,validation run>> on this build:

* it'll be PASSED if the dependencies are up-to-date
* FAILED otherwise

The name of the validation stamp is defined by the `validationStamp` parameter in the <<auto-versioning-config,configuration of the branch>>:

* if defined, will use this name
* if set to `auto`, the validation stamp name will be `auto-versioning-<project>`, with `<project>` being the name of the source project
* if not set, no validation is created

[NOTE]
====
You should seldom call this endpoint directly and rather use one of the existing integrations:

* <<integration-github-ingestion,GitHub ingestion>>
* <<feeding-jenkins-library,the Jenkins pipeline library>>
====

[[auto-versioning-audit]]
==== Audit logs

All auto versioning processes and all their statuses are recorded in an audit log, which can be accessed using dedicated pages (and the <<integration-graphql,GraphQL API>>).

The auto versioning audit can be accessed:

* from the _Auto versioning audit_ user menu, for all projects and branches
* from the _Tools > Auto versioning audit (target)_ from a project page when the project is considered a _target_ of the auto versioning
* from the _Tools > Auto versioning audit (source)_ from a project page when the project is considered a _source_ of the auto versioning
* from the _Tools > Auto versioning audit_ from a branch page when the branch is targeted by the auto versioning

All these pages are similar and show:

* a form to filter the audit log entries
* a paginated list of audit log entries

Each log entry contains the following information:

* target project and branch (only available in global & project views)
* source project
* version being updated
* <<auto-versioning-post-processing,post-processing>> ID if any
* <<auto-versioning-pr,auto approval mode>> if any
* running flag - is the auto versioning process still running?
* current state of the auto versioning process
* link to the <<auto-versioning-pr,PR>> if any
* timestamp of the latest state
* duration of the process until the latest state
* a button to show more details about the process

When the details are shown, the following information is available:

* the history of the states of the process
* a JSON representation of the auto versioning order

[[auto-versioning-audit-cleanup]]
===== Audit cleanup

To avoid accumulating audit log entries forever, a cleanup job is run every day to remove obsolete entries.
The behaviour of the cleanup is controlled through the <<auto-versioning-settings,global settings>>.

[[auto-versioning-audit-metrics]]
===== Audit metrics

The following operational metrics is exposed as a gauge by the Ontrack auto versioning feature:

* `ontrack_extension_auto_versioning_audit_state`
* tags: `state` auto versioning state
* count of auto versioning entries having this state

[[auto-versioning-notifications]]
==== Notifications

The auto versioning feature integrates with the <<notifications>> framework by emitting several events you can subscribe to:

* `auto-versioning-success` - whenever an auto versioning process completes
* `auto-versioning-error` - whenever an auto versioning process finishes with an error
* `auto-versioning-pr-merge-timeout-error` - whenever an auto versioning process cannot merge a pull request because of a timeout on its merge condition (only when `autoApprovalMode` is set to `CLIENT` - see <<auto-versioning-pr>>)

[[auto-versioning-cancellations]]
==== Cancellations

By default, when auto versioning requests pile up for a given source and target, all the intermediary processing requests are cancelled.

For example, given the following scenario, for a given source project and a given target branch:

* (1) auto versioning to version 1.0.1
* auto versioning to version 1.0.2 while (1) is still processed
* auto versioning to version 1.0.3 while (1) is still processed
* auto versioning to version 1.0.4 while (1) is finished

In this scenario, the processing of 1.0.1 and 1.0.4 will have been processed and completed while 1.0.2 and 1.0.3 would have been cancelled.

[NOTE]
====
The auto cancellation can be disabled by setting the `ontrack.extension.auto-versioning.queue.cancelling` <<configuration-properties-auto-versioning,configuration property>> to `false`.
====

[[auto-versioning-metrics]]
==== Metrics

The following operational metrics are exposed by Ontrack, which allow to track the load of the auto versioning processes:

|===
|Metric |Tags |Description |Type

|ontrack_extension_auto_versioning_queue_produced_count
a|
* `routingKey` - RabbitMQ routing key used for the processing
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Number of processing orders queued
| Count

|ontrack_extension_auto_versioning_queue_consumed_count
a|
* `queue` - RabbitMQ queue used for the processing
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Number of processing orders queued
| Count

|ontrack_extension_auto_versioning_processing_completed_count
a|
* `outcome` - Result of the processing, one of `CREATED`, `SAME_VERSION` or `NO_CONFIG`
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Number of processing orders queued
| Count

|ontrack_extension_auto_versioning_processing_error_count
| None
| Number of processing orders stopped because of an error
| Count

|ontrack_extension_auto_versioning_processing_time
a|
* `queue` - RabbitMQ queue used for the processing
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Time it took to process an order
| Timer

|ontrack_extension_auto_versioning_post_processing_started_count
a|
* `postProcessing` - ID of the post-processor (`github`, ...)
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Number of post-processing having started
| Count

|ontrack_extension_auto_versioning_post_processing_success_count
a|
* `postProcessing` - ID of the post-processor (`github`, ...)
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Number of post-processing having completed with success
| Count

|ontrack_extension_auto_versioning_post_processing_error_count
a|
* `postProcessing` - ID of the post-processor (`github`, ...)
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Number of post-processing having completed with an error
| Count

|ontrack_extension_auto_versioning_post_processing_time
a|
* `postProcessing` - ID of the post-processor (`github`, ...)
* `sourceProject` - source project
* `targetProject` - target project
* `targetBranch` - target branch
| Time it took to complete the post-processing
| Timer
|===

